// === LIBRARY — Lincoln v17.0.0-phase1 ===
// Phase 1: Infrastructure Implementation
// Components: lcInit, Tools, Utils, currentAction, Flags, Drafts, Turns, CommandsRegistry

(function () {
  const __SCRIPT_SLOT__ = "Library";
  const __VERSION__ = "17.0.0-phase1";

  // Create or reuse global LC object
  const LC = (typeof globalThis !== "undefined" ? (globalThis.LC ||= {}) : (window.LC ||= {}));

  // Version tracking
  LC.DATA_VERSION = __VERSION__;

  // ============================================================================
  // COMPONENT 1: lcInit - Enhanced State Initialization
  // ============================================================================
  
  /**
   * Initialize state.lincoln structure
   * Creates comprehensive state object with all infrastructure components
   * @returns {object} state.lincoln object
   */
  LC.lcInit = function () {
    const s = typeof state !== "undefined" ? state : {};
    
    // Initialize state.lincoln (NOT state.shared.lincoln per Phase 1 requirements)
    if (!s.lincoln) {
      s.lincoln = {
        // Core metadata
        version: __VERSION__,
        stateVersion: 0,      // Incremented on every state write for cache invalidation
        turn: 0,              // Turn counter
        initialized: true,
        timestamp: Date.now(),
        
        // Current action tracking
        currentAction: {
          type: "story",      // "story", "do", "say", etc.
          rawText: "",
          normalized: ""
        },
        
        // Output message queue
        drafts: [],
        
        // Characters data (populated by engines in later phases)
        characters: {},
        
        // Placeholder for future engines (Phase 2+)
        time: {},
        environment: {},
        relations: {},
        hierarchy: {},
        rumors: [],
        lore: [],
        myths: [],
        evergreen: [],
        secrets: []
      };
      
      console.log("[LIBRARY] Initialized state.lincoln v" + __VERSION__);
    }
    
    return s.lincoln;
  };

  // ============================================================================
  // COMPONENT 2: LC.Tools - Safety Utilities
  // ============================================================================
  
  LC.Tools = {
    /**
     * Safe regex match - prevents regex DoS and handles errors
     * @param {string} text - Text to search
     * @param {RegExp|string} pattern - Pattern to match (regex or string)
     * @param {string} flags - Optional regex flags (e.g., "gi")
     * @returns {Array|null} - Match results or null
     */
    safeRegexMatch: function(text, pattern, flags) {
      try {
        if (!text || typeof text !== "string") {
          return null;
        }
        
        var regex;
        if (pattern instanceof RegExp) {
          regex = pattern;
        } else if (typeof pattern === "string") {
          regex = new RegExp(pattern, flags || "");
        } else {
          return null;
        }
        
        // Prevent catastrophic backtracking by limiting input length
        var maxLength = 10000;
        var safeText = text.length > maxLength ? text.substring(0, maxLength) : text;
        
        var matches = safeText.match(regex);
        return matches;
      } catch (error) {
        console.warn("[LC.Tools.safeRegexMatch] Error: " + error.message);
        return null;
      }
    },
    
    /**
     * Escape special regex characters in a string
     * @param {string} str - String to escape
     * @returns {string} - Escaped string safe for use in RegExp
     */
    escapeRegex: function(str) {
      if (!str || typeof str !== "string") {
        return "";
      }
      // Escape special regex characters: . * + ? ^ $ { } ( ) | [ ] \
      return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
  };

  // ============================================================================
  // COMPONENT 3: LC.Utils - Type Conversion Utilities
  // ============================================================================
  
  LC.Utils = {
    /**
     * Convert value to number with default fallback
     * @param {*} value - Value to convert
     * @param {number} defaultValue - Default if conversion fails (default: 0)
     * @returns {number} - Converted number or default
     */
    toNum: function(value, defaultValue) {
      var def = typeof defaultValue === "number" ? defaultValue : 0;
      
      if (typeof value === "number") {
        return isNaN(value) ? def : value;
      }
      
      if (typeof value === "string") {
        var parsed = parseFloat(value);
        return isNaN(parsed) ? def : parsed;
      }
      
      if (typeof value === "boolean") {
        return value ? 1 : 0;
      }
      
      return def;
    },
    
    /**
     * Convert value to string
     * @param {*} value - Value to convert
     * @param {string} defaultValue - Default if conversion fails (default: "")
     * @returns {string} - Converted string or default
     */
    toStr: function(value, defaultValue) {
      var def = typeof defaultValue === "string" ? defaultValue : "";
      
      if (value === null || value === undefined) {
        return def;
      }
      
      if (typeof value === "string") {
        return value;
      }
      
      try {
        return String(value);
      } catch (error) {
        console.warn("[LC.Utils.toStr] Conversion error: " + error.message);
        return def;
      }
    },
    
    /**
     * Convert value to boolean
     * @param {*} value - Value to convert
     * @param {boolean} defaultValue - Default if conversion fails (default: false)
     * @returns {boolean} - Converted boolean or default
     */
    toBool: function(value, defaultValue) {
      var def = typeof defaultValue === "boolean" ? defaultValue : false;
      
      if (typeof value === "boolean") {
        return value;
      }
      
      if (typeof value === "number") {
        return value !== 0;
      }
      
      if (typeof value === "string") {
        var lower = value.toLowerCase().trim();
        if (lower === "true" || lower === "yes" || lower === "1") {
          return true;
        }
        if (lower === "false" || lower === "no" || lower === "0" || lower === "") {
          return false;
        }
      }
      
      return def;
    },
    
    /**
     * Clamp a number between min and max
     * @param {number} value - Value to clamp
     * @param {number} min - Minimum value
     * @param {number} max - Maximum value
     * @returns {number} - Clamped value
     */
    clamp: function(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }
  };

  // ============================================================================
  // COMPONENT 4: currentAction - Unified Action Tracking
  // ============================================================================
  
  /**
   * Update current action in state.lincoln.currentAction
   * Called from Input modifier to track what type of action the user is taking
   * @param {string} type - Action type: "story", "do", "say", "alter", etc.
   * @param {string} rawText - Original input text
   */
  LC.updateCurrentAction = function(type, rawText) {
    var L = LC.lcInit();
    
    L.currentAction = L.currentAction || {};
    L.currentAction.type = LC.Utils.toStr(type, "story");
    L.currentAction.rawText = LC.Utils.toStr(rawText, "");
    L.currentAction.normalized = LC.Utils.toStr(rawText, "").trim().toLowerCase();
    
    // Increment state version
    L.stateVersion = (L.stateVersion || 0) + 1;
    
    console.log("[LC.updateCurrentAction] Type: " + L.currentAction.type + " | Text length: " + L.currentAction.rawText.length);
  };
  
  /**
   * Get current action type
   * @returns {string} - Current action type
   */
  LC.getCurrentActionType = function() {
    var L = LC.lcInit();
    return (L.currentAction && L.currentAction.type) || "story";
  };

  // ============================================================================
  // COMPONENT 5: LC.Flags - Compatibility Facade for currentAction
  // ============================================================================
  
  LC.Flags = {
    /**
     * Check if current action is "do" type
     * @returns {boolean}
     */
    isDo: function() {
      return LC.getCurrentActionType() === "do";
    },
    
    /**
     * Check if current action is "say" type
     * @returns {boolean}
     */
    isSay: function() {
      return LC.getCurrentActionType() === "say";
    },
    
    /**
     * Check if current action is "story" type
     * @returns {boolean}
     */
    isStory: function() {
      return LC.getCurrentActionType() === "story";
    },
    
    /**
     * Check if current action is "alter" type
     * @returns {boolean}
     */
    isAlter: function() {
      return LC.getCurrentActionType() === "alter";
    },
    
    /**
     * Get current action raw text
     * @returns {string}
     */
    getText: function() {
      var L = LC.lcInit();
      return (L.currentAction && L.currentAction.rawText) || "";
    },
    
    /**
     * Get current action normalized text
     * @returns {string}
     */
    getNormalizedText: function() {
      var L = LC.lcInit();
      return (L.currentAction && L.currentAction.normalized) || "";
    }
  };

  // ============================================================================
  // COMPONENT 6: LC.Drafts - Output Message Queue Management
  // ============================================================================
  
  LC.Drafts = {
    /**
     * Add a message to the output queue
     * @param {string} message - Message to queue
     * @param {number} priority - Priority (higher = shown first), default 0
     */
    add: function(message, priority) {
      var L = LC.lcInit();
      
      L.drafts = L.drafts || [];
      L.drafts.push({
        message: LC.Utils.toStr(message, ""),
        priority: LC.Utils.toNum(priority, 0),
        timestamp: Date.now()
      });
      
      L.stateVersion = (L.stateVersion || 0) + 1;
      
      console.log("[LC.Drafts.add] Queued message (priority: " + priority + ")");
    },
    
    /**
     * Get all messages and clear the queue
     * Messages are sorted by priority (highest first)
     * @returns {string} - Concatenated messages with newlines
     */
    flush: function() {
      var L = LC.lcInit();
      
      if (!L.drafts || L.drafts.length === 0) {
        return "";
      }
      
      // Sort by priority (highest first)
      var sorted = L.drafts.slice().sort(function(a, b) {
        return (b.priority || 0) - (a.priority || 0);
      });
      
      // Extract messages
      var messages = [];
      for (var i = 0; i < sorted.length; i++) {
        if (sorted[i].message) {
          messages.push(sorted[i].message);
        }
      }
      
      // Clear queue
      L.drafts = [];
      L.stateVersion = (L.stateVersion || 0) + 1;
      
      console.log("[LC.Drafts.flush] Flushed " + messages.length + " message(s)");
      
      return messages.join("\n\n");
    },
    
    /**
     * Peek at queued messages without clearing
     * @returns {Array} - Array of draft objects
     */
    peek: function() {
      var L = LC.lcInit();
      return (L.drafts || []).slice(); // Return copy
    },
    
    /**
     * Clear all queued messages
     */
    clear: function() {
      var L = LC.lcInit();
      L.drafts = [];
      L.stateVersion = (L.stateVersion || 0) + 1;
      console.log("[LC.Drafts.clear] Cleared queue");
    }
  };

  // ============================================================================
  // COMPONENT 7: LC.Turns - Turn Counter Logic
  // ============================================================================
  
  LC.Turns = {
    /**
     * Get current turn number
     * @returns {number} - Current turn
     */
    get: function() {
      var L = LC.lcInit();
      return LC.Utils.toNum(L.turn, 0);
    },
    
    /**
     * Increment turn counter
     * Called from Output modifier
     * @returns {number} - New turn number
     */
    increment: function() {
      var L = LC.lcInit();
      L.turn = (L.turn || 0) + 1;
      L.stateVersion = (L.stateVersion || 0) + 1;
      console.log("[LC.Turns.increment] Turn: " + L.turn);
      return L.turn;
    },
    
    /**
     * Set turn to specific value (for testing/debugging)
     * @param {number} value - New turn value
     */
    set: function(value) {
      var L = LC.lcInit();
      L.turn = LC.Utils.toNum(value, 0);
      L.stateVersion = (L.stateVersion || 0) + 1;
      console.log("[LC.Turns.set] Turn: " + L.turn);
    }
  };

  // ============================================================================
  // COMPONENT 8: LC.CommandsRegistry - Command Registry (PLAIN OBJECT)
  // ============================================================================
  
  /**
   * CommandsRegistry - Plain object for storing command handlers
   * ES5-compatible, NOT using Map
   */
  LC.CommandsRegistry = {
    // Internal storage (plain object)
    _handlers: {},
    
    /**
     * Register a command handler
     * @param {string} command - Command name (without leading slash)
     * @param {function} handler - Handler function (args) => {}
     */
    register: function(command, handler) {
      if (!command || typeof command !== "string") {
        console.warn("[CommandsRegistry.register] Invalid command name");
        return;
      }
      
      if (typeof handler !== "function") {
        console.warn("[CommandsRegistry.register] Handler must be a function");
        return;
      }
      
      var key = command.toLowerCase().trim();
      this._handlers[key] = handler;
      console.log("[CommandsRegistry.register] Registered: /" + key);
    },
    
    /**
     * Execute a command
     * @param {string} input - Raw input text (may include leading slash)
     * @returns {string|null} - Command result or null if not a command
     */
    execute: function(input) {
      if (!input || typeof input !== "string") {
        return null;
      }
      
      var trimmed = input.trim();
      
      // Check if input starts with /
      if (!trimmed || trimmed.charAt(0) !== "/") {
        return null;
      }
      
      // Parse command and arguments
      var parts = trimmed.substring(1).split(/\s+/);
      var command = parts[0].toLowerCase();
      var args = parts.slice(1);
      
      // Look up handler
      var handler = this._handlers[command];
      
      if (!handler) {
        return null; // Unknown command, let input pass through
      }
      
      // Execute handler
      try {
        var result = handler(args);
        return LC.Utils.toStr(result, "");
      } catch (error) {
        console.error("[CommandsRegistry.execute] Error executing /" + command + ": " + error.message);
        return "[ERROR] Command failed: " + error.message;
      }
    },
    
    /**
     * Check if a command is registered
     * @param {string} command - Command name
     * @returns {boolean}
     */
    has: function(command) {
      var key = LC.Utils.toStr(command, "").toLowerCase().trim();
      return this._handlers.hasOwnProperty(key);
    },
    
    /**
     * List all registered commands
     * @returns {Array} - Array of command names
     */
    list: function() {
      var commands = [];
      for (var key in this._handlers) {
        if (this._handlers.hasOwnProperty(key)) {
          commands.push(key);
        }
      }
      return commands.sort();
    }
  };

  // ============================================================================
  // PHASE 1 TEST COMMANDS
  // ============================================================================
  
  // Register test commands for Phase 1 validation
  
  LC.CommandsRegistry.register("ping", function(args) {
    return "[PONG] Lincoln v" + __VERSION__ + " is alive! Turn: " + LC.Turns.get();
  });
  
  LC.CommandsRegistry.register("turn", function(args) {
    return "[TURN] Current turn: " + LC.Turns.get();
  });
  
  LC.CommandsRegistry.register("debug", function(args) {
    var L = LC.lcInit();
    var info = [
      "[DEBUG] Lincoln v" + __VERSION__,
      "Turn: " + L.turn,
      "State Version: " + L.stateVersion,
      "Current Action: " + (L.currentAction ? L.currentAction.type : "none"),
      "Drafts Queued: " + (L.drafts ? L.drafts.length : 0),
      "Registered Commands: " + LC.CommandsRegistry.list().length
    ];
    return info.join("\n");
  });
  
  LC.CommandsRegistry.register("draft", function(args) {
    if (args.length === 0) {
      return "[DRAFT] Usage: /draft <message>";
    }
    var message = args.join(" ");
    LC.Drafts.add(message, 0);
    return "[DRAFT] Message queued: \"" + message + "\"";
  });
  
  LC.CommandsRegistry.register("commands", function(args) {
    var cmds = LC.CommandsRegistry.list();
    return "[COMMANDS] Available (" + cmds.length + "): /" + cmds.join(", /");
  });

  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  
  // Initialize on load
  LC.lcInit();

  console.log("[LIBRARY] ═══════════════════════════════════════════════════");
  console.log("[LIBRARY] Lincoln v" + __VERSION__ + " Phase 1: Infrastructure");
  console.log("[LIBRARY] ═══════════════════════════════════════════════════");
  console.log("[LIBRARY] ✓ lcInit - State initialization");
  console.log("[LIBRARY] ✓ LC.Tools - Safety utilities");
  console.log("[LIBRARY] ✓ LC.Utils - Type conversion");
  console.log("[LIBRARY] ✓ currentAction - Action tracking");
  console.log("[LIBRARY] ✓ LC.Flags - Compatibility facade");
  console.log("[LIBRARY] ✓ LC.Drafts - Message queue");
  console.log("[LIBRARY] ✓ LC.Turns - Turn counter");
  console.log("[LIBRARY] ✓ LC.CommandsRegistry - Command parser");
  console.log("[LIBRARY] ═══════════════════════════════════════════════════");
  console.log("[LIBRARY] Test commands: /ping, /turn, /debug, /draft, /commands");
  console.log("[LIBRARY] ═══════════════════════════════════════════════════");
})();
