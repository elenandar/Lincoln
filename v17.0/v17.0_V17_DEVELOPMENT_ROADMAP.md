# Project Lincoln: v17 Development Roadmap

**Автор:** Copilot  
**Дата:** 13 октября 2025  
**На основе:** `v17.0/V16_MECHANICS_AUDIT.md`  
**Цель:** Определить пошаговый план разработки и внедрения систем для версии v17, следуя принципу инкрементального развития и постоянного тестирования в реальной игровой среде.

---

## 1. Философия и Основные Принципы

Разработка v17 — это не исправление v16, а её **перерождение**. Мы сохраняем блестящую архитектуру и концепции, но строим их заново на прочном, проверенном фундаменте.

1.  **Начать с Нуля ("Нулевая Система"):** Первым шагом является создание абсолютно пустых, но рабочих скриптов, которые успешно загружаются в игру, не влияя на неё. Это наша точка отсчета.
2.  **Один Движок за Раз:** Мы внедряем системы строго по одной, в порядке, определенном этой дорожной картой. Никаких параллельных разработок.
3.  **Код с Чистого Листа:** Мы не копируем код из v16. Мы берем *идею* из аудиторского отчета и пишем её реализацию заново, адаптируя под текущую реальность AI Dungeon.
4.  **Постоянное Тестирование в Игре:** После внедрения **каждого** компонента проводится обязательный запуск в игре для проверки стабильности и корректности работы. Любая ошибка — немедленный приоритет.

---

## 2. Дорожная Карта: Поэтапное Внедрение

### Фаза 1: Фундамент и Утилиты

**Цель:** Создать базовый каркас для управления состоянием и отладки. Получить возможность "общаться" с системой через команды.

| № | Компонент | Назначение из Аудита (v16) | Задачи для v17 (Минимальная реализация) | Команды для Тестирования | Критерий Успеха |
|---|---|---|---|---|---|
| 1.1 | **`lcInit` & State Management** | #33: Централизованная инициализация | Создать `Library.js` с функцией `LC.lcInit()`, которая создает и возвращает пустой объект `state.lincoln`. | - | Игра загружается без ошибок. В `state.shared` появляется объект `lincoln`. |
| 1.2 | **System Messages** | - | Создать утилиты `LC.sysLine()` и `LC.sysBlock()` для форматирования системных сообщений. `Output.js` должен уметь их отображать. | - | Сообщения, добавленные в очередь, корректно отображаются в выводе. |
| 1.3 | **`CommandsRegistry`** | #24: Реестр команд | Создать `LC.CommandsRegistry` (пустой `Map`). `Input.js` должен парсить текст, находить команды ( `/` ) и пытаться их выполнить. | `/ping` | При вводе `/ping` система должна отвечать `pong` через системное сообщение. |
| 1.4 | **`currentAction`** | #34: Объектная модель действий | Внедрить объект `L.currentAction` для отслеживания типа действия (`story`, `command`, `retry`). | - | При вводе команды в `L.currentAction.type` устанавливается `command`. |

**Результат Фазы 1:** У нас есть "скелет" системы. Он ничего не симулирует, но загружается, управляет состоянием и позволяет нам добавлять отладочные команды.

---

### Фаза 2: Симуляция Физического Мира

**Цель:** Заложить основы пространства и времени. Мир перестает быть статичным.

| № | Компонент | Назначение из Аудита (v16) | Задачи для v17 (Минимальная реализация) | Команды для Тестирования | Критерий Успеха |
|---|---|---|---|---|---|
| 2.1 | **`TimeEngine`** | #7: Система времени | Реализовать базовый счетчик ходов (`L.turn`). `Output.js` инкрементирует его на каждом сюжетном действии. Реализовать базовую структуру `L.time` (день, время суток). | `/time` | Команда `/time` показывает текущий ход и день. Счетчик ходов корректно увеличивается. |
| 2.2 | **`EnvironmentEngine`** | #8: Симуляция окружения | Реализовать структуру `L.environment` (погода, локация). `Output.js` не должен ничего анализировать автоматически. | `/weather set rain`, `/location set home` | Команды успешно меняют значения в `L.environment`. `state` сохраняется. |

**Результат Фазы 2:** В мире появилось время, которое течет, и окружение, которое мы можем изменять вручную.

---

### Фаза 3: Социальная Динамика

**Цель:** Ввести персонажей и симуляцию базовых социальных взаимодействий.

| № | Компонент | Назначение из Аудита (v16) | Задачи для v17 (Минимальная реализация) | Команды для Тестирования | Критерий Успеха |
|---|---|---|---|---|---|
| 3.1 | **`RelationshipEngine`**| #4: Управление отношениями | Реализовать структуру `L.relations`. Создать функции `getRelation` и `modifyRelation`. | `/relation set Alice Bob 50` | Команда успешно создает/изменяет запись об отношениях в `L.relations`. |
| 3.2 | **`HierarchyEngine`** | #10: Социальная иерархия | Реализовать структуру `L.characters[name].capital`. Функция `recalculateStatus` должна просто присваивать статус (`leader`, `outcast`) на основе капитала. | `/capital set Alice 110` | После выполнения команды статус персонажа Alice меняется на `leader`. |
| 3.3 | **`GossipEngine`** | #9: Система слухов | Реализовать структуру `L.rumors`. Создать функцию для добавления слуха вручную. Без авто-анализа. | `/rumor add "слух о..." about Alice` | Команда добавляет новый слух в массив `L.rumors`. |

**Результат Фазы 3:** Мы можем вручную создавать социальную картину мира: определять персонажей, их отношения, статусы и слухи о них.

---

### Фаза 4: Сознание и Субъективность

**Цель:** Реализовать ключевую инновацию проекта — внутренний мир персонажей.

| № | Компонент | Назначение из Аудита (v16) | Задачи для v17 (Минимальная реализация) | Команды для Тестирования | Критерий Успеха |
|---|---|---|---|---|---|
| 4.1 | **`QualiaEngine`** | #15: Феноменальное ядро | Реализовать структуру `L.characters[name].qualia_state` (valence, tension). | `/qualia set Alice valence 0.8` | Команда изменяет внутреннее состояние персонажа. |
| 4.2 | **`InformationEngine`**| #5: Субъективная реальность | **[Сложный этап]** Написать функцию `interpret(character, event)`. Она должна принимать простое событие (например, `{type: 'praise'}`) и возвращать разную интерпретацию в зависимости от `qualia_state.valence`. | `/interpret Alice praise` | Команда должна выводить в чат разный текст в зависимости от текущей "валентности" Алисы. |
| 4.3 | **`CrucibleEngine`** | #16: Формирование личности | Реализовать структуру `L.characters[name].self_concept`. Написать одну функцию, которая на событие `betrayal` немного понижает `perceived_trust`. | `/event trigger Alice betrayal` | После команды значение `perceived_trust` у Алисы в `state` уменьшается. |

**Результат Фазы 4:** Персонажи обретают внутренний мир. Мы можем симулировать, как их "ощущения" влияют на восприятие событий.

---

### Фаза 5: Культура и Память

**Цель:** Ввести высший уровень симуляции — коллективную память и историю.

| № | Компонент | Назначение из Аудита (v16) | Задачи для v17 (Минимальная реализация) | Команды для Тестирования | Критерий Успеха |
|---|---|---|---|---|---|
| 5.1 | **`LoreEngine`** | #13: Школьные легенды | Реализовать структуру `L.lore`. Создать функцию `crystallize(event)` для ручного добавления легенды. | `/lore add "Легенда о..."` | Команда добавляет новую легенду в `L.lore`. |
| 5.2 | **`MemoryEngine`** | #12: Мифологизация памяти | Реализовать структуру `L.myths`. Создать функцию для ручного добавления мифа. | `/myth add "Миф о..."` | Команда добавляет новый миф в `L.myths`. |

**Результат Фазы 5:** Система может хранить культурные артефакты (легенды и мифы), которые в будущем будут влиять на поведение персонажей.

---

### Фаза 6 и далее: Интеграция и Автоматизация

После того как все движки будут реализованы в минимальном виде и их ручное управление будет протестировано, начнется самая интересная работа:

-   **Создание `UnifiedAnalyzer`:** Написание единого анализатора, который будет автоматически вызывать `analyze()` каждого движка.
-   **Сборка Контекста:** Постепенное добавление данных из каждого движка в `composeContextOverlay`.
-   **Расширение Функционала:** Добавление более сложной логики в каждый движок (например, автоматическое распространение слухов, расчет социального капитала и т.д.).

Этот план обеспечивает максимальную предсказуемость и контроль. Мы строим наш "небоскреб" этаж за этажом, убеждаясь в прочности каждого перед тем, как перейти к следующему.

**Конец документа.**