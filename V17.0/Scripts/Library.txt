// Lincoln v17 - Library Script (Phase 1: Infrastructure)
// This script executes BEFORE each hook (Input/Context/Output) - 3x per turn
// Version: 17.0.0-phase1

// Initialize state.lincoln if not exists or version mismatch
if (!state.lincoln || state.lincoln.version !== "17.0.0") {
    state.lincoln = {
        version: "17.0.0",
        stateVersion: 0,
        initialized: true,
        turn: 0,
        currentAction: "",
        drafts: [],
        characters: {},
        relations: {},
        hierarchy: {},
        rumors: [],
        lore: [],
        myths: [],
        time: {
            day: 1,
            hour: 8,
            minute: 0,
            timeString: "Day 1, Morning (8:00 AM)",
            timeOfDay: "Morning",
            currentScene: "general",
            sceneStartTurn: 0,
            sceneTurnCount: 0,
            sceneMinutes: 0,
            mode: "hybrid",
            totalMinutesPassed: 0
        },
        environment: {},
        evergreen: [],
        secrets: []
    };
}

// Lincoln Core (LC) - recreated on each Library execution
const LC = (function() {
    // Constants
    var COMMAND_PREFIX = '/';
    var ACTION_TYPES = {
        COMMAND: 'command',
        ACTION: 'action',
        EMPTY: 'empty'
    };
    
    return {
        // Constants exposed
        Constants: {
            COMMAND_PREFIX: COMMAND_PREFIX,
            ACTION_TYPES: ACTION_TYPES
        },
        
        // Tools - Safety utilities (#19)
        Tools: {
            safeRegexMatch: function(text, pattern) {
                try {
                    return text.match(pattern) || [];
                } catch (e) {
                    console.log("Regex error:", e);
                    return [];
                }
            },
            
            escapeRegex: function(str) {
                try {
                    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                } catch (e) {
                    console.log("Escape regex error:", e);
                    return str;
                }
            }
        },
        
        // Utils - Type conversion and helper methods (#20)
        Utils: {
            toNum: function(value, defaultVal) {
                try {
                    var num = parseFloat(value);
                    return isNaN(num) ? (defaultVal !== undefined ? defaultVal : 0) : num;
                } catch (e) {
                    return defaultVal !== undefined ? defaultVal : 0;
                }
            },
            
            toStr: function(value, defaultVal) {
                try {
                    if (value === null || value === undefined) {
                        return defaultVal !== undefined ? defaultVal : "";
                    }
                    return String(value);
                } catch (e) {
                    return defaultVal !== undefined ? defaultVal : "";
                }
            },
            
            toBool: function(value, defaultVal) {
                try {
                    if (value === null || value === undefined) {
                        return defaultVal !== undefined ? defaultVal : false;
                    }
                    return Boolean(value);
                } catch (e) {
                    return defaultVal !== undefined ? defaultVal : false;
                }
            },
            
            clamp: function(value, min, max) {
                return Math.max(min, Math.min(max, value));
            }
        },
        
        // Flags - Debugging flags and currentAction facade (#21)
        Flags: {
            setCurrentAction: function(actionType) {
                try {
                    state.lincoln.currentAction = actionType;
                    state.lincoln.stateVersion++;
                } catch (e) {
                    console.log("Flags.setCurrentAction error:", e);
                }
            },
            
            getCurrentAction: function() {
                try {
                    return state.lincoln.currentAction || "";
                } catch (e) {
                    console.log("Flags.getCurrentAction error:", e);
                    return "";
                }
            }
        },
        
        // Drafts - Message queue for output hooks (#22)
        Drafts: {
            add: function(message) {
                try {
                    if (!state.lincoln.drafts) {
                        state.lincoln.drafts = [];
                    }
                    state.lincoln.drafts.push(message);
                    state.lincoln.stateVersion++;
                } catch (e) {
                    console.log("Drafts.add error:", e);
                }
            },
            
            get: function() {
                try {
                    return state.lincoln.drafts || [];
                } catch (e) {
                    console.log("Drafts.get error:", e);
                    return [];
                }
            },
            
            clear: function() {
                try {
                    state.lincoln.drafts = [];
                    state.lincoln.stateVersion++;
                } catch (e) {
                    console.log("Drafts.clear error:", e);
                }
            }
        },
        
        // Turns - Turn counter management (#23)
        Turns: {
            increment: function() {
                try {
                    state.lincoln.turn++;
                    state.lincoln.stateVersion++;
                } catch (e) {
                    console.log("Turns.increment error:", e);
                }
            },
            
            get: function() {
                try {
                    return state.lincoln.turn || 0;
                } catch (e) {
                    console.log("Turns.get error:", e);
                    return 0;
                }
            },
            
            set: function(value) {
                try {
                    state.lincoln.turn = LC.Utils.toNum(value, 0);
                    state.lincoln.stateVersion++;
                } catch (e) {
                    console.log("Turns.set error:", e);
                }
            }
        },
        
        // CommandsRegistry - Command processing system (#24)
        CommandsRegistry: {
            commands: {}, // Plain ES5 object, NOT Map
            prefix: '/',
            
            register: function(name, handler) {
                try {
                    this.commands[name] = handler;
                } catch (e) {
                    console.log("CommandsRegistry.register error:", e);
                }
            },
            
            detect: function(text) {
                if (!text || typeof text !== 'string') return null;
                for (var cmd in this.commands) {
                    var pattern = this.prefix + cmd;
                    if (text.indexOf(pattern) !== -1) {
                        return cmd;
                    }
                }
                return null;
            },
            
            parse: function(text, command) {
                var pattern = this.prefix + command;
                var index = text.indexOf(pattern);
                if (index === -1) return [];
                var afterCommand = text.substring(index + pattern.length);
                var argsMatch = afterCommand.match(/^[ \t]+([\w\s]+?)(?:[".\n]|$)/);
                if (argsMatch && argsMatch[1]) {
                    return argsMatch[1].replace(/^\s+|\s+$/g, '').split(/\s+/);
                }
                return [];
            },
            
            execute: function(command, args) {
                try {
                    if (this.commands[command]) {
                        return this.commands[command](args);
                    }
                    return null;
                } catch (e) {
                    console.log("CommandsRegistry.execute error:", e);
                    return "\u27E6SYS\u27E7 \u26A0\uFE0F Command error: " + e.message;
                }
            }
        },
        
        // CharacterTracker - Extract and track character states (#33)
        CharacterTracker: {
            // Common words to exclude from character extraction
            _commonWords: [
                'The', 'You', 'Your', 'They', 'Their', 'This', 'That', 'These', 'Those',
                'What', 'When', 'Where', 'Which', 'Who', 'Why', 'How',
                'But', 'And', 'Or', 'Not', 'So', 'As', 'At', 'By', 'For', 'From',
                'In', 'Of', 'On', 'To', 'Up', 'With', 'After', 'Before', 'During',
                'Since', 'Until', 'While', 'About', 'Against', 'Between', 'Into',
                'Through', 'Under', 'Over', 'Above', 'Below', 'Can', 'Could',
                'May', 'Might', 'Must', 'Should', 'Would', 'Will', 'Shall'
            ],
            
            extract: function(text) {
                try {
                    // Simple character extraction - looks for capitalized names
                    var matches = LC.Tools.safeRegexMatch(text, /\b[A-Z][a-z]+\b/g);
                    var characters = [];
                    
                    for (var i = 0; i < matches.length; i++) {
                        var name = matches[i];
                        // ES5: Use indexOf instead of includes
                        // Filter out common words
                        if (this._commonWords.indexOf(name) === -1 && 
                            characters.indexOf(name) === -1) {
                            characters.push(name);
                        }
                    }
                    
                    return characters;
                } catch (e) {
                    console.log("CharacterTracker.extract error:", e);
                    return [];
                }
            },
            
            ensure: function(name) {
                try {
                    if (!state.lincoln.characters[name]) {
                        state.lincoln.characters[name] = {
                            name: name,
                            created: state.lincoln.turn
                        };
                        state.lincoln.stateVersion++;
                    }
                } catch (e) {
                    console.log("CharacterTracker.ensure error:", e);
                }
            },
            
            exists: function(name) {
                try {
                    return state.lincoln.characters[name] !== undefined;
                } catch (e) {
                    console.log("CharacterTracker.exists error:", e);
                    return false;
                }
            }
        },
        
        // InputProcessor - Normalize and analyze player input (#34)
        InputProcessor: {
            normalize: function(text) {
                try {
                    if (!text || typeof text !== 'string') {
                        return "";
                    }
                    
                    // Trim whitespace
                    var normalized = text.replace(/^\s+|\s+$/g, '');
                    
                    // Collapse multiple spaces
                    normalized = normalized.replace(/\s+/g, ' ');
                    
                    return normalized;
                } catch (e) {
                    console.log("InputProcessor.normalize error:", e);
                    return text;
                }
            },
            
            isCommand: function(text) {
                try {
                    return text && typeof text === 'string' && text.charAt(0) === COMMAND_PREFIX;
                } catch (e) {
                    console.log("InputProcessor.isCommand error:", e);
                    return false;
                }
            },
            
            analyze: function(text) {
                try {
                    var normalized = this.normalize(text);
                    var isCommand = this.isCommand(normalized);
                    
                    return {
                        original: text,
                        normalized: normalized,
                        isCommand: isCommand,
                        isEmpty: normalized.length === 0
                    };
                } catch (e) {
                    console.log("InputProcessor.analyze error:", e);
                    return {
                        original: text,
                        normalized: text,
                        isCommand: false,
                        isEmpty: true
                    };
                }
            }
        },
        
        // SysOutput - Format system messages for AI Dungeon visibility (#35)
        SysOutput: {
            formatLine: function(msg) {
                try {
                    var s = LC.Utils.toStr(msg, "").replace(/^\s+|\s+$/g, '');
                    return s ? "\u27E6SYS\u27E7 " + s : "";
                } catch (e) {
                    console.log("SysOutput.formatLine error:", e);
                    return "";
                }
            }
        },
        
        // TimeEngine - Hybrid time progression system (Phase 2)
        TimeEngine: {
            // Scene configuration: rates in minutes/turn, maxDuration in minutes
            _sceneConfig: {
                combat: { rate: 2, maxDuration: 30, keywords: ['attack', 'fight', 'battle', 'strike', 'dodge', 'swing', 'slash', 'parry', 'block', 'evade'] },
                dialogue: { rate: 5, maxDuration: 60, keywords: ['say', 'ask', 'tell', 'speak', 'talk', 'reply', 'respond', 'whisper', 'shout', 'exclaim'] },
                travel: { rate: 15, maxDuration: 180, keywords: ['walk', 'run', 'ride', 'journey', 'travel', 'move', 'head', 'depart', 'arrive', 'reach'] },
                training: { rate: 10, maxDuration: 120, keywords: ['train', 'practice', 'exercise', 'spar', 'drill', 'rehearse', 'study', 'learn'] },
                exploration: { rate: 8, maxDuration: 240, keywords: ['search', 'explore', 'examine', 'investigate', 'inspect', 'look', 'scan', 'survey'] },
                rest: { rate: 60, maxDuration: 480, keywords: ['sleep', 'rest', 'camp', 'relax', 'nap', 'doze', 'lie', 'sit'] },
                general: { rate: 10, maxDuration: null, keywords: [] }
            },
            
            // Time anchors: absolute time setters
            _timeAnchors: [
                // Next day transitions
                { pattern: /\bnext\s+morning\b/i, action: 'nextDay', hour: 8, minute: 0 },
                { pattern: /\bnext\s+day\b/i, action: 'nextDay', hour: 8, minute: 0 },
                { pattern: /\bovernight\b/i, action: 'addHours', hours: 8 },
                
                // Absolute times
                { pattern: /\bat\s+dawn\b/i, action: 'setTime', hour: 6, minute: 0 },
                { pattern: /\bin\s+the\s+early\s+morning\b/i, action: 'setTime', hour: 7, minute: 0 },
                { pattern: /\bin\s+the\s+morning\b/i, action: 'setTime', hour: 8, minute: 0 },
                { pattern: /\bat\s+noon\b/i, action: 'setTime', hour: 12, minute: 0 },
                { pattern: /\bmidday\b/i, action: 'setTime', hour: 12, minute: 0 },
                { pattern: /\bin\s+the\s+afternoon\b/i, action: 'setTime', hour: 14, minute: 0 },
                { pattern: /\bin\s+the\s+evening\b/i, action: 'setTime', hour: 18, minute: 0 },
                { pattern: /\bat\s+dusk\b/i, action: 'setTime', hour: 19, minute: 0 },
                { pattern: /\bat\s+night\b/i, action: 'setTime', hour: 21, minute: 0 },
                { pattern: /\bat\s+midnight\b/i, action: 'setTime', hour: 0, minute: 0 },
                
                // Event-based times
                { pattern: /\bbreakfast\s+time\b/i, action: 'setTime', hour: 8, minute: 0 },
                { pattern: /\bbreakfast\b/i, action: 'setTime', hour: 8, minute: 0 },
                { pattern: /\blunch\s+time\b/i, action: 'setTime', hour: 12, minute: 30 },
                { pattern: /\blunch\b/i, action: 'setTime', hour: 12, minute: 30 },
                { pattern: /\bdinner\s+time\b/i, action: 'setTime', hour: 19, minute: 0 },
                { pattern: /\bdinner\b/i, action: 'setTime', hour: 19, minute: 0 },
                { pattern: /\bafter\s+lessons?\b/i, action: 'setTime', hour: 16, minute: 0 },
                { pattern: /\bafter\s+class(?:es)?\b/i, action: 'setTime', hour: 16, minute: 0 },
                { pattern: /\bafter\s+school\b/i, action: 'setTime', hour: 16, minute: 0 },
                { pattern: /\bevening\s+training\b/i, action: 'setTime', hour: 19, minute: 0 },
                
                // Relative time (hours)
                { pattern: /(\d+)\s*hours?\s+later/i, action: 'addHours', captureGroup: 1 },
                { pattern: /(\d+)\s*hours?\s+passed/i, action: 'addHours', captureGroup: 1 },
                { pattern: /after\s+(\d+)\s*hours?/i, action: 'addHours', captureGroup: 1 },
                { pattern: /an?\s+hour\s+later/i, action: 'addHours', hours: 1 },
                { pattern: /an?\s+hour\s+passed/i, action: 'addHours', hours: 1 },
                
                // Relative time (minutes)
                { pattern: /(\d+)\s*minutes?\s+later/i, action: 'addMinutes', captureGroup: 1 },
                { pattern: /(\d+)\s*minutes?\s+passed/i, action: 'addMinutes', captureGroup: 1 },
                { pattern: /after\s+(\d+)\s*minutes?/i, action: 'addMinutes', captureGroup: 1 },
                
                // Russian: Relative time with numeric digits (hours)
                { pattern: /(?:через|спустя)\s+(\d+)\s*час(?:а|ов)?/iu, action: 'addHours', captureGroup: 1 },
                { pattern: /(\d+)\s*час(?:а|ов)?\s+спустя/iu, action: 'addHours', captureGroup: 1 },
                { pattern: /час\s+спустя/iu, action: 'addHours', hours: 1 },
                
                // Russian: Relative time with word numerals (hours)
                { pattern: /(?:через|спустя)\s+(один|одна|одно)\s+час/iu, action: 'addHours', captureGroup: 1 },
                { pattern: /(?:через|спустя)\s+(два|две|три|четыре|пять|шесть|семь|восемь|девять|десять|одиннадцать|двенадцать)\s+час(?:а|ов)/iu, action: 'addHours', captureGroup: 1 },
                { pattern: /(два|две|три|четыре|пять|шесть|семь|восемь|девять|десять|одиннадцать|двенадцать)\s+час(?:а|ов)\s+спустя/iu, action: 'addHours', captureGroup: 1 },
                { pattern: /(?:через|спустя)\s+(?:пару|несколько)\s+час(?:ов|а)/iu, action: 'addHours', hours: 2 },
                
                // Russian: Relative time with numeric digits (minutes)
                { pattern: /(?:через|спустя)\s+(\d+)\s*минут(?:у|ы)?/iu, action: 'addMinutes', captureGroup: 1 },
                { pattern: /(\d+)\s*минут(?:у|ы)?\s+спустя/iu, action: 'addMinutes', captureGroup: 1 },
                
                // Russian: Relative time with word numerals (minutes)
                { pattern: /(?:через|спустя)\s+(одну|один|две|два|три|четыре|пять|шесть|семь|восемь|девять|десять|пятнадцать|двадцать|тридцать)\s+минут(?:у|ы)?/iu, action: 'addMinutes', captureGroup: 1 },
                { pattern: /(одну|один|две|два|три|четыре|пять|шесть|семь|восемь|девять|десять|пятнадцать|двадцать|тридцать)\s+минут(?:у|ы)?\s+спустя/iu, action: 'addMinutes', captureGroup: 1 }
            ],
            
            // Scene priority (higher priority = checked first)
            _scenePriority: ['combat', 'rest', 'training', 'dialogue', 'travel', 'exploration', 'general'],
            
            // Convert Russian word numerals to numbers
            _parseRussianNumeral: function(text) {
                var russianNumerals = {
                    // Hours (1-12)
                    'один': 1, 'одна': 1, 'одно': 1,
                    'два': 2, 'две': 2,
                    'три': 3,
                    'четыре': 4,
                    'пять': 5,
                    'шесть': 6,
                    'семь': 7,
                    'восемь': 8,
                    'девять': 9,
                    'десять': 10,
                    'одиннадцать': 11,
                    'двенадцать': 12,
                    // Common minute values
                    'пятнадцать': 15,
                    'двадцать': 20,
                    'тридцать': 30,
                    // Colloquial
                    'пару': 2,
                    'несколько': 3
                };
                
                var lowerText = text.toLowerCase();
                if (russianNumerals[lowerText] !== undefined) {
                    return russianNumerals[lowerText];
                }
                
                // Try parsing as number
                var num = parseInt(text, 10);
                return isNaN(num) ? 0 : num;
            },
            
            // Detect time anchor in text
            detectAnchor: function(text) {
                try {
                    for (var i = 0; i < this._timeAnchors.length; i++) {
                        var anchor = this._timeAnchors[i];
                        var match = text.match(anchor.pattern);
                        if (match) {
                            return {
                                anchor: anchor,
                                match: match
                            };
                        }
                    }
                    return null;
                } catch (e) {
                    console.log("TimeEngine.detectAnchor error:", e);
                    return null;
                }
            },
            
            // Detect scene type from text
            detectScene: function(text) {
                try {
                    var lowerText = text.toLowerCase();
                    var sceneScores = {};
                    
                    // Score each scene type based on keyword matches
                    for (var i = 0; i < this._scenePriority.length; i++) {
                        var sceneType = this._scenePriority[i];
                        var config = this._sceneConfig[sceneType];
                        var score = 0;
                        
                        for (var j = 0; j < config.keywords.length; j++) {
                            var keyword = config.keywords[j];
                            // Use word boundaries to avoid substring matches
                            var regex = new RegExp('\\b' + keyword + '\\b', 'gi');
                            var matches = lowerText.match(regex);
                            if (matches) {
                                score += matches.length;
                            }
                        }
                        
                        if (score > 0) {
                            sceneScores[sceneType] = score;
                        }
                    }
                    
                    // Return scene with highest score (respecting priority order)
                    var bestScene = 'general';
                    var bestScore = 0;
                    for (var k = 0; k < this._scenePriority.length; k++) {
                        var scene = this._scenePriority[k];
                        if (sceneScores[scene] && sceneScores[scene] > bestScore) {
                            bestScene = scene;
                            bestScore = sceneScores[scene];
                        }
                    }
                    
                    return bestScene;
                } catch (e) {
                    console.log("TimeEngine.detectScene error:", e);
                    return 'general';
                }
            },
            
            // Calculate time progression based on hybrid logic
            calculateHybridTime: function(text) {
                try {
                    var timeState = state.lincoln.time;
                    
                    // Skip if in manual mode
                    if (timeState.mode === 'manual') {
                        return 0;
                    }
                    
                    // Priority 1: Check for time anchors
                    var anchorResult = this.detectAnchor(text);
                    if (anchorResult) {
                        return this._applyAnchor(anchorResult.anchor, anchorResult.match);
                    }
                    
                    // Priority 2: Scene-based progression
                    if (timeState.mode === 'hybrid' || timeState.mode === 'auto') {
                        var detectedScene = this.detectScene(text);
                        return this._applySceneTime(detectedScene);
                    }
                    
                    // Fallback: fixed rate (15 min/turn)
                    return 15;
                } catch (e) {
                    console.log("TimeEngine.calculateHybridTime error:", e);
                    return 10; // Fallback rate
                }
            },
            
            // Apply time anchor
            _applyAnchor: function(anchor, match) {
                try {
                    var timeState = state.lincoln.time;
                    
                    if (anchor.action === 'setTime') {
                        // Set absolute time
                        var oldMinutes = timeState.hour * 60 + timeState.minute;
                        var newMinutes = anchor.hour * 60 + anchor.minute;
                        
                        // If new time is earlier in day, assume next day
                        if (newMinutes < oldMinutes) {
                            timeState.day++;
                        }
                        
                        timeState.hour = anchor.hour;
                        timeState.minute = anchor.minute;
                        this.updateTimeString();
                        
                        // Reset scene tracking
                        timeState.sceneMinutes = 0;
                        timeState.sceneTurnCount = 0;
                        timeState.sceneStartTurn = state.lincoln.turn;
                        
                        return 0; // Anchor sets time, doesn't add
                    } else if (anchor.action === 'nextDay') {
                        timeState.day++;
                        timeState.hour = anchor.hour;
                        timeState.minute = anchor.minute;
                        this.updateTimeString();
                        
                        timeState.sceneMinutes = 0;
                        timeState.sceneTurnCount = 0;
                        timeState.sceneStartTurn = state.lincoln.turn;
                        
                        return 0;
                    } else if (anchor.action === 'addHours') {
                        var hours = anchor.hours;
                        if (anchor.captureGroup && match[anchor.captureGroup]) {
                            hours = this._parseRussianNumeral(match[anchor.captureGroup]);
                        }
                        return hours * 60;
                    } else if (anchor.action === 'addMinutes') {
                        var minutes = 0;
                        if (anchor.captureGroup && match[anchor.captureGroup]) {
                            minutes = this._parseRussianNumeral(match[anchor.captureGroup]);
                        }
                        return minutes;
                    }
                    
                    return 0;
                } catch (e) {
                    console.log("TimeEngine._applyAnchor error:", e);
                    return 0;
                }
            },
            
            // Apply scene-based time progression
            _applySceneTime: function(sceneType) {
                try {
                    var timeState = state.lincoln.time;
                    var config = this._sceneConfig[sceneType];
                    
                    // Check if scene changed
                    if (timeState.currentScene !== sceneType) {
                        timeState.currentScene = sceneType;
                        timeState.sceneStartTurn = state.lincoln.turn;
                        timeState.sceneTurnCount = 0;
                        timeState.sceneMinutes = 0;
                    }
                    
                    // Increment scene turn count
                    timeState.sceneTurnCount++;
                    
                    // Base rate
                    var rate = config.rate;
                    
                    // Apply scene drift (slowdown over time)
                    if (timeState.sceneTurnCount >= 20) {
                        rate = Math.floor(rate * 0.5);
                    } else if (timeState.sceneTurnCount >= 10) {
                        rate = Math.floor(rate * 0.7);
                    }
                    
                    // Check max duration cap
                    if (config.maxDuration !== null) {
                        var potentialMinutes = timeState.sceneMinutes + rate;
                        if (potentialMinutes > config.maxDuration) {
                            // Near max duration: reduce rate by 70%
                            rate = Math.floor(rate * 0.3);
                            
                            // Hard cap: don't exceed max duration
                            if (timeState.sceneMinutes >= config.maxDuration) {
                                rate = 0;
                            }
                        }
                    }
                    
                    // Update scene minutes
                    timeState.sceneMinutes += rate;
                    
                    return rate;
                } catch (e) {
                    console.log("TimeEngine._applySceneTime error:", e);
                    return 10;
                }
            },
            
            // Add minutes to current time
            addMinutes: function(minutes) {
                try {
                    var timeState = state.lincoln.time;
                    
                    timeState.minute += minutes;
                    timeState.totalMinutesPassed += minutes;
                    
                    // Handle minute overflow
                    while (timeState.minute >= 60) {
                        timeState.minute -= 60;
                        timeState.hour++;
                    }
                    
                    // Handle hour overflow
                    while (timeState.hour >= 24) {
                        timeState.hour -= 24;
                        timeState.day++;
                    }
                    
                    this.updateTimeString();
                    state.lincoln.stateVersion++;
                } catch (e) {
                    console.log("TimeEngine.addMinutes error:", e);
                }
            },
            
            // Update time string and time of day
            updateTimeString: function() {
                try {
                    var timeState = state.lincoln.time;
                    var hour = timeState.hour;
                    var minute = timeState.minute;
                    
                    // Determine time of day
                    var timeOfDay;
                    if (hour >= 5 && hour < 12) {
                        timeOfDay = "Morning";
                    } else if (hour >= 12 && hour < 17) {
                        timeOfDay = "Afternoon";
                    } else if (hour >= 17 && hour < 21) {
                        timeOfDay = "Evening";
                    } else {
                        timeOfDay = "Night";
                    }
                    
                    // Format time (12-hour format)
                    var displayHour = hour % 12;
                    if (displayHour === 0) displayHour = 12;
                    var ampm = hour < 12 ? "AM" : "PM";
                    var minuteStr = minute < 10 ? "0" + minute : String(minute);
                    
                    timeState.timeOfDay = timeOfDay;
                    timeState.timeString = "Day " + timeState.day + ", " + timeOfDay + 
                                          " (" + displayHour + ":" + minuteStr + " " + ampm + ")";
                } catch (e) {
                    console.log("TimeEngine.updateTimeString error:", e);
                }
            },
            
            // Set absolute time
            setTime: function(day, hour, minute) {
                try {
                    var timeState = state.lincoln.time;
                    timeState.day = LC.Utils.toNum(day, 1);
                    timeState.hour = LC.Utils.clamp(LC.Utils.toNum(hour, 0), 0, 23);
                    timeState.minute = LC.Utils.clamp(LC.Utils.toNum(minute, 0), 0, 59);
                    
                    this.updateTimeString();
                    state.lincoln.stateVersion++;
                } catch (e) {
                    console.log("TimeEngine.setTime error:", e);
                }
            },
            
            // Get current time info
            getTimeInfo: function() {
                try {
                    var timeState = state.lincoln.time;
                    return "=== Current Time ===\n" +
                           timeState.timeString + "\n" +
                           "Scene: " + timeState.currentScene + " (" + timeState.sceneTurnCount + " turns)\n" +
                           "Mode: " + timeState.mode + "\n" +
                           "Total time passed: " + Math.floor(timeState.totalMinutesPassed / 60) + "h " + 
                           (timeState.totalMinutesPassed % 60) + "m";
                } catch (e) {
                    console.log("TimeEngine.getTimeInfo error:", e);
                    return "Time info unavailable";
                }
            },
            
            // Get detailed stats
            getStats: function() {
                try {
                    var timeState = state.lincoln.time;
                    var config = this._sceneConfig[timeState.currentScene];
                    
                    return "=== Time Statistics ===\n" +
                           "Current: " + timeState.timeString + "\n" +
                           "Day: " + timeState.day + " | Hour: " + timeState.hour + " | Minute: " + timeState.minute + "\n" +
                           "Time of Day: " + timeState.timeOfDay + "\n" +
                           "Scene: " + timeState.currentScene + "\n" +
                           "Scene turns: " + timeState.sceneTurnCount + "\n" +
                           "Scene minutes: " + timeState.sceneMinutes + "/" + (config.maxDuration || "unlimited") + "\n" +
                           "Mode: " + timeState.mode + "\n" +
                           "Total elapsed: " + Math.floor(timeState.totalMinutesPassed / 60) + "h " + 
                           (timeState.totalMinutesPassed % 60) + "m";
                } catch (e) {
                    console.log("TimeEngine.getStats error:", e);
                    return "Stats unavailable";
                }
            }
        }
    };
})();

// Register built-in commands
LC.CommandsRegistry.register('ping', function(args) {
    return "pong";
});

LC.CommandsRegistry.register('debug', function(args) {
    try {
        var L = state.lincoln;
        return "=== Lincoln v17 Debug ===\n" +
               "Version: " + L.version + "\n" +
               "Turn: " + L.turn + "\n" +
               "State Version: " + L.stateVersion + "\n" +
               "Action Count: " + (L.actionCount || 0) + "\n" +
               "Characters: " + Object.keys(L.characters).length;
    } catch (e) {
        console.log("Debug command error:", e);
        return "\u27E6SYS\u27E7 Debug error: " + e.message;
    }
});

LC.CommandsRegistry.register('turn', function(args) {
    return "Current turn: " + state.lincoln.turn;
});

LC.CommandsRegistry.register('characters', function(args) {
    try {
        var chars = Object.keys(state.lincoln.characters);
        if (chars.length === 0) {
            return "No characters tracked yet.";
        }
        var output = "Tracked characters (" + chars.length + "):\n";
        for (var i = 0; i < chars.length; i++) {
            output += "- " + chars[i] + "\n";
        }
        return output;
    } catch (e) {
        console.log("Characters command error:", e);
        return "\u27E6SYS\u27E7 Characters error: " + e.message;
    }
});

LC.CommandsRegistry.register('help', function(args) {
    try {
        var cmds = Object.keys(LC.CommandsRegistry.commands);
        var output = "=== Lincoln v17 Commands ===\nAvailable commands:\n";
        for (var i = 0; i < cmds.length; i++) {
            output += "- /" + cmds[i] + "\n";
        }
        return output;
    } catch (e) {
        console.log("Help command error:", e);
        return "\u27E6SYS\u27E7 Help error: " + e.message;
    }
});

// Time commands
LC.CommandsRegistry.register('time', function(args) {
    try {
        if (!args || args.length === 0) {
            // Display current time
            return LC.TimeEngine.getTimeInfo();
        }
        
        var subcommand = args[0].toLowerCase();
        
        if (subcommand === 'skip') {
            // /time skip <number> <unit>
            if (args.length < 3) {
                return "Usage: /time skip <number> <hours|minutes>";
            }
            var amount = parseInt(args[1], 10);
            var unit = args[2].toLowerCase();
            
            if (isNaN(amount) || amount < 0) {
                return "Invalid amount: " + args[1];
            }
            
            if (unit === 'hours' || unit === 'hour' || unit === 'h') {
                LC.TimeEngine.addMinutes(amount * 60);
                return "Skipped " + amount + " hour(s) forward.\n" + LC.TimeEngine.getTimeInfo();
            } else if (unit === 'minutes' || unit === 'minute' || unit === 'min' || unit === 'm') {
                LC.TimeEngine.addMinutes(amount);
                return "Skipped " + amount + " minute(s) forward.\n" + LC.TimeEngine.getTimeInfo();
            } else {
                return "Invalid unit. Use 'hours' or 'minutes'.";
            }
        } else if (subcommand === 'set') {
            // /time set <day> <hour> <minute>
            if (args.length < 4) {
                return "Usage: /time set <day> <hour> <minute>";
            }
            var day = parseInt(args[1], 10);
            var hour = parseInt(args[2], 10);
            var minute = parseInt(args[3], 10);
            
            if (isNaN(day) || day < 1) {
                return "Invalid day: " + args[1];
            }
            if (isNaN(hour) || hour < 0 || hour > 23) {
                return "Invalid hour (0-23): " + args[2];
            }
            if (isNaN(minute) || minute < 0 || minute > 59) {
                return "Invalid minute (0-59): " + args[3];
            }
            
            LC.TimeEngine.setTime(day, hour, minute);
            return "Time set to Day " + day + ", " + hour + ":" + (minute < 10 ? "0" : "") + minute + ".\n" + 
                   LC.TimeEngine.getTimeInfo();
        } else if (subcommand === 'mode') {
            // /time mode <hybrid|manual|auto>
            if (args.length < 2) {
                return "Usage: /time mode <hybrid|manual|auto>\nCurrent mode: " + state.lincoln.time.mode;
            }
            var newMode = args[1].toLowerCase();
            
            if (newMode !== 'hybrid' && newMode !== 'manual' && newMode !== 'auto') {
                return "Invalid mode. Use 'hybrid', 'manual', or 'auto'.";
            }
            
            state.lincoln.time.mode = newMode;
            state.lincoln.stateVersion++;
            return "Time mode set to: " + newMode;
        } else if (subcommand === 'stats') {
            // /time stats
            return LC.TimeEngine.getStats();
        } else {
            return "Unknown subcommand. Try: /time, /time skip, /time set, /time mode, /time stats";
        }
    } catch (e) {
        console.log("Time command error:", e);
        return "\u27E6SYS\u27E7 Time command error: " + e.message;
    }
});

// LC is now available in this scope for Input/Context/Output scripts
