// Lincoln v17 - Library Script (Phase 1: Infrastructure)
// This script executes BEFORE each hook (Input/Context/Output) - 3x per turn
// Version: 17.0.0-phase1

// Initialize state.lincoln if not exists or version mismatch
if (!state.lincoln || state.lincoln.version !== "17.0.0") {
    state.lincoln = {
        version: "17.0.0",
        stateVersion: 0,
        initialized: true,
        turn: 0,
        currentAction: "",
        drafts: [],
        characters: {},
        relations: {},
        hierarchy: {},
        rumors: [],
        lore: [],
        myths: [],
        time: {},
        environment: {},
        evergreen: [],
        secrets: []
    };
}

// Lincoln Core (LC) - recreated on each Library execution
const LC = (function() {
    // Constants
    var COMMAND_PREFIX = '/';
    var ACTION_TYPES = {
        COMMAND: 'command',
        ACTION: 'action',
        EMPTY: 'empty'
    };
    
    return {
        // Constants exposed
        Constants: {
            COMMAND_PREFIX: COMMAND_PREFIX,
            ACTION_TYPES: ACTION_TYPES
        },
        
        // Tools - Safety utilities (#19)
        Tools: {
            safeRegexMatch: function(text, pattern) {
                try {
                    return text.match(pattern) || [];
                } catch (e) {
                    console.log("Regex error:", e);
                    return [];
                }
            },
            
            escapeRegex: function(str) {
                try {
                    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                } catch (e) {
                    console.log("Escape regex error:", e);
                    return str;
                }
            }
        },
        
        // Utils - Type conversion and helper methods (#20)
        Utils: {
            toNum: function(value, defaultVal) {
                try {
                    var num = parseFloat(value);
                    return isNaN(num) ? (defaultVal !== undefined ? defaultVal : 0) : num;
                } catch (e) {
                    return defaultVal !== undefined ? defaultVal : 0;
                }
            },
            
            toStr: function(value, defaultVal) {
                try {
                    if (value === null || value === undefined) {
                        return defaultVal !== undefined ? defaultVal : "";
                    }
                    return String(value);
                } catch (e) {
                    return defaultVal !== undefined ? defaultVal : "";
                }
            },
            
            toBool: function(value, defaultVal) {
                try {
                    if (value === null || value === undefined) {
                        return defaultVal !== undefined ? defaultVal : false;
                    }
                    return Boolean(value);
                } catch (e) {
                    return defaultVal !== undefined ? defaultVal : false;
                }
            },
            
            clamp: function(value, min, max) {
                return Math.max(min, Math.min(max, value));
            }
        },
        
        // Flags - Debugging flags and currentAction facade (#21)
        Flags: {
            setCurrentAction: function(actionType) {
                try {
                    state.lincoln.currentAction = actionType;
                    state.lincoln.stateVersion++;
                } catch (e) {
                    console.log("Flags.setCurrentAction error:", e);
                }
            },
            
            getCurrentAction: function() {
                try {
                    return state.lincoln.currentAction || "";
                } catch (e) {
                    console.log("Flags.getCurrentAction error:", e);
                    return "";
                }
            }
        },
        
        // Drafts - Message queue for output hooks (#22)
        Drafts: {
            add: function(message) {
                try {
                    if (!state.lincoln.drafts) {
                        state.lincoln.drafts = [];
                    }
                    state.lincoln.drafts.push(message);
                    state.lincoln.stateVersion++;
                } catch (e) {
                    console.log("Drafts.add error:", e);
                }
            },
            
            get: function() {
                try {
                    return state.lincoln.drafts || [];
                } catch (e) {
                    console.log("Drafts.get error:", e);
                    return [];
                }
            },
            
            clear: function() {
                try {
                    state.lincoln.drafts = [];
                    state.lincoln.stateVersion++;
                } catch (e) {
                    console.log("Drafts.clear error:", e);
                }
            }
        },
        
        // Turns - Turn counter management (#23)
        Turns: {
            increment: function() {
                try {
                    state.lincoln.turn++;
                    state.lincoln.stateVersion++;
                } catch (e) {
                    console.log("Turns.increment error:", e);
                }
            },
            
            get: function() {
                try {
                    return state.lincoln.turn || 0;
                } catch (e) {
                    console.log("Turns.get error:", e);
                    return 0;
                }
            },
            
            set: function(value) {
                try {
                    state.lincoln.turn = LC.Utils.toNum(value, 0);
                    state.lincoln.stateVersion++;
                } catch (e) {
                    console.log("Turns.set error:", e);
                }
            }
        },
        
        // CommandsRegistry - Command processing system (#24)
        CommandsRegistry: {
            commands: {}, // Plain ES5 object, NOT Map
            prefix: '/',
            
            register: function(name, handler) {
                try {
                    this.commands[name] = handler;
                } catch (e) {
                    console.log("CommandsRegistry.register error:", e);
                }
            },
            
            detect: function(text) {
                if (!text || typeof text !== 'string') return null;
                for (var cmd in this.commands) {
                    var pattern = this.prefix + cmd;
                    if (text.indexOf(pattern) !== -1) {
                        return cmd;
                    }
                }
                return null;
            },
            
            parse: function(text, command) {
                var pattern = this.prefix + command;
                var index = text.indexOf(pattern);
                if (index === -1) return [];
                var afterCommand = text.substring(index + pattern.length);
                var argsMatch = afterCommand.match(/^[ \t]+([\w\s]+?)(?:[".\n]|$)/);
                if (argsMatch && argsMatch[1]) {
                    return argsMatch[1].replace(/^\s+|\s+$/g, '').split(/\s+/);
                }
                return [];
            },
            
            execute: function(command, args) {
                try {
                    if (this.commands[command]) {
                        return this.commands[command](args);
                    }
                    return null;
                } catch (e) {
                    console.log("CommandsRegistry.execute error:", e);
                    return "\u27E6SYS\u27E7 \u26A0\uFE0F Command error: " + e.message;
                }
            }
        },
        
        // CharacterTracker - Extract and track character states (#33)
        CharacterTracker: {
            // Common words to exclude from character extraction
            _commonWords: [
                'The', 'You', 'Your', 'They', 'Their', 'This', 'That', 'These', 'Those',
                'What', 'When', 'Where', 'Which', 'Who', 'Why', 'How',
                'But', 'And', 'Or', 'Not', 'So', 'As', 'At', 'By', 'For', 'From',
                'In', 'Of', 'On', 'To', 'Up', 'With', 'After', 'Before', 'During',
                'Since', 'Until', 'While', 'About', 'Against', 'Between', 'Into',
                'Through', 'Under', 'Over', 'Above', 'Below', 'Can', 'Could',
                'May', 'Might', 'Must', 'Should', 'Would', 'Will', 'Shall'
            ],
            
            extract: function(text) {
                try {
                    // Simple character extraction - looks for capitalized names
                    var matches = LC.Tools.safeRegexMatch(text, /\b[A-Z][a-z]+\b/g);
                    var characters = [];
                    
                    for (var i = 0; i < matches.length; i++) {
                        var name = matches[i];
                        // ES5: Use indexOf instead of includes
                        // Filter out common words
                        if (this._commonWords.indexOf(name) === -1 && 
                            characters.indexOf(name) === -1) {
                            characters.push(name);
                        }
                    }
                    
                    return characters;
                } catch (e) {
                    console.log("CharacterTracker.extract error:", e);
                    return [];
                }
            },
            
            ensure: function(name) {
                try {
                    if (!state.lincoln.characters[name]) {
                        state.lincoln.characters[name] = {
                            name: name,
                            created: state.lincoln.turn
                        };
                        state.lincoln.stateVersion++;
                    }
                } catch (e) {
                    console.log("CharacterTracker.ensure error:", e);
                }
            },
            
            exists: function(name) {
                try {
                    return state.lincoln.characters[name] !== undefined;
                } catch (e) {
                    console.log("CharacterTracker.exists error:", e);
                    return false;
                }
            }
        },
        
        // InputProcessor - Normalize and analyze player input (#34)
        InputProcessor: {
            normalize: function(text) {
                try {
                    if (!text || typeof text !== 'string') {
                        return "";
                    }
                    
                    // Trim whitespace
                    var normalized = text.replace(/^\s+|\s+$/g, '');
                    
                    // Collapse multiple spaces
                    normalized = normalized.replace(/\s+/g, ' ');
                    
                    return normalized;
                } catch (e) {
                    console.log("InputProcessor.normalize error:", e);
                    return text;
                }
            },
            
            isCommand: function(text) {
                try {
                    return text && typeof text === 'string' && text.charAt(0) === COMMAND_PREFIX;
                } catch (e) {
                    console.log("InputProcessor.isCommand error:", e);
                    return false;
                }
            },
            
            analyze: function(text) {
                try {
                    var normalized = this.normalize(text);
                    var isCommand = this.isCommand(normalized);
                    
                    return {
                        original: text,
                        normalized: normalized,
                        isCommand: isCommand,
                        isEmpty: normalized.length === 0
                    };
                } catch (e) {
                    console.log("InputProcessor.analyze error:", e);
                    return {
                        original: text,
                        normalized: text,
                        isCommand: false,
                        isEmpty: true
                    };
                }
            }
        },
        
        // SysOutput - Format system messages for AI Dungeon visibility (#35)
        SysOutput: {
            formatLine: function(msg) {
                try {
                    var s = LC.Utils.toStr(msg, "").replace(/^\s+|\s+$/g, '');
                    return s ? "\u27E6SYS\u27E7 " + s : "";
                } catch (e) {
                    console.log("SysOutput.formatLine error:", e);
                    return "";
                }
            }
        }
    };
})();

// Register built-in commands
LC.CommandsRegistry.register('ping', function(args) {
    return "pong";
});

LC.CommandsRegistry.register('debug', function(args) {
    try {
        var L = state.lincoln;
        return "=== Lincoln v17 Debug ===\n" +
               "Version: " + L.version + "\n" +
               "Turn: " + L.turn + "\n" +
               "State Version: " + L.stateVersion + "\n" +
               "Action Count: " + (L.actionCount || 0) + "\n" +
               "Characters: " + Object.keys(L.characters).length;
    } catch (e) {
        console.log("Debug command error:", e);
        return "\u27E6SYS\u27E7 Debug error: " + e.message;
    }
});

LC.CommandsRegistry.register('turn', function(args) {
    return "Current turn: " + state.lincoln.turn;
});

LC.CommandsRegistry.register('characters', function(args) {
    try {
        var chars = Object.keys(state.lincoln.characters);
        if (chars.length === 0) {
            return "No characters tracked yet.";
        }
        var output = "Tracked characters (" + chars.length + "):\n";
        for (var i = 0; i < chars.length; i++) {
            output += "- " + chars[i] + "\n";
        }
        return output;
    } catch (e) {
        console.log("Characters command error:", e);
        return "\u27E6SYS\u27E7 Characters error: " + e.message;
    }
});

LC.CommandsRegistry.register('help', function(args) {
    try {
        var cmds = Object.keys(LC.CommandsRegistry.commands);
        var output = "=== Lincoln v17 Commands ===\nAvailable commands:\n";
        for (var i = 0; i < cmds.length; i++) {
            output += "- /" + cmds[i] + "\n";
        }
        return output;
    } catch (e) {
        console.log("Help command error:", e);
        return "\u27E6SYS\u27E7 Help error: " + e.message;
    }
});

// LC is now available in this scope for Input/Context/Output scripts
