/*
Module: Library ‚Äî Lincoln v16.0.8-compat6d
Contract:
- Reads flags: ...
- Writes flags: ...
- Entry points: ...
- Invariants:
  - Turn +1 on story input and the UI Continue button.
  - Turn +0 on slash commands (including `/continue`) and retries.
  - `/continue` slash command accepts recap/epoch drafts (not the UI button).
  - Context overlay falls back to upstream text when empty or on error.
- Config: LIMITS.*, CHAR_WINDOW_*, FEATURES.*, OUTPUT_BUDGET_MS (optional)
*/
// === LIBRARY ‚Äî Lincoln Heights Core v16.0.8-compat6d ===

(function () {
  const __SCRIPT_SLOT__ = "Library";

  // ---------- Utils ----------
  const getState = () => (typeof state !== "undefined" ? state : {});
  const toNum  = (x, d=0)    => (typeof x === "number" && !isNaN(x)) ? x : (Number(x) || d);
  const toStr  = (x)         => String(x == null ? "" : x);
  const toBool = (x, d=false)=> (x == null ? d : !!x);

  const _globalScope =
    (typeof globalThis !== "undefined" && globalThis) ||
    (typeof self !== "undefined" && self) ||
    (typeof window !== "undefined" && window) ||
    (typeof global !== "undefined" && global) ||
    {};

  const _existingLC = _globalScope?.LC;
  const _preparedConfig = _existingLC?.CONFIG ?? {};
  if (_existingLC && !_existingLC.CONFIG) {
    _existingLC.CONFIG = _preparedConfig;
  }

  const _preparedLimits = (_preparedConfig.LIMITS ??= {});
  _preparedLimits.CONTEXT_LENGTH ??= 800;
  _preparedLimits.ANTI_ECHO ??= { CACHE_MAX: 256, MIN_LENGTH: 200, SOFT_PRUNE_80: true };
  _preparedConfig.CHAR_WINDOW_HOT ??= 3;
  _preparedConfig.CHAR_WINDOW_ACTIVE ??= 10;
  _preparedLimits.EVERGREEN_HISTORY_CAP ??= 400;
  _preparedConfig.FEATURES ??= { USE_NORM_CACHE: false, ANALYZE_RELATIONS: true };

  const LC = (typeof globalThis !== "undefined" ? (globalThis.LC ||= {}) : (_globalScope.LC ||= {}));

  // RF-T1: CONFIG sweep + unified utils (idempotent guards)
  LC.CONFIG ??= {};
  LC.CONFIG.LIMITS ??= {};
  LC.CONFIG.LIMITS.CONTEXT_LENGTH ??= 800;
  LC.CONFIG.LIMITS.ANTI_ECHO ??= { CACHE_MAX: 256, MIN_LENGTH: 200, SOFT_PRUNE_80: true };
  LC.CONFIG.LIMITS.EVERGREEN_HISTORY_CAP ??= 400;
  LC.CONFIG.CHAR_WINDOW_HOT ??= 3;
  LC.CONFIG.CHAR_WINDOW_ACTIVE ??= 10;
  LC.CONFIG.FEATURES ??= {
    USE_NORM_CACHE: false,
    ANALYZE_RELATIONS: true,
    STRICT_CMD_BYPASS: true
  };

  /**
   * Sanitizes and deduplicates character aliases.
   * Handles both array and object formats for aliases.
   * @param {object} L - The Lincoln state object
   */
  LC.sanitizeAliases = function (L){
    try{
      if (!L) return;
      const aliases = L.aliases;
      if (Array.isArray(aliases)){
        const seen = new Set(); const clean = [];
        for (let i=0;i<aliases.length;i++){
          const v = String(aliases[i] ?? "").trim().toLowerCase();
          if (!v || seen.has(v)) continue;
          seen.add(v); clean.push(v);
        }
        L.aliases = clean;
        return;
      }
      if (aliases && typeof aliases === "object"){
        const cleanMap = {};
        for (const key of Object.keys(aliases)){
          const safeKey = String(key ?? "").trim();
          if (!safeKey) continue;
          const arr = Array.isArray(aliases[key]) ? aliases[key] : [];
          const seen = new Set(); const clean = [];
          for (let i=0;i<arr.length;i++){
            const v = String(arr[i] ?? "").trim().toLowerCase();
            if (!v || seen.has(v)) continue;
            seen.add(v); clean.push(v);
          }
          if (clean.length) cleanMap[safeKey] = clean;
        }
        L.aliases = cleanMap;
        return;
      }
      L.aliases = {};
    }catch(_){}
  };

  // Notices (centralized)
  LC.pushNotice ??= (msg) => {
    if (!msg) return;
    const L = LC.lcInit ? LC.lcInit() : (globalThis.state?.shared || {});
    L.visibleNotice = [L.visibleNotice, String(msg)].filter(Boolean).join("\n");
  };
  LC.consumeNotices ??= () => {
    const L = LC.lcInit ? LC.lcInit() : (globalThis.state?.shared || {});
    const out = L.visibleNotice || "";
    L.visibleNotice = "";
    return out;
  };

  // Flags facade
  LC.Flags ||= {};
  LC.Flags.clearCmd ||= function clearCmd(preserveCycle){
    try {
      const L = LC.lcInit ? LC.lcInit() : {};
      if (!preserveCycle && L.currentAction) delete L.currentAction.__cmdCyclePending;
      if (L.currentAction) {
        if (L.currentAction.type === 'command') delete L.currentAction.type;
        if (L.currentAction.type === 'retry') delete L.currentAction.type;
        if (L.currentAction.type === 'continue') delete L.currentAction.type;
      }
    } catch(_) {}
  };
  LC.Flags.setCmd ||= function setCmd(){
    try {
      const L = LC.lcInit ? LC.lcInit() : {};
      if (L.currentAction) {
        L.currentAction.type = 'command';
      }
    } catch(_) {}
  };
  LC.Flags.queueRecap ||= function queueRecap(){
    try {
      const L = LC.lcInit ? LC.lcInit() : {};
      if (L.currentAction) {
        L.currentAction.task = 'recap';
      }
    } catch(_) {}
  };
  LC.Flags.queueEpoch ||= function queueEpoch(){
    try {
      const L = LC.lcInit ? LC.lcInit() : {};
      if (L.currentAction) {
        L.currentAction.task = 'epoch';
      }
    } catch(_) {}
  };

  // --- SYS formatting helpers (shared by Input/Output) ---
  /**
   * Formats a message as a single-line system message.
   * @param {string} msg - The message to format
   * @returns {string} Formatted system message or empty string
   */
  LC.sysLine = function sysLine(msg){
    const s = String(msg ?? "").trim();
    return s ? `‚ü¶SYS‚üß ${s}` : "";
  };

  /**
   * Formats multiple lines as a system message block.
   * @param {string[]|string} lines - Array of lines or single line
   * @returns {string} Formatted system block with separator
   */
  LC.sysBlock = function sysBlock(lines){
    const arr = Array.isArray(lines) ? lines : [String(lines ?? "")];
    const body = arr.map(v => {
      // Handle both string and object format
      const text = (v && typeof v === 'object') ? (v.text || '') : String(v ?? "");
      return text.trim();
    }).filter(Boolean).join("\n");
    if (!body) return "";
    return body + "\n" + "=".repeat(40) + "\n";
  };

  /**
   * Tools namespace for utility functions.
   */
  LC.Tools = LC.Tools || {};
  
  /**
   * Executes regex match with timeout protection to prevent catastrophic backtracking.
   * @param {string} text - The text to match against
   * @param {RegExp} regex - The regular expression to test
   * @param {number} [timeout=100] - Maximum execution time in milliseconds
   * @returns {Array|null} Match result or null if timeout/error occurs
   */
  LC.Tools.safeRegexMatch = function safeRegexMatch(text, regex, timeout = 100) {
    let timeoutId;
    let timedOut = false;
    
    try {
      // Create a timeout handler
      timeoutId = setTimeout(() => {
        timedOut = true;
      }, timeout);
      
      // Attempt the match
      const result = text.match(regex);
      
      // Clear timeout
      clearTimeout(timeoutId);
      
      // Check if we timed out (simple heuristic, not perfect but helps)
      if (timedOut) {
        LC.lcWarn?.(`Regex match timed out after ${timeout}ms`);
        return null;
      }
      
      return result;
    } catch (err) {
      if (timeoutId) clearTimeout(timeoutId);
      LC.lcWarn?.(`Regex execution error: ${err && err.message ? err.message : err}`);
      return null;
    }
  };

  /**
   * Applies a recap draft by saving it and clearing the draft state.
   * @param {object} L - The Lincoln state object
   * @returns {object|boolean} Object with savedCount or false if no draft
   */
  LC.applyRecapDraft ??= function applyRecapDraft(L) {
    if (!L || !L.recapDraft || !L.recapDraft.text) return false;
    let savedCount = 0;
    if (typeof LC.syncRecapToStoryCards === "function") {
      try {
        savedCount = LC.syncRecapToStoryCards(L.recapDraft.text, L.recapDraft.window) | 0;
      } catch (e) {
        LC.lcWarn?.("syncRecapToStoryCards failed: " + (e && e.message));
      }
    }
    L.lastRecapTurn = L.recapDraft.turn || L.turn;
    L.recapDraft = null;
    LC.lcSys?.(`‚úÖ Recap saved${savedCount ? ` (${savedCount} card${savedCount === 1 ? "" : "s"})` : ""}.`);
    return { savedCount };
  };

  /**
   * Applies an epoch draft by saving it and clearing the draft state.
   * @param {object} L - The Lincoln state object
   * @returns {boolean} True if epoch was applied, false otherwise
   */
  LC.applyEpochDraft ??= function applyEpochDraft(L) {
    if (!L || !L.epochDraft || !L.epochDraft.text) return false;
    L.lastEpochTurn = L.epochDraft.turn || L.turn;
    L.epochDraft = null;
    LC.lcSys?.("‚úÖ Epoch accepted.");
    return true;
  };

  LC.Drafts = LC.Drafts || {};
  LC.Drafts.applyPending = function applyPending(L, source){
    try{
      if (!L) return { applied:false };
      if (L.__draftAppliedStamp === L.turn) return { applied:false, reason:"already-applied" };
      let did=false, notes=[];
      if (L.recapDraft) { LC.applyRecapDraft?.(L); did=true; notes.push("recap"); }
      if (L.epochDraft) { LC.applyEpochDraft?.(L); did=true; notes.push("epoch"); }
      if (did){
        L.__draftAppliedStamp = L.turn;
        LC.lcSys?.("‚úÖ Draft saved ("+notes.join("+")+")");
        return { applied:true, notes };
      }
      return { applied:false, reason:"no-draft" };
    }catch(e){ LC.lcWarn?.("Drafts.applyPending failed: "+(e && e.message)); return { applied:false, reason:"error" }; }
  };

  // Turns facade (—Ç–æ–Ω–∫–∞—è –æ–±—ë—Ä—Ç–∫–∞)
  LC.Turns ??= {
    incIfNeeded(){ 
      const L=LC.lcInit(); 
      if (L.currentAction?.type !== 'command' && L.currentAction?.type !== 'retry') { 
        L.turn=(L.turn|0)+1; 
      } 
    },
    set(n){ LC.turnSet?.(n); },
    undo(n){ LC.turnUndo?.(n); },
  };

  // Unified context preview
  LC.buildCtxPreview ??= function(stateOrOpts, opts = {}) {
    const limitDefault = LC.CONFIG?.LIMITS?.CONTEXT_LENGTH ?? 800;
    const options = {};
    if (stateOrOpts && typeof stateOrOpts === "object" && !Array.isArray(stateOrOpts)) {
      const maybeState = stateOrOpts;
      const hasOverlayKeys = ["limit", "allowPartial", "preview", "text", "parts", "max"].some((k) => k in maybeState);
      if (hasOverlayKeys) {
        Object.assign(options, maybeState);
      } else {
        options.state = maybeState;
      }
    }
    if (opts && typeof opts === "object") {
      Object.assign(options, opts);
    }
    if (!("limit" in options)) options.limit = limitDefault;
    try {
      const result = LC.composeContextOverlay?.(options);
      if (result && typeof result === "object") {
        return {
          overlay: typeof result.text === "string" ? result.text : String(result.text || ""),
          parts: result.parts || {},
          max: result.max,
          error: result.error
        };
      }
      const limit = Number.isFinite(Number(options.limit)) ? Number(options.limit) : 0;
      return {
        overlay: typeof result === "string" ? result : "",
        parts: {},
        max: limit,
        error: result && typeof result !== "string" ? "Unexpected preview result" : undefined
      };
    } catch (e) {
      const message = e && e.message ? e.message : String(e);
      LC.lcWarn?.(`buildCtxPreview failed: ${message}`);
      const limit = Number.isFinite(Number(options.limit)) ? Number(options.limit) : 0;
      return { overlay: "", parts: {}, max: limit, error: message };
    }
  };

  // Norm cache (opt-in)
  const __NU_CACHE = (globalThis.__NU_CACHE ||= new Map());
  LC._normUCached ??= function(s){
    if (!s) return s;
    const normFn = typeof LC._normU === "function" ? LC._normU.bind(LC) : (typeof _normU === "function" ? _normU : (x) => x);
    if (!LC.CONFIG?.FEATURES?.USE_NORM_CACHE) return normFn(s);
    if (__NU_CACHE.has(s)) { const v=__NU_CACHE.get(s); __NU_CACHE.delete(s); __NU_CACHE.set(s,v); return v; }
    const v = normFn(s);
    __NU_CACHE.set(s, v);
    if (__NU_CACHE.size > 64) __NU_CACHE.delete(__NU_CACHE.keys().next().value);
    return v;
  };

  // RF-T5: Commands registry (minimal start, safe replies)
  LC.Commands ??= new Map();
  LC.CommandsRegistry = new Map();

  // Populate CommandsRegistry with all commands
  // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∑–∞–º—ã–∫–∞–Ω–∏–µ –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º helper-—Ñ—É–Ω–∫—Ü–∏—è–º
  (function() {
    const reg = LC.CommandsRegistry;

    // /ui
    reg.set("/ui", {
      description: "/ui on|off ‚Äî toggle UI messages",
      handler(args, text) {
        const L = LC.lcInit();
        const cmdRaw = text || "";
        if (typeof LC.replyStop !== "function") return { text: "‚ü¶SYS‚üß UI command", stop: true };
        if (/\/ui\s+on/i.test(cmdRaw)) {
          L.sysShow = true;
          return LC.replyStop("‚úÖ UI enabled.");
        }
        if (/\/ui\s+off/i.test(cmdRaw)) {
          L.sysShow = false;
          return LC.replyStop("‚ö´ UI disabled.");
        }
        return LC.replyStop(`UI is ${L.sysShow ? "on" : "off"}.`);
      }
    });

    // /debug
    reg.set("/debug", {
      description: "/debug on|off ‚Äî toggle debug mode",
      handler(args, text) {
        const L = LC.lcInit();
        const cmdRaw = text || "";
        if (typeof LC.replyStop !== "function") return { text: "‚ü¶SYS‚üß Debug command", stop: true };
        if (/\/debug\s+on/i.test(cmdRaw)) {
          L.debugMode = true;
          return LC.replyStop("üîç Debug ON.");
        }
        if (/\/debug\s+off/i.test(cmdRaw)) {
          L.debugMode = false;
          return LC.replyStop("üîç Debug OFF.");
        }
        return LC.replyStop(`Debug is ${L.debugMode ? "on" : "off"}.`);
      }
    });

    // /mode
    reg.set("/mode", {
      description: "/mode director|character ‚Äî switch information access level",
      handler(args, text) {
        const L = LC.lcInit();
        const cmdRaw = text || "";
        if (typeof LC.replyStop !== "function") return { text: "‚ü¶SYS‚üß Mode command", stop: true };
        if (/\/mode\s+director/i.test(cmdRaw)) {
          L.playerInfoLevel = 'director';
          return LC.replyStop("üé¨ Director mode enabled. All system messages visible.");
        }
        if (/\/mode\s+character/i.test(cmdRaw)) {
          L.playerInfoLevel = 'character';
          return LC.replyStop("üé≠ Character mode enabled. Director-level messages hidden for immersion.");
        }
        return LC.replyStop(`Current mode: ${L.playerInfoLevel === 'director' ? 'Director üé¨' : 'Character üé≠'}`);
      }
    });

    // /recap
    reg.set("/recap", {
      description: "/recap ‚Äî create recap draft next output",
      handler(args, text) {
        const L = LC.lcInit();
        if (typeof LC.replyStop !== "function") return { text: "‚ü¶SYS‚üß Recap command", stop: true };
        L.currentAction = { type: 'story', task: 'recap' };
        L.tm = L.tm || {};
        L.tm.wantRecapTurn = 0;
        LC.Flags?.clearCmd?.(true);
        return LC.replyStop("üìã Recap requested. Next output ‚Üí draft.");
      }
    });

    // /epoch
    reg.set("/epoch", {
      description: "/epoch ‚Äî create epoch draft",
      handler(args, text) {
        const L = LC.lcInit();
        if (typeof LC.replyStop !== "function") return { text: "‚ü¶SYS‚üß Epoch command", stop: true };
        L.currentAction = { type: 'story', task: 'epoch' };
        L.tm = L.tm || {};
        L.tm.wantRecapTurn = 0;
        LC.Flags?.clearCmd?.(true);
        return LC.replyStop("üóø Epoch requested. Next output ‚Üí draft.");
      }
    });

    // /continue
    reg.set("/continue", {
      description: "/continue ‚Äî accept and save draft",
      handler(args, text) {
        const L = LC.lcInit();
        if (typeof LC.replyStop !== "function") return { text: "‚ü¶SYS‚üß Continue command", stop: true };
        if (L.recapDraft || L.epochDraft) {
          L.currentAction = { type: 'command', name: '/continue' };
          LC.Drafts?.applyPending?.(L, "input");
          return { text: "", stop: true };
        }
        return LC.replyStop("‚ùå No draft to save.");
      }
    });

    // /evergreen
    reg.set("/evergreen", {
      description: "/evergreen on|off|clear|summary|set <cat>: <value>",
      handler(args, text) {
        const L = LC.lcInit();
        const cmdRaw = text || "";
        if (typeof LC.replyStop !== "function") return { text: "‚ü¶SYS‚üß Evergreen command", stop: true };
        if (/\/evergreen\s+clear/i.test(cmdRaw)) {
          LC.EvergreenEngine.clear();
          return LC.replyStop("üßπ Evergreen storage cleared.");
        }
        if (/\/evergreen\s+on/i.test(cmdRaw)) {
          LC.EvergreenEngine.toggle(true);
          return LC.replyStop("üåø Evergreen enabled.");
        }
        if (/\/evergreen\s+off/i.test(cmdRaw)) {
          LC.EvergreenEngine.toggle(false);
          return LC.replyStop("üåø Evergreen disabled.");
        }
        if (/\/evergreen\s+summary/i.test(cmdRaw)) { return LC.replyStop(LC.EvergreenEngine.getSummary()); }
        const m = cmdRaw.match(/\/evergreen\s+set\s+([\w-]+):\s*(.+)$/i);
        if (m) {
          const cat = m[1].toLowerCase();
          let val = m[2].trim().replace(/\s+/g, " ").slice(0, 240);
          const allowed = ["facts","status","relations","obligations"];
          const target = allowed.indexOf(cat) === -1 ? "facts" : cat;
          const key = `u_${Date.now().toString(36)}`;
          LC.evergreenManualSet(L, target, key, val);
          return LC.replyStop(`Evergreen[${target}] += ${val.slice(0,80)}`);
        }
        return LC.replyStop(LC.EvergreenEngine.getSummary());
      }
    });

    // /secret
    reg.set("/secret", {
      description: "/secret <text> known_by: <Name1>, <Name2>, ... ‚Äî add secret",
      handler(args, text) {
        const L = LC.lcInit();
        const cmdRaw = text || "";
        if (typeof LC.replyStop !== "function") return { text: "‚ü¶SYS‚üß Secret command", stop: true };
        
        // Parse: /secret <text> known_by: <names>
        const match = cmdRaw.match(/\/secret\s+(.+?)\s+known_by:\s*(.+)$/i);
        if (!match) {
          return LC.replyStop("‚ùå Usage: /secret <text> known_by: <Name1>, <Name2>, ...");
        }
        
        const secretText = match[1].trim();
        const knownByRaw = match[2].trim();
        
        if (!secretText || secretText.length < 5) {
          return LC.replyStop("‚ùå Secret text too short (min 5 chars).");
        }
        
        if (!knownByRaw) {
          return LC.replyStop("‚ùå Must specify at least one character in known_by.");
        }
        
        // Parse character names (comma-separated)
        const knownByList = knownByRaw.split(/,\s*/).map(n => n.trim()).filter(n => n.length > 0);
        
        if (knownByList.length === 0) {
          return LC.replyStop("‚ùå Must specify at least one character in known_by.");
        }
        
        // Create secret object
        const secretId = `secret_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
        const secret = {
          id: secretId,
          text: secretText,
          known_by: knownByList
        };
        
        // Add to secrets array
        if (!Array.isArray(L.secrets)) L.secrets = [];
        L.secrets.push(secret);
        
        const knownByStr = knownByList.join(", ");
        return LC.replyStop(`ü§´ Secret added (known by: ${knownByStr})`);
      }
    });

    // /time
    reg.set("/time", {
      description: "/time ‚Äî show current time | /time set day N [Name] ‚Äî set day | /time next ‚Äî advance time",
      /**
       * Handles time-related commands with defensive input validation.
       * @param {string[]} args - Command arguments
       * @param {string} text - Full command text
       * @returns {object} Command response
       */
      handler(args, text) {
        const L = LC.lcInit();
        const cmdRaw = text || "";
        if (typeof LC.replyStop !== "function") return { text: "‚ü¶SYS‚üß Time command", stop: true };
        
        // /time next ‚Äî advance to next time of day
        if (/\/time\s+next/i.test(cmdRaw)) {
          if (LC.TimeEngine && typeof LC.TimeEngine.advance === 'function') {
            LC.TimeEngine.advance();
            const timeInfo = L.time || {};
            return LC.replyStop(`‚è∞ –í—Ä–µ–º—è –∏–∑–º–µ–Ω–∏–ª–æ—Å—å: ${timeInfo.dayName}, ${timeInfo.timeOfDay}`);
          }
          return LC.replyStop("‚ùå TimeEngine not available");
        }
        
        // /time set day N [Name] - with defensive validation
        const setMatch = cmdRaw.match(/\/time\s+set\s+day\s+(\d+)(?:\s+(.+))?/i);
        if (setMatch) {
          const dayNum = parseInt(setMatch[1], 10);
          const dayNameCustom = setMatch[2] ? setMatch[2].trim() : null;
          
          // Defensive programming: validate day number is reasonable
          if (!Number.isFinite(dayNum) || dayNum < 1 || dayNum > 10000) {
            return LC.replyStop("‚ùå Invalid day number. Must be between 1 and 10000.");
          }
          
          if (!L.time) L.time = { currentDay: 1, dayName: '–ü–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫', timeOfDay: '–£—Ç—Ä–æ', turnsPerToD: 5, turnsInCurrentToD: 0, scheduledEvents: [] };
          L.time.currentDay = dayNum;
          
          if (dayNameCustom) {
            // Defensive programming: validate day name length
            if (dayNameCustom.length > 50) {
              return LC.replyStop("‚ùå Day name too long (max 50 characters).");
            }
            L.time.dayName = dayNameCustom;
          } else {
            // Auto-calculate day name based on day number
            const dayNames = ['–ü–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫', '–í—Ç–æ—Ä–Ω–∏–∫', '–°—Ä–µ–¥–∞', '–ß–µ—Ç–≤–µ—Ä–≥', '–ü—è—Ç–Ω–∏—Ü–∞', '–°—É–±–±–æ—Ç–∞', '–í–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ'];
            const dayIndex = ((dayNum - 1) % 7);
            L.time.dayName = dayNames[dayIndex];
          }
          
          return LC.replyStop(`üìÖ –î–µ–Ω—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: ${L.time.currentDay} (${L.time.dayName})`);
        }
        
        // /time ‚Äî show current time
        if (!L.time) L.time = { currentDay: 1, dayName: '–ü–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫', timeOfDay: '–£—Ç—Ä–æ', turnsPerToD: 5, turnsInCurrentToD: 0, scheduledEvents: [] };
        return LC.replyStop([
          "‚è∞ –¢–ï–ö–£–©–ï–ï –í–†–ï–ú–Ø",
          `–î–µ–Ω—å: ${L.time.currentDay} (${L.time.dayName})`,
          `–í—Ä–µ–º—è —Å—É—Ç–æ–∫: ${L.time.timeOfDay}`,
          `–•–æ–¥–æ–≤ –≤ —Ç–µ–∫—É—â–µ–º –≤—Ä–µ–º–µ–Ω–∏: ${L.time.turnsInCurrentToD}/${L.time.turnsPerToD}`
        ].join("\n"));
      }
    });

    // /weather
    reg.set("/weather", {
      description: "/weather ‚Äî show current weather | /weather set <type> ‚Äî change weather (clear/rain/snow/storm/fog/cloudy)",
      handler(args, text) {
        const L = LC.lcInit();
        const cmdRaw = text || "";
        if (typeof LC.replyStop !== "function") return { text: "‚ü¶SYS‚üß Weather command", stop: true };
        
        // /weather set <type>
        const setMatch = cmdRaw.match(/\/weather\s+set\s+(\w+)/i);
        if (setMatch) {
          const newWeather = setMatch[1].toLowerCase();
          const validWeather = ['clear', 'rain', 'snow', 'storm', 'fog', 'cloudy'];
          
          if (!validWeather.includes(newWeather)) {
            return LC.replyStop(`‚ùå Invalid weather. Valid options: ${validWeather.join(', ')}`);
          }
          
          if (LC.EnvironmentEngine && typeof LC.EnvironmentEngine.changeWeather === 'function') {
            LC.EnvironmentEngine.changeWeather(newWeather, false);
            return LC.replyStop(`‚úÖ Weather changed to: ${newWeather}`);
          }
          return LC.replyStop("‚ùå EnvironmentEngine not available");
        }
        
        // /weather ‚Äî show current
        if (!L.environment) L.environment = { weather: 'clear', location: '', ambiance: '' };
        const weatherEmoji = {
          clear: '‚òÄÔ∏è',
          rain: 'üåßÔ∏è',
          snow: '‚ùÑÔ∏è',
          storm: '‚õàÔ∏è',
          fog: 'üå´Ô∏è',
          cloudy: '‚òÅÔ∏è'
        };
        return LC.replyStop(`${weatherEmoji[L.environment.weather] || 'üå§Ô∏è'} Current weather: ${L.environment.weather}`);
      }
    });

    // /location
    reg.set("/location", {
      description: "/location ‚Äî show current location | /location set <name> ‚Äî set location",
      handler(args, text) {
        const L = LC.lcInit();
        const cmdRaw = text || "";
        if (typeof LC.replyStop !== "function") return { text: "‚ü¶SYS‚üß Location command", stop: true };
        
        // /location set <name>
        const setMatch = cmdRaw.match(/\/location\s+set\s+(.+)/i);
        if (setMatch) {
          const newLocation = setMatch[1].trim();
          
          if (newLocation.length > 100) {
            return LC.replyStop("‚ùå Location name too long (max 100 characters).");
          }
          
          if (!L.environment) L.environment = { weather: 'clear', location: '', ambiance: '' };
          L.environment.location = newLocation;
          L.stateVersion++;
          return LC.replyStop(`üìç Location set to: ${newLocation}`);
        }
        
        // /location ‚Äî show current
        if (!L.environment) L.environment = { weather: 'clear', location: '', ambiance: '' };
        const loc = L.environment.location || 'unknown';
        return LC.replyStop(`üìç Current location: ${loc}`);
      }
    });

    // /rumor
    reg.set("/rumor", {
      description: "/rumor ‚Äî list all rumors | /rumor add <text> about <char> ‚Äî create rumor | /rumor spread <id> from <char1> to <char2> ‚Äî spread rumor",
      handler(args, text) {
        const L = LC.lcInit();
        const cmdRaw = text || "";
        if (typeof LC.replyStop !== "function") return { text: "‚ü¶SYS‚üß Rumor command", stop: true };
        
        // /rumor add <text> about <char>
        const addMatch = cmdRaw.match(/\/rumor\s+add\s+(.+?)\s+about\s+(.+)/i);
        if (addMatch) {
          const rumorText = addMatch[1].trim();
          const subject = addMatch[2].trim();
          
          if (!L.rumors) L.rumors = [];
          
          const rumor = {
            id: LC.GossipEngine?.generateRumorId?.() || 'rumor_' + Date.now(),
            text: rumorText,
            type: 'custom',
            subject: subject,
            target: null,
            spin: 'neutral',
            turn: L.turn,
            knownBy: [],
            distortion: 0,
            verified: false,
            status: 'ACTIVE'
          };
          
          L.rumors.push(rumor);
          L.stateVersion++;
          return LC.replyStop(`üó£Ô∏è Rumor created: "${rumorText}" (ID: ${rumor.id})`);
        }
        
        // /rumor spread <id> from <char1> to <char2>
        const spreadMatch = cmdRaw.match(/\/rumor\s+spread\s+(\S+)\s+from\s+(.+?)\s+to\s+(.+)/i);
        if (spreadMatch) {
          const rumorId = spreadMatch[1].trim();
          const from = spreadMatch[2].trim();
          const to = spreadMatch[3].trim();
          
          if (LC.GossipEngine?.Propagator?.spreadRumor) {
            LC.GossipEngine.Propagator.spreadRumor(rumorId, from, to);
            return LC.replyStop(`‚úÖ Rumor spread from ${from} to ${to}`);
          }
          return LC.replyStop("‚ùå GossipEngine not available");
        }
        
        // /rumor ‚Äî list all
        if (!L.rumors) L.rumors = [];
        if (L.rumors.length === 0) {
          return LC.replyStop("üìã No rumors yet.");
        }
        
        const rumorList = L.rumors.map((r, i) => {
          const known = r.knownBy.length;
          const distortion = r.distortion.toFixed(1);
          return `${i + 1}. [${r.id.substr(-6)}] "${r.text.substr(0, 50)}..." - Known by ${known}, Distortion: ${distortion}`;
        }).join("\n");
        
        return LC.replyStop(`üó£Ô∏è ACTIVE RUMORS (${L.rumors.length}):\n${rumorList}`);
      }
    });

    // /reputation
    reg.set("/reputation", {
      description: "/reputation ‚Äî show all reputations | /reputation <char> ‚Äî show character reputation | /reputation set <char> <value> ‚Äî set reputation",
      handler(args, text) {
        const L = LC.lcInit();
        const cmdRaw = text || "";
        if (typeof LC.replyStop !== "function") return { text: "‚ü¶SYS‚üß Reputation command", stop: true };
        
        // /reputation set <char> <value>
        const setMatch = cmdRaw.match(/\/reputation\s+set\s+(.+?)\s+(\d+)/i);
        if (setMatch) {
          const char = setMatch[1].trim();
          const value = parseInt(setMatch[2], 10);
          
          if (!Number.isFinite(value) || value < 0 || value > 100) {
            return LC.replyStop("‚ùå Reputation must be between 0 and 100");
          }
          
          if (!L.characters[char]) {
            L.characters[char] = { mentions: 0, lastSeen: L.turn };
          }
          L.characters[char].reputation = value;
          L.stateVersion++;
          return LC.replyStop(`‚úÖ Reputation set: ${char} = ${value}`);
        }
        
        // /reputation <char>
        const charMatch = cmdRaw.match(/\/reputation\s+(.+)/i);
        if (charMatch) {
          const char = charMatch[1].trim();
          const reputation = L.characters[char]?.reputation;
          
          if (reputation === undefined) {
            return LC.replyStop(`‚ùå Character "${char}" not found or has no reputation`);
          }
          
          let reputationDesc = '';
          if (reputation >= 80) reputationDesc = 'Excellent';
          else if (reputation >= 60) reputationDesc = 'Good';
          else if (reputation >= 40) reputationDesc = 'Neutral';
          else if (reputation >= 20) reputationDesc = 'Poor';
          else reputationDesc = 'Bad';
          
          return LC.replyStop(`‚≠ê ${char}: ${reputation}/100 (${reputationDesc})`);
        }
        
        // /reputation ‚Äî show all
        const chars = Object.keys(L.characters).filter(c => L.characters[c].reputation !== undefined);
        if (chars.length === 0) {
          return LC.replyStop("üìã No reputations tracked yet.");
        }
        
        const repList = chars.map(char => {
          const rep = L.characters[char].reputation;
          return `${char}: ${rep}/100`;
        }).join("\n");
        
        return LC.replyStop(`‚≠ê CHARACTER REPUTATIONS:\n${repList}`);
      }
    });

    // /event
    reg.set("/event", {
      description: "/event add \"<Name>\" on day N ‚Äî schedule event",
      handler(args, text) {
        const L = LC.lcInit();
        const cmdRaw = text || "";
        if (typeof LC.replyStop !== "function") return { text: "‚ü¶SYS‚üß Event command", stop: true };
        
        // /event add "Name" on day N
        const addMatch = cmdRaw.match(/\/event\s+add\s+"([^"]+)"\s+on\s+day\s+(\d+)/i);
        if (!addMatch) {
          return LC.replyStop("‚ùå Usage: /event add \"<Name>\" on day N");
        }
        
        const eventName = addMatch[1].trim();
        const eventDay = parseInt(addMatch[2], 10);
        
        if (!eventName || eventName.length < 2) {
          return LC.replyStop("‚ùå Event name too short (min 2 chars)");
        }
        
        if (!Number.isFinite(eventDay) || eventDay < 1) {
          return LC.replyStop("‚ùå Invalid day number");
        }
        
        // Initialize time if needed
        if (!L.time) L.time = { currentDay: 1, dayName: '–ü–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫', timeOfDay: '–£—Ç—Ä–æ', turnsPerToD: 5, turnsInCurrentToD: 0, scheduledEvents: [] };
        if (!Array.isArray(L.time.scheduledEvents)) L.time.scheduledEvents = [];
        
        // Add event
        const event = {
          name: eventName,
          day: eventDay,
          id: `event_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`
        };
        
        L.time.scheduledEvents.push(event);
        
        const currentDay = L.time.currentDay || 1;
        const daysUntil = eventDay - currentDay;
        
        if (daysUntil === 0) {
          return LC.replyStop(`üìå –°–æ–±—ã—Ç–∏–µ "${eventName}" –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è (–¥–µ–Ω—å ${eventDay})`);
        } else if (daysUntil < 0) {
          return LC.replyStop(`üìå –°–æ–±—ã—Ç–∏–µ "${eventName}" –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ –Ω–∞ –¥–µ–Ω—å ${eventDay} (–≤ –ø—Ä–æ—à–ª–æ–º)`);
        } else {
          return LC.replyStop(`üìå –°–æ–±—ã—Ç–∏–µ "${eventName}" –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ –Ω–∞ –¥–µ–Ω—å ${eventDay} (—á–µ—Ä–µ–∑ ${daysUntil} –¥–Ω–µ–π)`);
        }
      }
    });

    // /schedule
    reg.set("/schedule", {
      description: "/schedule ‚Äî show all scheduled events",
      handler(args, text) {
        const L = LC.lcInit();
        if (typeof LC.replyStop !== "function") return { text: "‚ü¶SYS‚üß Schedule command", stop: true };
        
        if (!L.time) L.time = { currentDay: 1, dayName: '–ü–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫', timeOfDay: '–£—Ç—Ä–æ', turnsPerToD: 5, turnsInCurrentToD: 0, scheduledEvents: [] };
        if (!Array.isArray(L.time.scheduledEvents)) L.time.scheduledEvents = [];
        
        if (L.time.scheduledEvents.length === 0) {
          return LC.replyStop("üìÖ –ù–µ—Ç –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Å–æ–±—ã—Ç–∏–π");
        }
        
        const currentDay = L.time.currentDay || 1;
        const lines = ["üìÖ –†–ê–°–ü–ò–°–ê–ù–ò–ï –°–û–ë–´–¢–ò–ô"];
        
        // Sort events by day
        const sortedEvents = L.time.scheduledEvents.slice().sort((a, b) => (a.day || 0) - (b.day || 0));
        
        for (let i = 0; i < sortedEvents.length; i++) {
          const event = sortedEvents[i];
          const daysUntil = event.day - currentDay;
          let status = '';
          
          if (daysUntil < 0) {
            status = '(–ø—Ä–æ—à–ª–æ)';
          } else if (daysUntil === 0) {
            status = '(—Å–µ–≥–æ–¥–Ω—è!)';
          } else if (daysUntil === 1) {
            status = '(–∑–∞–≤—Ç—Ä–∞)';
          } else {
            status = `(—á–µ—Ä–µ–∑ ${daysUntil} –¥–Ω–µ–π)`;
          }
          
          lines.push(`–î–µ–Ω—å ${event.day}: ${event.name} ${status}`);
        }
        
        return LC.replyStop(lines.join("\n"));
      }
    });

    // /antiecho
    reg.set("/antiecho", {
      description: "/antiecho on|off|sensitivity N (1-100)|mode soft|hard|stats|flush",
      handler(args, text) {
        const L = LC.lcInit();
        const cmdRaw = text || "";
        if (typeof LC.replyStop !== "function") return { text: "‚ü¶SYS‚üß Anti-echo command", stop: true };
        if (/\/antiecho\s+stats/i.test(cmdRaw)) {
          const s = LC.antiEchoStats();
          return LC.replyStop([
            "=== ANTI-ECHO STATS ===",
            `LRU size: ${s.lruSize}`,
            `Cache entries: ${s.cacheEntries}`,
            `Cache hits: ${s.hits}`
          ].join("\n"));
        }
        if (/\/antiecho\s+flush/i.test(cmdRaw)) {
          LC.antiEchoFlush();
          return LC.replyStop("Anti-echo cache flushed.");
        }
        if (/\/antiecho\s+on/i.test(cmdRaw))  { L.antiEchoEnabled = true;  return LC.replyStop("‚úÖ Anti-echo enabled."); }
        if (/\/antiecho\s+off/i.test(cmdRaw)) { L.antiEchoEnabled = false; return LC.replyStop("‚ö´ Anti-echo disabled."); }
        if (/\/antiecho\s+sensitivity\s+(\d{1,3})/i.test(cmdRaw)) {
          const v = Math.max(1, Math.min(100, parseInt(cmdRaw.match(/sensitivity\s+(\d{1,3})/i)[1], 10)));
          L.antiEchoSensitivity = v; return LC.replyStop(`üîß Anti-echo sensitivity = ${v}%`);
        }
        if (/\/antiecho\s+mode\s+(soft|hard)/i.test(cmdRaw)) {
          L.antiEchoMode = (cmdRaw.match(/mode\s+(soft|hard)/i)[1].toLowerCase() === "hard") ? "hard" : "soft";
          return LC.replyStop(`üõ°Ô∏è Anti-echo mode = ${L.antiEchoMode.toUpperCase()}`);
        }
        const base = (L.antiEchoSensitivity || 85) / 100;
        const multSoft = LC.CONFIG.LIMITS.ANTI_ECHO.CONTINUE_THRESHOLD_MULT.SOFT;
        const multHard = LC.CONFIG.LIMITS.ANTI_ECHO.CONTINUE_THRESHOLD_MULT.HARD;
        return LC.replyStop([
          "=== ANTI-ECHO SETTINGS ===",
          `Status: ${L.antiEchoEnabled ? "Enabled" : "Disabled"}`,
          `Sensitivity: ${L.antiEchoSensitivity || 85}%`,
          `Mode: ${L.antiEchoMode || "soft"}`,
          `Continue thr (soft/hard): ${(Math.min(0.99, base*multSoft)).toFixed(2)} / ${(Math.min(0.99, base*multHard)).toFixed(2)}`,
          `Echo hits: ${L.tm.echoHits || 0}`
        ].join("\n"));
      }
    });

    // /events
    reg.set("/events", {
      description: "/events [N] ‚Äî list recent events with score contribution",
      handler(args, text) {
        const cmdRaw = text || "";
        if (typeof LC.replyStop !== "function") return { text: "‚ü¶SYS‚üß Events command", stop: true };
        const m = cmdRaw.match(/\/events(?:\s+(\d+))?/i);
        const n = m && m[1] ? parseInt(m[1],10) : 10;
        const diag = LC.getEventsDiagnostics(n);
        const lines = diag.rows.map(r => `${r.type.padEnd(10)} | turn ${String(r.turn).padStart(3)} | ${String(r.ago).padStart(2)} ago | w=${r.w} decay=${r.decay} ‚Üí +${r.contrib}`);
        return LC.replyStop([
          `=== EVENTS (last ${diag.rows.length}) ‚Äî contribution total: +${diag.total} ===`,
          ...lines
        ].join("\n"));
      }
    });

    // /alias
    reg.set("/alias", {
      description: "/alias add <Name>=a,b,c | /alias del <Name> | /alias list",
      handler(args, text) {
        const L = LC.lcInit();
        const cmdRaw = text || "";
        if (typeof LC.replyStop !== "function") return { text: "‚ü¶SYS‚üß Alias command", stop: true };
        if (/\/alias\s+list/i.test(cmdRaw)) {
          const map = L.aliases || {};
          const keys = Object.keys(map);
          if (!keys.length) return LC.replyStop("No custom aliases.");
          const out = keys.map(k => `${k}: ${map[k].join(", ")}`);
          return LC.replyStop("=== ALIASES ===\n" + out.join("\n"));
        }
        if (/\/alias\s+add\s+/i.test(cmdRaw)) {
          const m = cmdRaw.match(/\/alias\s+add\s+([^=]+)=(.+)$/i);
          if (!m) return LC.replyStop("Usage: /alias add <Name>=a,b,c");
          const name = m[1].trim();
          const list = m[2].split(",").map(s=>s.trim()).filter(Boolean);
          L.aliases = (L.aliases && typeof L.aliases === "object") ? L.aliases : {};
          L.aliases[name] = list;
          LC.sanitizeAliases?.(L);
          const finalList = Array.isArray(L.aliases[name]) ? L.aliases[name] : [];
          return LC.replyStop(`Alias set: ${name} = ${finalList.join(", ")}`);
        }
        if (/\/alias\s+del\s+/i.test(cmdRaw)) {
          const m = cmdRaw.match(/\/alias\s+del\s+(.+)$/i);
          if (!m) return LC.replyStop("Usage: /alias del <Name>");
          const name = m[1].trim();
          L.aliases = (L.aliases && typeof L.aliases === "object") ? L.aliases : {};
          if (name in L.aliases) {
            delete L.aliases[name];
            LC.sanitizeAliases?.(L);
            return LC.replyStop(`Alias deleted: ${name}`);
          }
          return LC.replyStop(`No alias for: ${name}`);
        }
        return LC.replyStop("Usage: /alias add <Name>=a,b,c | /alias del <Name> | /alias list");
      }
    });

    // /evhist
    reg.set("/evhist", {
      description: "/evhist cap <N> | /evhist last <N> | /evhist clear",
      handler(args, text) {
        const L = LC.lcInit();
        const cmdRaw = text || "";
        if (typeof LC.replyStop !== "function") return { text: "‚ü¶SYS‚üß Evhist command", stop: true };
        if (/\/evhist\s+cap\s+(\d+)/i.test(cmdRaw)) {
          const cap = Math.max(0, parseInt(cmdRaw.match(/cap\s+(\d+)/i)[1],10));
          LC.capEvergreenHistory(cap);
          return LC.replyStop(`Evergreen history cap = ${cap || "no cap"}.`);
        }
        if (/\/evhist\s+last\s+(\d+)/i.test(cmdRaw)) {
          const n = Math.max(1, parseInt(cmdRaw.match(/last\s+(\d+)/i)[1],10));
          const arr = (L.evergreen && Array.isArray(L.evergreen.history)) ? L.evergreen.history.slice(-n) : [];
          if (!arr.length) return LC.replyStop("Evergreen history is empty.");
          const show = arr.map(h => {
            const oldS = String(h.old||"").slice(0,40);
            const newS = String(h.new||"").slice(0,40);
            return `t${h.turn} [${h.category}] ${oldS} ‚áí ${newS}`;
          });
          return LC.replyStop("=== EV HISTORY ===\n" + show.join("\n"));
        }
        if (/\/evhist\s+clear/i.test(cmdRaw)) {
          if (L.evergreen) L.evergreen.history = [];
          return LC.replyStop("Evergreen history cleared.");
        }
        return LC.replyStop("Usage: /evhist cap <N> | /evhist last <N> | /evhist clear");
      }
    });

    // /characters
    reg.set("/characters", {
      description: "/characters ‚Äî list active NPCs",
      handler(args, text) {
        if (typeof LC.replyStop !== "function") return { text: "‚ü¶SYS‚üß Characters command", stop: true };
        const chars = LC.getActiveCharacters(10);
        if (chars.length) return LC.replyStop("=== ACTIVE CHARACTERS ===\n" +
          chars.map(c => `${c.name}: ${c.mentions} mentions, ${c.turnsAgo} turns ago`).join("\n"));
        return LC.replyStop("No active characters tracked yet.");
      }
    });

    // /opening
    reg.set("/opening", {
      description: "/opening ‚Äî show captured opening",
      handler(args, text) {
        if (typeof LC.replyStop !== "function") return { text: "‚ü¶SYS‚üß Opening command", stop: true };
        return LC.replyStop(LC.getOpeningLine() || "No opening captured yet.");
      }
    });

    // /retry
    reg.set("/retry", {
      description: "/retry ‚Äî show retry info",
      handler(args, text) {
        const L = LC.lcInit();
        const cmdRaw = text || "";
        if (typeof LC.replyStop !== "function") return { text: "‚ü¶SYS‚üß Retry command", stop: true };
        if (/\/retry\s+keep/i.test(cmdRaw)) {
          if (!L.currentAction) L.currentAction = {};
          L.currentAction.RETRY_KEEP_CONTEXT = true;
          return LC.replyStop("üîÅ Retry: keep context = ON.");
        }
        if (/\/retry\s+clear/i.test(cmdRaw)) {
          if (!L.currentAction) L.currentAction = {};
          L.currentAction.RETRY_KEEP_CONTEXT = false;
          return LC.replyStop("üîÅ Retry: keep context = OFF.");
        }
        const keep = L.currentAction?.RETRY_KEEP_CONTEXT || false;
        return LC.replyStop([
          "=== RETRY ===",
          `Consecutive: ${L.consecutiveRetries || 0}`,
          `Total: ${L.tm?.retries || 0}`,
          `Turn: ${L.turn}, LastProcessed: ${L.lastProcessedTurn}`,
          `isRetry=${L.currentAction?.type === 'retry'}, isContinue=${L.currentAction?.type === 'continue'}`,
          `Keep context: ${keep ? "ON" : "OFF"}`
        ].join("\n"));
      }
    });

    // /cadence
    reg.set("/cadence", {
      description: "/cadence N ‚Äî set recap cadence (6-24)",
      handler(args, text) {
        const L = LC.lcInit();
        const cmdRaw = text || "";
        if (typeof LC.replyStop !== "function") return { text: "‚ü¶SYS‚üß Cadence command", stop: true };
        const m = cmdRaw.match(/\/cadence\s+(\d{1,3})/i);
        if (m) {
          const req = parseInt(m[1], 10);
          const v = Math.max(LC.CONFIG.LIMITS.CADENCE.MIN, Math.min(LC.CONFIG.LIMITS.CADENCE.MAX, req));
          L.cadence = v;
          if (req !== v) return LC.replyStop(`‚è±Ô∏è Recap cadence: requested ${req} ‚Üí applied ${v} (range ${LC.CONFIG.LIMITS.CADENCE.MIN}-${LC.CONFIG.LIMITS.CADENCE.MAX}).`);
          return LC.replyStop(`‚è±Ô∏è Recap cadence ‚Üí ${v} turns.`);
        }
        return LC.replyStop(`Current cadence: ${L.cadence} turns.`);
      }
    });

    // /story
    reg.set("/story", {
      description: "/story add <text> | /story del <id>",
      handler(args, text) {
        const L = LC.lcInit();
        const cmdRaw = text || "";
        if (typeof LC.replyStop !== "function") return { text: "‚ü¶SYS‚üß Story command", stop: true };
        if (/^\/story\s+add\s+/i.test(cmdRaw)) {
          const m = cmdRaw.match(/^\/story\s+add\s+([\s\S]+)$/i);
          const entry = m ? m[1].trim() : "";
          if (!entry || entry.length < 10) return LC.replyStop("Usage: /story add <—Ç–µ–∫—Å—Ç –∫–∞—Ä—Ç–æ—á–∫–∏ (‚â•10 —Å–∏–º–≤–æ–ª–æ–≤)>");
          const id = LC.createStoryCard(entry, [Math.max(0, L.turn - L.cadence), L.turn], "note");
          return LC.replyStop(`üìù Card saved ‚Äî ID: ${id}`);
        }
        if (/^\/story\s+del\s+/i.test(cmdRaw)) {
          const m = cmdRaw.match(/^\/story\s+del\s+(\S+)/i);
          if (!m) return LC.replyStop("Usage: /story del <id>");
          const id = m[1].trim();
          const ok = LC.removeStoryCardById(id);
          return LC.replyStop(ok ? `üóëÔ∏è Card ${id} removed.` : `üîé Card ${id} not found (removed from registry if present).`);
        }
        return LC.replyStop("Usage: /story add <text> | /story del <id>");
      }
    });

    // /cards
    reg.set("/cards", {
      description: "/cards ‚Äî list managed cards",
      handler(args, text) {
        const L = LC.lcInit();
        if (typeof LC.replyStop !== "function") return { text: "‚ü¶SYS‚üß Cards command", stop: true };
        const st  = (typeof state !== "undefined") ? state : {};
        const ext = Array.isArray(st.$$WORLD_INFO_EXTENDED) ? st.$$WORLD_INFO_EXTENDED : [];
        const extSet = {};
        for (let i=0;i<ext.length;i++){
          const id = ext[i] && ext[i].worldInfoId;
          if (id) extSet[id] = 1;
        }
        const ids = L.worldInfoIds.slice(-15);
        if (!ids.length) return LC.replyStop("No managed cards.");
        return LC.replyStop("=== CARDS (managed) ===\n" +
          ids.map((id,i)=>{
            const pin = (L.pinnedWorldInfoIds.indexOf(id)!==-1) ? " [PIN]" : "";
            const mk  = extSet[id] ? " [EXT]" : "";
            return `${i+1}. ${id}${pin}${mk}`;
          }).join("\n"));
      }
    });

    // /pin
    reg.set("/pin", {
      description: "/pin <id> ‚Äî pseudo-pin for cleanup",
      handler(args, text) {
        const L = LC.lcInit();
        const cmdRaw = text || "";
        if (typeof LC.replyStop !== "function") return { text: "‚ü¶SYS‚üß Pin command", stop: true };
        const m = cmdRaw.match(/\/pin\s+(\S+)/i);
        if (!m) return LC.replyStop("Usage: /pin <id>");
        const id = m[1];
        if (L.pinnedWorldInfoIds.indexOf(id) === -1) L.pinnedWorldInfoIds.push(id);
        return LC.replyStop(`üìå Pseudo-pin set for ${id}.`);
      }
    });

    // /unpin
    reg.set("/unpin", {
      description: "/unpin <id> ‚Äî remove pseudo-pin",
      handler(args, text) {
        const L = LC.lcInit();
        const cmdRaw = text || "";
        if (typeof LC.replyStop !== "function") return { text: "‚ü¶SYS‚üß Unpin command", stop: true };
        const m = cmdRaw.match(/\/unpin\s+(\S+)/i);
        if (!m) return LC.replyStop("Usage: /unpin <id>");
        const id = m[1];
        const p = L.pinnedWorldInfoIds.indexOf(id);
        if (p !== -1) L.pinnedWorldInfoIds.splice(p,1);
        return LC.replyStop(`üìå Pseudo-pin removed for ${id}.`);
      }
    });

    // /del
    reg.set("/del", {
      description: "/del <id> ‚Äî remove card by id (if possible)",
      handler(args, text) {
        const L = LC.lcInit();
        const cmdRaw = text || "";
        if (typeof LC.replyStop !== "function") return { text: "‚ü¶SYS‚üß Del command", stop: true };
        const m = cmdRaw.match(/\/del\s+(\S+)/i);
        if (!m) return LC.replyStop("Usage: /del <id>");
        const id = m[1];
        const p = L.pinnedWorldInfoIds.indexOf(id);
        if (p !== -1) L.pinnedWorldInfoIds.splice(p,1);
        const ok = LC.removeStoryCardById(id);
        return LC.replyStop(ok ? `üóëÔ∏è Card ${id} removed.` : `üîé Card ${id} not found (removed from registry if present).`);
      }
    });

    // /ctx
    reg.set("/ctx", {
      description: "/ctx ‚Äî inspect context overlay composition",
      handler(args, text) {
        if (typeof LC.replyStop !== "function") return { text: "‚ü¶SYS‚üß Ctx command", stop: true };
        const limit = LC.CONFIG?.LIMITS?.CONTEXT_LENGTH ?? 800;
        let preview = {};
        try {
          const result = LC.buildCtxPreview?.({ limit, allowPartial: true });
          if (result && typeof result === "object") preview = result;
        } catch (_) {/* ignore */}
        const overlayRaw = typeof preview.overlay === "string"
          ? preview.overlay
          : String(preview.text ?? preview.overlay ?? "");
        const overlay = overlayRaw.length > limit ? overlayRaw.slice(0, limit) : overlayRaw;
        const max = (typeof preview?.max === "number" && isFinite(preview.max)) ? preview.max : limit;
        const parts = (preview.parts && typeof preview.parts === "object") ? preview.parts : {};
        const lines = [
          `LEN: ${overlay.length}/${max}`,
          `GUIDE: ${parts.GUIDE||0}`,
          `INTENT: ${parts.INTENT||0}`,
          `TASK: ${parts.TASK||0}`,
          `CANON: ${parts.CANON||0}`,
          `OPENING: ${parts.OPENING||0}`,
          `SCENE: ${parts.SCENE||0}`,
          `META: ${parts.META||0}`
        ];
        if (preview.error) lines.push(`ERROR: ${preview.error}`);
        let sampleSource = typeof preview.preview === "string"
          ? preview.preview
          : (typeof preview.overlay === "string" ? preview.overlay : overlay);
        if (typeof sampleSource !== "string") sampleSource = "";
        const sample = sampleSource.split(/\r?\n/).slice(0,8).join("\n");
        return LC.replyStop("=== CONTEXT INSPECTOR ===\n" + lines.join(" | ") + "\n---\n" + sample);
      }
    });

    // /selftest
    reg.set("/selftest", {
      description: "/selftest ‚Äî run system tests",
      handler(args, text) {
        const L = LC.lcInit();
        const cmdRaw = text || "";
        if (typeof LC.replyStop !== "function") return { text: "‚ü¶SYS‚üß Selftest command", stop: true };
        const cfg = LC.CONFIG || {};
        const anti = [
          L.antiEchoEnabled ? "ON" : "OFF",
          (L.antiEchoMode || "soft"),
          `@${L.antiEchoSensitivity ?? 85}%`
        ].join(" ");
        const out = [
          "=== SELFTEST ===",
          `Version: ${cfg.VERSION || "n/a"}`,
          `Data: ${cfg.DATA_VERSION || "n/a"}`,
          `Cadence: ${L.cadence} (muteUntil=${L.recapMuteUntil ?? "-"}, sinceRecap=${(L.turn - (L.lastRecapTurn || 0)) || 0})`,
          `Anti-echo: ${anti}`,
          `CurrentAction: type=${L.currentAction?.type || 'none'}, task=${L.currentAction?.task || 'none'}, RETRY_KEEP_CONTEXT=${L.currentAction?.RETRY_KEEP_CONTEXT || false}`
        ];
        const mods = (L && L._modsSeen) || {};
        const modList = Object.entries(mods).map(([k,v]) => `${k}:${v}`).join(", ");
        const modSummary = modList || "n/a";
        out.push(`versions=[${modSummary}]`);
        const flagsReset = (() => {
          try {
            LC.Flags?.clearCmd?.();
          } catch (_) {}
          return L.currentAction?.type !== 'command' && L.currentAction?.type !== 'retry' && L.currentAction?.type !== 'continue';
        })();
        const flagsResetStatus = flagsReset ? "ok" : "warn";
        out.push(`flagsReset=${flagsResetStatus}`);
        out.push(`echoCache=${LC._echoOrder?.length ?? 0}`);
        const ever = (L && L.evergreen) || {};
        out.push(`evHist=${ever.history?.length ?? 0}`);
        return LC.replyStop(out.join("\n"));
      }
    });
  })();

  // –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π stop-–æ—Ç–≤–µ—Ç: –ø—Ä–æ–±—É–µ–º —ç–∫—Å–ø–æ—Ä—Ç –∏–∑ Input, –∏–Ω–∞—á–µ ‚Äî –ª–æ–∫–∞–ª—å–Ω—ã–π fallback
  function _safeCmd(msg){
    if (typeof LC !== "undefined" && typeof LC.replyStop === "function") {
      return LC.replyStop(msg);
    }
    return { text: (LC.CONFIG?.CMD_PLACEHOLDER ?? "‚ü¶SYS‚üß OK."), stop: true, _sys: String(msg ?? "") };
  }

  if (!LC.Commands.has("/help")) {
    LC.Commands.set("/help",  { bypass: true, handler: () => _safeCmd("Help shown.") });
  }
  if (!LC.Commands.has("/stats")) {
    LC.Commands.set("/stats", { bypass: true, handler: () => _safeCmd("Stats shown.") });
  }

  // FNV-1a 32-bit (—É–º–Ω–æ–∂–µ–Ω–∏–µ –Ω–∞ prime —á–µ—Ä–µ–∑ —Å—É–º–º—É —Å–¥–≤–∏–≥–æ–≤ ‚Äî —ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç Math.imul(h, 0x01000193))
  const FNV1A = (str) => {
    let h = 0x811c9dc5 >>> 0;
    const s = String(str || "");
    for (let i = 0; i < s.length; i++) {
      h ^= s.charCodeAt(i);
      h = (h + ((h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24))) >>> 0;
    }
    return h >>> 0;
  };

  const CONFIG = {
  VERSION: "16.0.8-compat6d",
  DATA_VERSION: "16.0.8-compat6d",
  CHAR_WINDOW_HOT: 3,
  CHAR_WINDOW_ACTIVE: 10,
  CMD_PLACEHOLDER: "‚ü¶SYS‚üß OK.",
  LIMITS: {
    CONTEXT_LENGTH: 800,
    SYS_MSGS_MAX: 15,
    CARDS_MAX: 50,
    CADENCE: { MIN: 6, MAX: 24, DEFAULT: 12 },
    EVERGREEN_MAX_PER_CATEGORY: 5,
    ANTI_ECHO: {
      MIN_LENGTH: 200,
      SIMILARITY_THRESHOLD_DEFAULT: 0.85,
      TRIM_PERCENTAGE: 0.75,
      CONTINUE_TRIM: 0.60,
      CHECK_TAIL_LENGTH: 300,
      CACHE_MAX: 1024,
      CONTINUE_THRESHOLD_MULT: { SOFT: 0.96, HARD: 0.90 }
    },
    EXTENDED_STORE_CAP: 120,
    EVENTS_WINDOW_TURNS: 50
  },
  FEATURES: { USE_NORM_CACHE: false, ANALYZE_RELATIONS: true },
  RELATIONSHIP_MODIFIERS: {
    romance: 15,
    conflict: -10,
    betrayal: -25,
    loyalty: 10
  },
  RECAP_V2: {
    SCORE_THRESHOLD: 1.0,
    COOLDOWN_TURNS: 3,
    BASE_CADENCE_BONUS: 0.08,
    DECAY_HALF_LIFE: 12,
    WEIGHTS: {
      conflict: 1.0, romance: 1.2, authority: 0.8, achievement: 0.9,
      reveal: 1.1, location: 0.4, timeskip: 0.5, betrayal: 1.3, loyalty: 0.9,
      social_upheaval: 1.4, secret_reveal: 1.5, goal_outcome: 1.2, dramatic: 1.6
    },
    HOT_NPC_BONUS: 0.25,
    AUTO_EPOCH_SCORE: 1.5,
    AUTO_EPOCH_WINDOW: 8,
    AUTO_EPOCH_MIN_RECAPS: 2
  }
};

  CONFIG.LIMITS.EVERGREEN_HISTORY_CAP ??= 400;

  Object.assign(LC, {
    CONFIG,
    DATA_VERSION: "16.0.8-compat6d",

    /**
     * Initializes and returns the Lincoln state object with all necessary defaults.
     * This is the primary entry point for accessing the Lincoln system state.
     * @param {string} [slot] - The script slot identifier (e.g., "Library", "Input", "Output", "Context")
     * @returns {object} The initialized Lincoln state object with all required properties
     */
    lcInit(slot = __SCRIPT_SLOT__) {
      const st = getState();
      const L = (st.lincoln = st.lincoln || {});
      const scriptSlot = toStr(slot || __SCRIPT_SLOT__ || "Library");
      const seen = (L._modsSeen = L._modsSeen || {});
      seen[scriptSlot] = LC.DATA_VERSION;
      if (!L._versionCheckDone) {
        const entries = Object.entries(seen).filter(([, v]) => v);
        if (entries.length > 1) {
          const baseVersion = entries[0][1];
          const hasMismatch = entries.some(([, v]) => v !== baseVersion);
          if (hasMismatch) {
            const summary = entries.map(([name, v]) => `${name}=${v}`).join(", ");
            const msg = `‚ö†Ô∏è Lincoln module data versions differ: ${summary}`;
            LC.pushNotice?.(msg);
            L._versionCheckDone = true;
          }
        }
      }
      L.version = CONFIG.VERSION;
      // echo cache auto-flush on new session
      try { if ((L.turn|0) <= 0) { this._echoCache = {}; this._echoOrder = []; } } catch(_) {}
      
      // stateVersion counter for context caching
      L.stateVersion = L.stateVersion || 0;

      // –Ø–≤–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫—ç—à–∞ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –¥–ª—è —è—Å–Ω–æ—Å—Ç–∏ –∏ –ø—Ä–µ–¥—Å–∫–∞–∑—É–µ–º–æ—Å—Ç–∏.
      // –≠—Ç–æ—Ç –æ–±—ä–µ–∫—Ç –∫—ç—à–∏—Ä—É–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã composeContextOverlay –¥–ª—è –ø–æ–≤—ã—à–µ–Ω–∏—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏.
      // –ö–ª—é—á - –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤—ã–∑–æ–≤–∞, –∑–Ω–∞—á–µ–Ω–∏–µ - —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∏ –≤–µ—Ä—Å–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è.
      if (!LC._contextCache) {
        LC._contextCache = {};
      }

      // turn/flags
      L.turn = toNum(L.turn, 0);
      L.lastProcessedTurn = toNum(L.lastProcessedTurn, -1);
      L.lastActionType = toStr(L.lastActionType);
      L.currentAction = L.currentAction || {};

      // io
      L.lastInput = toStr(L.lastInput);
      L.lastOutput = toStr(L.lastOutput);
      L.prevOutput = toStr(L.prevOutput);
      L.lastIntent = toStr(L.lastIntent);

      // counters
      L.retryCount = toNum(L.retryCount, 0);
      L.consecutiveRetries = toNum(L.consecutiveRetries, 0);
      L.continueCount = toNum(L.continueCount, 0);

      // settings
      L.antiEchoEnabled = toBool(L.antiEchoEnabled, true);
      L.antiEchoSensitivity = toNum(L.antiEchoSensitivity, 85);
      L.antiEchoMode = (L.antiEchoMode === "hard") ? "hard" : "soft";
      {
  const MIN = CONFIG.LIMITS.CADENCE.MIN;
  const MAX = CONFIG.LIMITS.CADENCE.MAX;
  const DEF = CONFIG.LIMITS.CADENCE.DEFAULT;
  let cad = toNum(L.cadence, DEF);
  if (!cad || cad < MIN) cad = DEF;
  L.cadence = Math.min(MAX, Math.max(MIN, cad));
}
L.debugMode = toBool(L.debugMode, false);
      L.sysShow = toBool(L.sysShow, true);
      L.playerInfoLevel = (L.playerInfoLevel === 'director') ? 'director' : 'character';

      // opening
      L.opening = toStr(L.opening);
      L.openingCaptured = toBool(L.openingCaptured, false);
      L.openingTurn = toNum(L.openingTurn, -1);
      L.openingTTL = toNum(L.openingTTL, 15);

      // system messages
      L.sysMsgs = Array.isArray(L.sysMsgs) ? L.sysMsgs : [];
      if (L.sysMsgs.length > CONFIG.LIMITS.SYS_MSGS_MAX) {
        L.sysMsgs = L.sysMsgs.slice(-CONFIG.LIMITS.SYS_MSGS_MAX);
      }

      // characters/cards/aliases
      L.characters = L.characters || {};
      L.worldInfoIds = Array.isArray(L.worldInfoIds) ? L.worldInfoIds : [];
      L.pinnedWorldInfoIds = Array.isArray(L.pinnedWorldInfoIds) ? L.pinnedWorldInfoIds : [];
      L.aliases = L.aliases || {}; // { "–•–ª–æ—è": ["chloe","harper"] }

      // recap/epoch + drafts
      L.lastRecapTurn = toNum(L.lastRecapTurn, 0);
      L.lastEpochTurn = toNum(L.lastEpochTurn, 0);
      L.recapDraft = L.recapDraft || null;
      L.epochDraft = L.epochDraft || null;
      L.recapMuteUntil = toNum(L.recapMuteUntil, 0);

      // events/telemetry
      L.events = Array.isArray(L.events) ? L.events : [];
      L.tm = L.tm || {}; // wantRecapTurn, recaps, epochs, echoHits, errors, etc.
      L.tm.recapTurns = Array.isArray(L.tm.recapTurns) ? L.tm.recapTurns : [];
      L.tm.echoCacheHits = toNum(L.tm.echoCacheHits, 0);

      // evergreen (+history cap)
      L.evergreen = L.evergreen || {
        enabled: true, relations: {}, status: {}, obligations: {}, facts: {},
        history: [], lastUpdate: 0
      };
      L.evergreen.history = Array.isArray(L.evergreen.history) ? L.evergreen.history : [];
      
      // goals tracking
      L.goals = L.goals || {};
      
      // character mood/status tracking
      L.character_status = L.character_status || {};
      
      // secrets tracking
      L.secrets = Array.isArray(L.secrets) ? L.secrets : [];
      
      // time tracking
      L.time = L.time || {
        currentDay: 1,
        dayName: '–ü–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫',
        timeOfDay: '–£—Ç—Ä–æ',
        turnsPerToD: 5,
        turnsInCurrentToD: 0,
        scheduledEvents: []
      };
      
      // environment tracking
      L.environment = L.environment || {
        weather: 'clear',
        location: '',
        ambiance: ''
      };
      
      // rumors and reputation tracking
      L.rumors = Array.isArray(L.rumors) ? L.rumors : [];
      // Initialize reputation for all characters
      for (const charName in L.characters) {
        if (!L.characters[charName].reputation) {
          L.characters[charName].reputation = 50; // neutral default
        }
      }
      
      // population tracking (demographic pressure)
      L.population = L.population || {
        unnamedStudents: 50,
        unnamedTeachers: 5
      };
      
      // society tracking (social norms and hierarchy)
      L.society = L.society || {
        norms: {},
        myths: []
      };
      // Ensure myths array exists even if society object already existed
      L.society.myths = L.society.myths || [];
      
      const defaultEvergreenCapRaw = CONFIG?.LIMITS?.EVERGREEN_HISTORY_CAP;
      const defaultEvergreenCapNum = Number(defaultEvergreenCapRaw);
      const evergreenCapDefault = Number.isFinite(defaultEvergreenCapNum) ? defaultEvergreenCapNum : 0;
      const evergreenCapNum = Number(L.evergreenHistoryCap);
      if (L.evergreenHistoryCap == null || Number.isNaN(evergreenCapNum)) {
        L.evergreenHistoryCap = evergreenCapDefault;
      } else {
        L.evergreenHistoryCap = evergreenCapNum;
      }
      // 0 = –±–µ–∑ –∫–∞–ø–∞

      // User config merge: –µ—Å–ª–∏ –≤ state –µ—Å—Ç—å lincoln_config, —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ –º–µ—Ä–∂–∏–º —Å LC.CONFIG
      if (st.lincoln_config && typeof st.lincoln_config === 'object') {
        try {
          const deepMerge = (target, source) => {
            if (!source || typeof source !== 'object' || Array.isArray(source)) return target;
            const result = { ...target };
            for (const key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                const srcVal = source[key];
                const tgtVal = target[key];
                if (srcVal && typeof srcVal === 'object' && !Array.isArray(srcVal) && tgtVal && typeof tgtVal === 'object' && !Array.isArray(tgtVal)) {
                  result[key] = deepMerge(tgtVal, srcVal);
                } else {
                  result[key] = srcVal;
                }
              }
            }
            return result;
          };
          LC.CONFIG = deepMerge(LC.CONFIG, st.lincoln_config);
        } catch (e) {
          LC.lcWarn?.('Config merge failed: ' + (e && e.message ? e.message : e));
        }
      }

      return L;
    },

    // ---------- SYS ----------
    /**
     * Adds a system message to the message queue.
     * @param {string|object} msg - The message to add, or an object with {text, level}
     * @param {object} [options] - Optional parameters {level: 'director'|'character'}
     */
    lcSys(msg, options)  { 
      const L=this.lcInit(); 
      let text = msg;
      let level = 'character';
      
      // Handle object parameter (msg as {text, level})
      if (msg && typeof msg === 'object' && !Array.isArray(msg)) {
        text = msg.text || '';
        level = msg.level || 'character';
      }
      // Handle options parameter
      else if (options && typeof options === 'object') {
        level = options.level || 'character';
      }
      
      const msgText = `‚ü¶SYS‚üß ${toStr(text)}`;
      const msgObj = { text: msgText, level: level };
      L.sysMsgs.push(msgObj);
      if (L.sysMsgs.length > CONFIG.LIMITS.SYS_MSGS_MAX) {
        L.sysMsgs = L.sysMsgs.slice(-Math.floor(CONFIG.LIMITS.SYS_MSGS_MAX/2));
      } 
      return msgObj; // Return for debugging
    },
    /**
     * Adds a warning message to the system message queue.
     * @param {string} m - The warning message
     */
    lcWarn(m)   { this.lcSys("‚ö†Ô∏è " + m); },
    /**
     * Adds an error message and increments the error counter.
     * @param {string} m - The error message
     */
    lcError(m)  { this.lcSys("‚ùå " + m); const L=this.lcInit(); L.tm.errors=(L.tm.errors||0)+1; },
    /**
     * Adds a debug message if debug mode is enabled.
     * @param {string} m - The debug message
     */
    lcDebug(m)  { const L=this.lcInit(); if (L.debugMode) this.lcSys("üîç " + m); },
    /**
     * Retrieves and clears all queued system messages.
     * Normalizes messages to consistent format {text, level}.
     * @returns {Array<{text: string, level: string}>} Array of system message objects
     */
    lcConsumeMsgs(){ 
      const L=this.lcInit(); 
      const msgs = L.sysMsgs.slice();
      L.sysMsgs=[]; 
      // Normalize to object format for backward compatibility
      return msgs.map(m => {
        if (typeof m === 'string') return { text: m, level: 'character' };
        if (m && typeof m === 'object') return { text: m.text || '', level: m.level || 'character' };
        return { text: '', level: 'character' };
      });
    },

    // ---------- Text utils ----------
    _normU(s){
      const src = toStr(s).toLowerCase();
      try {
        return src.replace(/[^\p{L}\p{N}\s]+/gu, " ").replace(/\s+/g, " ").trim();
      } catch(e) {
        return src.replace(/[^\w\s]+/g, " ").replace(/\s+/g, " ").trim();
      }
    },
    lcStripSys(text){ return toStr(text).replace(/‚ü¶[A-Z]+‚üß[^\n]*\n?/g, "").trim(); },
    stripYouWrappers(s){
      let x = toStr(s).trim();
      const m1 = x.match(/^\s*You\s+(say|ask|whisper|shout)\s*[:"'¬ª¬´‚Äú‚Äù‚Äû]?([\s\S]*?)["'¬ª¬´‚Äú‚Äù‚Äû]?\s*$/i);
      if (m1) return m1[2].trim();
      const m2 = x.match(/^\s*You\s+(?!say|ask|whisper|shout)(.+)$/i);
      if (m2) return m2[1].trim();
      return x;
    },

    // ---------- Continue/Retry helpers ----------
    /**
     * Checks if the input is a soft continue (empty, whitespace, or continue keyword).
     * @param {string} raw - The raw input text
     * @returns {boolean} True if input is a soft continue
     */
    _isSoftContinue(raw){
      const r = String(raw == null ? "" : raw);
      const tokens = ["", " ", "...", "‚Äî", ">"];
      if (tokens.indexOf(r) !== -1) return true;
      if (/^(continue|next|–¥–∞–ª—å—à–µ|–ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å|–ø—Ä–æ–¥–æ–ª–∂–∏|–¥–∞–ª–µ–µ)$/i.test(r)) return true;
      if (/^["'\s]+$/.test(r) && r.length <= 4) return true;
      const norm = this._normU(r);
      return norm === "";
    },

    // ---------- Input type & turn ----------
    /**
     * Detects the type of user input (new, continue, or retry) and updates state accordingly.
     * @param {string} raw - The raw input text
     * @returns {string} The detected input type ('new', 'continue', or 'retry')
     */
    detectInputType(raw){
      const L = this.lcInit();
      const currentNorm = this._normU(raw);
      const lastNorm = this._normU(L.lastInput || "");

      let inputType = "new";
      const isContinue = this._isSoftContinue(raw);
      const isRetry = !isContinue && currentNorm.length > 0 && currentNorm === lastNorm;

      if (isContinue){
        inputType = "continue";
        L.continueCount++; L.consecutiveRetries = 0;
        L.currentAction = { type: 'continue' };
      } else if (isRetry){
        inputType = "retry";
        L.consecutiveRetries++; L.continueCount = 0;
        L.currentAction = { type: 'retry' };
        L.tm.retries = (L.tm.retries || 0) + 1;
      } else {
        inputType = "new";
        L.consecutiveRetries = 0; L.continueCount = 0;
        L.currentAction = { type: 'story' };
        L.lastInput = toStr(raw);
      }
      L.lastActionType = inputType;
      return inputType;
    },

    assertTurnInvariants(L, ctx){
      try{
        const isCmd = L.currentAction?.type === 'command';
        const isRetry = L.currentAction?.type === 'retry';
        const should = LC.shouldIncrementTurn?.() === true;
        if (isCmd && should)  LC.lcWarn?.("[TURN] would increment on command @"+ctx);
        if (isRetry && should)LC.lcWarn?.("[TURN] would increment on retry @"+ctx);
      }catch(_){ }
    },

    /**
     * Determines if the current action should increment the turn counter.
     * Returns false for commands and retries, true for new story inputs and continue actions.
     * @returns {boolean} True if the turn counter should be incremented, false otherwise
     */
    shouldIncrementTurn(){
      const L = this.lcInit();
      const isRetry = L.currentAction?.type === 'retry';
      const isCmd   = L.currentAction?.type === 'command';
      // —Ç–µ–ø–µ—Ä—å: Continue = —Ä–µ–∞–ª—å–Ω—ã–π —Ö–æ–¥; +1 —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–µ –∫–æ–º–∞–Ω–¥–∞ –∏ –Ω–µ retry
      return !isCmd && !isRetry;
    },
    /**
     * Increments the turn counter and updates the last processed turn.
     * Should only be called when shouldIncrementTurn() returns true.
     * @returns {void}
     */
    incrementTurn(){
      const L = this.lcInit();
      L.turn = (L.turn || 0) + 1;
      L.lastProcessedTurn = L.turn;
      this.lcDebug(`Turn ‚Üí ${L.turn}`);
      
      // Run mythologization every 100 turns
      if (L.turn % 100 === 0 && LC.MemoryEngine && typeof LC.MemoryEngine.runMythologization === 'function') {
        LC.MemoryEngine.runMythologization();
      }
    },

    // ---------- Opening ----------
    captureOpeningFromHistory(){
      const L = this.lcInit();
      if (L.openingCaptured) return;
      const st = getState();
      let opening = "";
      if (st.memory && st.memory.frontMemory) opening = toStr(st.memory.frontMemory).trim();
      else if (typeof history !== "undefined" && Array.isArray(history) && history.length > 0) {
        const first = history[0];
        opening = toStr(first && (first.text || first.message || first.value)).trim();
      } else if (st.$$INITIAL_PROMPT) opening = toStr(st.$$INITIAL_PROMPT).trim();
      else if (st.memory && st.memory.authorsNote) opening = toStr(st.memory.authorsNote).trim();
      if (opening && opening.length > 20) {
        L.opening = opening.split(/\r?\n/)[0].slice(0, 200);
        L.openingCaptured = true; L.openingTurn = 0;
        this.lcSys(`üìñ Opening: "${L.opening.slice(0, 50)}..."`);
      }
    },
    captureOpeningFromOutput(out){
      const L = this.lcInit();
      if (L.openingCaptured) return;
      const s = toStr(out);
      if (s.length > 20) {
        L.opening = s.split(/\r?\n/)[0].slice(0, 200);
        L.openingCaptured = true; L.openingTurn = L.turn;
        this.lcSys("üìñ Opening captured from output.");
      }
    },
    getOpeningLine(){
      const L = this.lcInit();
      const age = L.turn - L.openingTurn;
      if (!L.opening || age > L.openingTTL) return "";
      return `‚ü¶OPENING‚üß ${L.opening}`;
    },

    // ---------- Story Cards (API + fallback) ----------
    capExtendedStore(max){
      const st = getState();
      const ext = st.$$WORLD_INFO_EXTENDED;
      const M = max || this.CONFIG.LIMITS.EXTENDED_STORE_CAP;
      if (Array.isArray(ext) && ext.length > M) {
        st.$$WORLD_INFO_EXTENDED = ext.slice(-M);
        this.lcWarn(`WORLD_INFO_EXTENDED trimmed to ${M}`);
      }
    },

    createStoryCard(entry, windowTurns, kind){
      const L = this.lcInit();
      const text = toStr(entry || "").trim();
      if (!text) return null;

      const id  = `wi_${Date.now()}_${Math.floor(Math.random()*1e6)}`;
      const win = Array.isArray(windowTurns) ? windowTurns : [Math.max(0, L.turn - L.cadence), L.turn];
      const keys = ['recap', 'lincoln heights', `id:${id}`, `turns_${win[0]}-${win[1]}`].join(', ');

      let ok = false;
      try {
        if (typeof addStoryCard === "function") {
          const r = addStoryCard(keys, text, kind || "note");
          ok = (r !== false);
        }
      } catch (e){ this.lcWarn("addStoryCard failed: " + (e && e.message)); }

      L.worldInfoIds.push(id);

      if (!ok) {
        const st = getState();
        st.$$WORLD_INFO_EXTENDED = Array.isArray(st.$$WORLD_INFO_EXTENDED) ? st.$$WORLD_INFO_EXTENDED : [];
        st.$$WORLD_INFO_EXTENDED.push({
          __lincoln: true,
          worldInfoId: id,
          keys, entry: text,
          kind: (kind || "note"),
          createdTurnStart: win[0],
          createdTurnEnd: win[1],
          priority: 50,
          ts: Date.now()
        });
        this.capExtendedStore(this.CONFIG.LIMITS.EXTENDED_STORE_CAP);
        this.lcWarn("Cards API unavailable or returned false. Saved to $$WORLD_INFO_EXTENDED.");
      }

      this.cleanupOldCards();
      return id;
    },
    _findStoryCardIndexById(id){
      try {
        if (typeof storyCards !== "undefined" && Array.isArray(storyCards)) {
          for (let i=0;i<storyCards.length;i++){
            const c = storyCards[i];
            const k = (c && c.keys) ? String(c.keys) : "";
            if (k.indexOf(`id:${id}`) !== -1) return i;
          }
        }
      } catch(e){}
      return -1;
    },
    removeStoryCardById(id){
      let removed = false;
      try {
        const idx = this._findStoryCardIndexById(id);
        if (idx >= 0 && typeof removeStoryCard === "function") {
          removeStoryCard(idx);
          removed = true;
        }
      } catch(e){}
      // registry
      const L = this.lcInit();
      // also unpin if pinned
      try {
        if (Array.isArray(L.pinnedWorldInfoIds)) {
          const pi = L.pinnedWorldInfoIds.indexOf(String(id));
          if (pi !== -1) L.pinnedWorldInfoIds.splice(pi, 1);
        }
      } catch(_){}

      const p = L.worldInfoIds.indexOf(id);
      if (p !== -1) L.worldInfoIds.splice(p,1);

      // fallback purge + cap
      const st = getState();
      const ext = st.$$WORLD_INFO_EXTENDED;
      if (Array.isArray(ext)) {
        for (let i = ext.length - 1; i >= 0; i--) {
          if (ext[i] && ext[i].worldInfoId === id) ext.splice(i, 1);
        }
        this.capExtendedStore(this.CONFIG.LIMITS.EXTENDED_STORE_CAP);
      }
      return removed;
    },
    cleanupOldCards(){
      const L = this.lcInit();
      const pinned = {};
      for (let i=0;i<L.pinnedWorldInfoIds.length;i++) pinned[L.pinnedWorldInfoIds[i]] = true;

      let guard = 0, target = CONFIG.LIMITS.CARDS_MAX;
      while (L.worldInfoIds.length > target && guard < L.worldInfoIds.length + 5) {
        const oldId = L.worldInfoIds.shift(); guard++;
        if (pinned[oldId]) { L.worldInfoIds.push(oldId); continue; }
        this.removeStoryCardById(oldId);
      }
      if (L.worldInfoIds.length > target) {
        this.lcWarn(`Cards limit exceeded (${L.worldInfoIds.length}/${target}) due to pinned items.`);
      }
    },

    // ---------- Aliases (user + built-in) ----------
    getAliasMap(){
      const L = this.lcInit();
      // built-in
      const base = {
        "–º–∞–∫—Å–∏–º": ["–º–∞–∫—Å–∏–º","–º–∞–∫—Å","maxim","max","bergman","–±–µ—Ä–≥–º–∞–Ω"],
        "—Ö–ª–æ—è": ["—Ö–ª–æ—è","—Ö–ª–æ–∏","—Ö–ª–æ–µ","chloe","—Ö–∞—Ä–ø–µ—Ä","harper"],
        "—ç—à–ª–∏": ["—ç—à–ª–∏","ashley","ash","—ç—à"],
        "–º–∏—Å—Å–∏—Å –≥—Ä–µ–π—Å–æ–Ω": ["–º–∏—Å—Å–∏—Å –≥—Ä–µ–π—Å–æ–Ω","–≥—Ä–µ–π—Å–æ–Ω","grayson","—É—á–∏—Ç–µ–ª—å–Ω–∏—Ü–∞","—É—á–∏—Ç–µ–ª—å–Ω–∏—Ü—É","—É—á–∏—Ç–µ–ª—å–Ω–∏—Ü–µ","—É—á–∏—Ç–µ–ª—å–Ω–∏—Ü–µ–π","teacher"],
        "–¥–∏—Ä–µ–∫—Ç–æ—Ä –∫–æ–≤–∞–ª—å—Å–∫–∏": ["–¥–∏—Ä–µ–∫—Ç–æ—Ä –∫–æ–≤–∞–ª—å—Å–∫–∏","–∫–æ–≤–∞–ª—å—Å–∫–∏","kovalski","–∞–ª–µ–∫—Å–∞–Ω–¥—Ä","alexander","–¥–∏—Ä–µ–∫—Ç–æ—Ä–∞","–¥–∏—Ä–µ–∫—Ç–æ—Ä—É","–¥–∏—Ä–µ–∫—Ç–æ—Ä–æ–º","–¥–∏—Ä–µ–∫—Ç–æ—Ä–µ"]
      };
      // user-defined: { "–•–ª–æ—è": ["Chloe","Harper"] }
      const user = {};
      for (const k in (L.aliases||{})) {
        const canon = String(k || "").trim();
        if (!canon) continue;
        const list = Array.isArray(L.aliases[k]) ? L.aliases[k] : [];
        user[canon.toLowerCase()] = list.map(s => String(s||"").trim().toLowerCase()).filter(Boolean);
      }
      // merge: –ø—Ä–∏ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–∏ –∫–∞–Ω–æ–Ω–∞ ‚Äî –æ–±—ä–µ–¥–∏–Ω—è–µ–º —Å–ø–∏—Å–∫–∏
      const merged = {};
      function add(canon, arr){
        const c = canon.toLowerCase();
        merged[c] = merged[c] || [];
        for (let i=0;i<arr.length;i++){
          const v = arr[i].toLowerCase();
          if (merged[c].indexOf(v) === -1) merged[c].push(v);
        }
      }
      for (const b in base) add(b, base[b]);
      for (const u in user) add(u, user[u]);
      return merged; // { "–º–∞–∫—Å–∏–º": ["–º–∞–∫—Å–∏–º","–º–∞–∫—Å",...] , ... }
    },

    // ---------- Characters ----------
    updateCharacterActivity(text, isRetry){
      if (!text || isRetry) return;
      const L = this.lcInit();
      const low = toStr(text).toLowerCase();
      const t = L.turn || 0;

      const aliasesMap = this.getAliasMap();
      function reEscape(s){ return String(s).replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }
      function wordHit(hay, needle){
        try {
          const rx = new RegExp(`(?:^|[^\\p{L}\\p{N}])${reEscape(needle)}(?:[^\\p{L}\\p{N}]|$)`, "iu");
          return rx.test(hay);
        } catch(e) {
          const rx2 = new RegExp(`(?:^|[^A-Za-z0-9_])${reEscape(needle)}(?:[^A-Za-z0-9_]|$)`, "i");
          return rx2.test(hay);
        }
      }

      const names = Object.keys(aliasesMap);
      for (let i=0;i<names.length;i++){
        const canon = names[i];
        const list = aliasesMap[canon] || [];
        let hit = false;
        for (let j=0;j<list.length;j++){ if (wordHit(low, list[j])) { hit = true; break; } }
        if (hit){
          let key; try { key = canon.replace(/^\p{Ll}/u, m=>m.toUpperCase()); } catch(e) { key = canon.charAt(0).toUpperCase() + canon.slice(1);} // –ª–µ–≥–∫–∏–π –∫–∞–ø –ø–µ—Ä–≤–æ–π –±—É–∫–≤—ã
          const rec = L.characters[key] || { mentions:0, lastSeen:-1, firstSeen:t, type:'EXTRA', status:'ACTIVE' };
          // Unfreeze character if they were frozen
          if (rec.status === 'FROZEN') {
            rec.status = 'ACTIVE';
            L.stateVersion++;
          }
          // Initialize personality core if not present
          if (!rec.personality) {
            // Base personality values
            let baseTrust = 0.5;
            let baseBravery = 0.5;
            let baseIdealism = 0.5;
            let baseAggression = 0.3;
            
            // Calibrate personality based on existing myths
            if (LC.MemoryEngine && typeof LC.MemoryEngine.getMythStrengthForTheme === 'function') {
              const loyaltyMyth = LC.MemoryEngine.getMythStrengthForTheme('loyalty_rescue');
              const betrayalMyth = LC.MemoryEngine.getMythStrengthForTheme('betrayal');
              
              // Strong loyalty myths increase trust
              if (loyaltyMyth > 0.5) {
                baseTrust = Math.min(1, baseTrust + loyaltyMyth * 0.2);
              }
              
              // Strong betrayal myths decrease trust
              if (betrayalMyth > 0.5) {
                baseTrust = Math.max(0, baseTrust - betrayalMyth * 0.15);
              }
            }
            
            rec.personality = {
              trust: baseTrust,       // –î–æ–≤–µ—Ä—á–∏–≤–æ—Å—Ç—å
              bravery: baseBravery,   // –°–º–µ–ª–æ—Å—Ç—å
              idealism: baseIdealism, // –ò–¥–µ–∞–ª–∏–∑–º
              aggression: baseAggression   // –ê–≥—Ä–µ—Å—Å–∏–≤–Ω–æ—Å—Ç—å
            };
          }
          // Initialize self-concept (perceived traits) if not present
          if (!rec.self_concept) {
            // Self-concept starts matching objective personality
            rec.self_concept = {
              perceived_trust: rec.personality.trust,
              perceived_bravery: rec.personality.bravery,
              perceived_idealism: rec.personality.idealism,
              perceived_aggression: rec.personality.aggression
            };
          }
          // Initialize social standing if not present
          if (!rec.social) {
            rec.social = {
              status: 'member',    // 'leader', 'member', 'outcast'
              capital: 100,        // Social capital (points)
              conformity: 0.5      // Conformity to norms [0, 1]
            };
          }
          // Initialize qualia state (phenomenal core) if not present
          if (!rec.qualia_state) {
            rec.qualia_state = {
              somatic_tension: 0.3,  // –ú—ã—à–µ—á–Ω–æ–µ/–Ω–µ—Ä–≤–Ω–æ–µ –Ω–∞–ø—Ä—è–∂–µ–Ω–∏–µ [0-1]
              valence: 0.5,          // –ë–∞–∑–æ–≤—ã–π –∞—Ñ—Ñ–µ–∫—Ç (0-–Ω–µ–ø—Ä–∏—è—Ç–Ω–æ, 1-–ø—Ä–∏—è—Ç–Ω–æ)
              focus_aperture: 0.7,   // –®–∏—Ä–æ—Ç–∞ —Ñ–æ–∫—É—Å–∞ (0-—Ç—É–Ω–Ω–µ–ª—å–Ω–æ–µ –∑—Ä–µ–Ω–∏–µ, 1-—Ä–∞—Å—Å–µ—è–Ω–Ω–æ—Å—Ç—å)
              energy_level: 0.8      // –£—Ä–æ–≤–µ–Ω—å —ç–Ω–µ—Ä–≥–∏–∏/–±–æ–¥—Ä–æ—Å—Ç–∏ [0-1]
            };
          }
          // Initialize perceptions (subjective view of other characters)
          if (!rec.perceptions) {
            rec.perceptions = {};  // Individual, asymmetric perceptions of others
          }
          rec.lastSeen = t; rec.mentions++;
          L.characters[key] = rec;
        }
      }
    },
    getActiveCharacters(max){
      const L = this.lcInit();
      const t = L.turn || 0;
      const arr = [];
      for (const name in (L.characters || {})) {
        const d = L.characters[name];
        // Skip FROZEN characters
        if (d.status === 'FROZEN') continue;
        const turnsAgo = t - d.lastSeen;
        if (turnsAgo < 50) {
          arr.push({
            name, lastSeen: d.lastSeen, mentions: d.mentions,
            turnsAgo, importance: d.mentions + Math.max(0, 20 - turnsAgo)
          });
        }
      }
      arr.sort((a,b)=> b.importance - a.importance);
      return arr.slice(0, max || 10);
    },

    // ---------- Anti-Echo ----------
    _echoCache: {},
    _echoOrder: [],

    antiEchoCheck(current, previous, actionType){
      const L = this.lcInit();
      if (!L.antiEchoEnabled) return { isEcho:false, sim:0 };
      if (!current || !previous) return { isEcho:false, sim:0 };
      if (actionType === "retry") return { isEcho:false, sim:0 };

      const minLen = CONFIG.LIMITS.ANTI_ECHO.MIN_LENGTH;
      if (String(current).length < minLen || String(previous).length < minLen) {
        return { isEcho:false, sim:0 };
      }

      const tailN = CONFIG.LIMITS.ANTI_ECHO.CHECK_TAIL_LENGTH;
      const a = this._normU(String(current).slice(-tailN));
      const b = this._normU(String(previous).slice(-tailN));
      if (a.length < 50 || b.length < 50) return { isEcho:false, sim:0 };

      const cacheKey = (FNV1A(a + "|" + b + "|" + (actionType||"")).toString(36));
      if (this._echoCache[cacheKey] !== undefined) {
        if (L.debugMode) this.lcSys(`antiEcho: cache hit (${cacheKey})`);
        const p = this._echoOrder.indexOf(cacheKey);
        if (p !== -1) { this._echoOrder.splice(p, 1); this._echoOrder.push(cacheKey); }
        L.tm.echoCacheHits = (L.tm.echoCacheHits || 0) + 1;
        return this._echoCache[cacheKey];
      }

      const base = (L.antiEchoSensitivity || 85) / 100;
      let thr = base;
      if (actionType === "continue") {
        const mult = (L.antiEchoMode === "hard")
          ? CONFIG.LIMITS.ANTI_ECHO.CONTINUE_THRESHOLD_MULT.HARD
          : CONFIG.LIMITS.ANTI_ECHO.CONTINUE_THRESHOLD_MULT.SOFT;
        thr = Math.min(0.99, base * mult);
      }

      const setA = {}; let aCount = 0;
      const wa = a.split(" ");
      for (let i=0;i<wa.length;i++){ const w=wa[i]; if (!setA[w]){ setA[w]=1; aCount++; } }
      const setB = {}; let bCount = 0;
      const wb = b.split(" ");
      for (let i=0;i<wb.length;i++){ const w=wb[i]; if (!setB[w]){ setB[w]=1; bCount++; } }

      let inter = 0;
      for (const w in setA) if (setB[w]) inter++;
      const union = aCount + bCount - inter;
      const sim = union > 0 ? (inter/union) : 0;

      const res = { isEcho: sim >= thr, sim };
      this._echoCache[cacheKey] = res;
      this._echoOrder.push(cacheKey);

      const MAX = this.CONFIG?.LIMITS?.ANTI_ECHO?.CACHE_MAX ?? 256;
      const softCap = Math.floor(MAX * 0.8);
      if (this._echoOrder.length > softCap) {
        const pruneCount = Math.max(1, Math.floor(this._echoOrder.length * 0.3));
        const removedKeys = this._echoOrder.splice(0, pruneCount);
        for (let i = 0; i < removedKeys.length; i++) {
          const oldKey = removedKeys[i];
          if (oldKey && this._echoCache[oldKey] !== undefined) {
            delete this._echoCache[oldKey];
          }
        }
        if (L.debugMode) {
          this.lcDebug(`antiEcho: soft prune (-${removedKeys.length}, size=${this._echoOrder.length})`);
        }
      }

      const max = MAX;
      if (this._echoOrder.length > max) {
        const toRemove = Math.floor(max / 2);
        for (let i=0;i<toRemove;i++){
          const oldKey = this._echoOrder.shift();
          if (oldKey && this._echoCache[oldKey] !== undefined) delete this._echoCache[oldKey];
        }
        if (L.debugMode) this.lcDebug(`antiEcho: cache pruned (-${toRemove}, size=${this._echoOrder.length})`);
      }

      if (L.debugMode) this.lcDebug(`antiEcho: sim=${sim.toFixed(3)} thr=${thr.toFixed(2)} act=${actionType||"new"} mode=${L.antiEchoMode}`);
      return res;
    },
    /**
     * Applies anti-echo trimming to prevent AI from repeating previous output.
     * Uses configurable trim ratios and looks for sentence boundaries.
     * @param {string} currentOutput - The current output text
     * @param {string} previousOutput - The previous output text
     * @param {string} actionType - The action type ('continue', 'story', etc.)
     * @returns {string} The trimmed output or original if no echo detected
     */
    applyAntiEcho(currentOutput, previousOutput, actionType){
      if (actionType === "retry") return currentOutput;
      const { isEcho } = this.antiEchoCheck(currentOutput, previousOutput, actionType);
      if (!isEcho) return currentOutput;

      // Use different trim ratios for continue vs normal actions
      const ratio = (actionType === "continue")
        ? CONFIG.LIMITS.ANTI_ECHO.CONTINUE_TRIM   // 60% for continue
        : CONFIG.LIMITS.ANTI_ECHO.TRIM_PERCENTAGE; // 75% for normal

      let cut = Math.floor(currentOutput.length * ratio);
      
      // Look for a sentence boundary near the cut point (¬±100 chars window)
      const search = 100;
      const winS = Math.max(0, cut - search);
      const window = currentOutput.slice(winS, cut + search);
      const ends = window.match(/[.!?‚Ä¶]\s|‚Äî\s/g);  // Find sentence endings
      if (ends && ends.length > 0){
        const last = ends[ends.length-1];
        const lastIdx = window.lastIndexOf(last);
        if (lastIdx !== -1) cut = winS + lastIdx + last.length;
      }
      const trimmed = currentOutput.slice(0, cut).trim();
      
      // Safety check: don't trim if result is too short
      if (trimmed.length < 80) return currentOutput;

      const L = this.lcInit();
      L.tm.echoHits = (L.tm.echoHits || 0) + 1;
      this.lcSys("üîÑ Echo detected and trimmed.");
      return trimmed;
    },
    /**
     * Returns statistics about the anti-echo cache.
     * @returns {{cacheEntries: number, lruSize: number, hits: number}} Cache statistics
     */
    antiEchoStats(){
      const L = this.lcInit();
      return {
        cacheEntries: Object.keys(this._echoCache).length,
        lruSize: this._echoOrder.length,
        hits: toNum(L.tm.echoCacheHits, 0)
      };
    },
    antiEchoFlush(){
      this._echoCache = {};
      this._echoOrder = [];
      this.lcSys("üßπ Anti-echo cache flushed.");
    },

    // ---------- Evergreen (patterns + fallback) ----------
    EvergreenEngine: {
      /**
       * Builds regex patterns for detecting relations, status changes, obligations, and facts.
       * Uses Unicode-aware patterns with fallback to ASCII-only patterns if needed.
       * @returns {object} Object containing pattern arrays for relations, status, obligations, facts, goals
       */
      _buildPatterns(){
        const P = { relations:[], status:[], obligations:[], facts:[], goals:[] };
        const tryPush = (arr, src, flags, meta) => {
          try {
            const re = new RegExp(src, flags);
            if (meta && typeof meta === "object") {
              Object.assign(re, meta);
            }
            arr.push(re);
            return true;
          } catch(e){
            return false;
          }
        };

        const okR1 = tryPush(P.relations, "([\\p{L}'-]+(?:\\s+[\\p{L}'-]+){0,2})\\s+–∏\\s+([\\p{L}'-]+(?:\\s+[\\p{L}'-]+){0,2})\\s+—Ç–µ–ø–µ—Ä—å\\s+(–≤–º–µ—Å—Ç–µ|–ø–∞—Ä–∞|—Ä–∞—Å—Å—Ç–∞–ª–∏—Å—å|–¥—Ä—É–∑—å—è|–≤—Ä–∞–≥–∏)", "giu", { _relPattern: "pairRu" });
        const okR2 = tryPush(P.relations, "([\\p{L}'-]+)\\s+(–ª—é–±–∏—Ç|–Ω–µ–Ω–∞–≤–∏–¥–∏—Ç|—Ä–µ–≤–Ω—É–µ—Ç|–ø–æ—Ü–µ–ª–æ–≤–∞–ª(?:–∞)?|–æ–±–Ω—è–ª(?:–∞)?|—É–¥–∞—Ä–∏–ª(?:–∞)?|–ø—Ä–µ–¥–∞–ª(?:–∞)?|–ø—Ä–æ—Å—Ç–∏–ª(?:–∞)?|–±—Ä–æ—Å–∏–ª(?:–∞)?)\\s+([\\p{L}'-]+(?:\\s+[\\p{L}'-]+){0,2})", "giu", { _relPattern: "verbRu" });

        const okS1 = tryPush(P.status, "([\\p{L}'-]+(?:\\s+[\\p{L}'-]+){0,2})\\s+—Ç–µ–ø–µ—Ä—å\\s+(.+?)(?:[.,!]|$)", "giu");
        const okS2 = tryPush(P.status, "([\\p{L}'-]+(?:\\s+[\\p{L}'-]+){0,2})\\s+—Å—Ç–∞–ª(?:–∞)?\\s+(.+?)(?:[.,!]|$)", "giu");
        const okS3 = tryPush(P.status, "([\\p{L}'-]+(?:\\s+[\\p{L}'-]+){0,2})\\s+–ø–æ–ª—É—á–∏–ª(?:–∞)?\\s+(.+?)(?:[.,!]|$)", "giu");

        const ruRecipient = "(?:[\\p{L}'-]+(?:\\s+[\\p{L}'-]+){0,2}|–µ–º—É|–µ–π|–∏–º|–Ω–∞–º|—Ç–µ–±–µ|–º–Ω–µ|–≤–∞–º|–µ–≥–æ|–µ–µ|–Ω–∏—Ö|–Ω–∞—Å|–≤–∞—Å)";
        const enRecipient = "(?:(?:(?!(?:to|that)\\b)[\\p{L}'-]+(?:\\s+(?!(?:to|that)\\b)[\\p{L}'-]+){0,2})|him|her|them|you|us|me)";

        const okO1Src = `([\\p{L}'-]+(?:\\s+[\\p{L}'-]+){0,2})\\s+–¥–æ–ª–∂–Ω?(?:–µ–Ω|–∞|—ã|–æ)\\s+(?:(?:(${ruRecipient})\\s+)?(.+?))(?:[.,!]|$)`;
        const okO1 = tryPush(P.obligations, okO1Src, "giu");
        const okO2Src = `([\\p{L}'-]+(?:\\s+[\\p{L}'-]+){0,2})\\s+–æ–±–µ—â–∞–ª(?:–∞)?\\s+(?:(?:(${ruRecipient})\\s+)?(.+?))(?:[.,!]|$)`;
        const okO2 = tryPush(P.obligations, okO2Src, "giu");

        const okF1 = tryPush(P.facts, "–≤–∞–∂–Ω–æ:\\s*([^.!\\n]+)", "giu");
        const okF2 = tryPush(P.facts, "–∑–∞–ø–æ–º–Ω–∏:\\s*([^.!\\n]+)", "giu");
        const okF3 = tryPush(P.facts, "—Ñ–∞–∫—Ç:\\s*([^.!\\n]+)", "giu");

        // EVG: colon-friendly fact cues (ru only), ':' optional to survive _normU
        // –ü–æ–º–µ—á–∞–µ–º –∫–æ—Ä–æ—Ç–∫–∏–µ —è–≤–Ω—ã–µ –ø–æ–¥—Å–∫–∞–∑–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–∞ ¬´—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ñ–∞–∫—Ç–∞¬ª
        P.factsCues = P.factsCues || [];
        tryPush(P.factsCues, "(?:–≤–∞–∂–Ω–æ|–∑–∞–ø–æ–º–Ω–∏|—Ñ–∞–∫—Ç|–∏—Ç–æ–≥|–≤—ã–≤–æ–¥)\\s*[:\\-]?\\s*(.{8,280})", "giu");

        const needFallback = !(okR1 && okR2 && okS1 && okS2 && okS3 && okO1 && okO2 && okF1 && okF2 && okF3);
        if (needFallback) {
          const LTR = "A-Za-z–ê-–Ø–∞-—è–Å—ë";
          const ruRecipientFallback = `(?:[${LTR}'-]+(?:\\s+[${LTR}'-]+){0,2}|–µ–º—É|–µ–π|–∏–º|–Ω–∞–º|—Ç–µ–±–µ|–º–Ω–µ|–≤–∞–º|–µ–≥–æ|–µ–µ|–Ω–∏—Ö|–Ω–∞—Å|–≤–∞—Å)`;
          const fbR1 = new RegExp(`([${LTR}'-]+(?:\\s+[${LTR}'-]+){0,2})\\s+–∏\\s+([${LTR}'-]+(?:\\s+[${LTR}'-]+){0,2})\\s+—Ç–µ–ø–µ—Ä—å\\s+(–≤–º–µ—Å—Ç–µ|–ø–∞—Ä–∞|—Ä–∞—Å—Å—Ç–∞–ª–∏—Å—å|–¥—Ä—É–∑—å—è|–≤—Ä–∞–≥–∏)`, "gi");
          fbR1._relPattern = "pairRu";
          P.relations.push(fbR1);
          const fbR2 = new RegExp(`([${LTR}'-]+)\\s+(–ª—é–±–∏—Ç|–Ω–µ–Ω–∞–≤–∏–¥–∏—Ç|—Ä–µ–≤–Ω—É–µ—Ç|–ø–æ—Ü–µ–ª–æ–≤–∞–ª(?:–∞)?|–æ–±–Ω—è–ª(?:–∞)?|—É–¥–∞—Ä–∏–ª(?:–∞)?|–ø—Ä–µ–¥–∞–ª(?:–∞)?|–ø—Ä–æ—Å—Ç–∏–ª(?:–∞)?|–±—Ä–æ—Å–∏–ª(?:–∞)?)\\s+([${LTR}'-]+(?:\\s+[${LTR}'-]+){0,2})`, "gi");
          fbR2._relPattern = "verbRu";
          P.relations.push(fbR2);

          P.status.push(new RegExp(`([${LTR}'-]+(?:\\s+[${LTR}'-]+){0,2})\\s+—Ç–µ–ø–µ—Ä—å\\s+(.+?)(?:[.,!]|$)`, "gi"));
          P.status.push(new RegExp(`([${LTR}'-]+(?:\\s+[${LTR}'-]+){0,2})\\s+—Å—Ç–∞–ª(?:–∞)?\\s+(.+?)(?:[.,!]|$)`, "gi"));
          P.status.push(new RegExp(`([${LTR}'-]+(?:\\s+[${LTR}'-]+){0,2})\\s+–ø–æ–ª—É—á–∏–ª(?:–∞)?\\s+(.+?)(?:[.,!]|$)`, "gi"));

          P.obligations.push(new RegExp(`([${LTR}'-]+(?:\\s+[${LTR}'-]+){0,2})\\s+–¥–æ–ª–∂–Ω?(?:–µ–Ω|–∞|—ã|–æ)\\s+(?:(?:(${ruRecipientFallback})\\s+)?(.+?))(?:[.,!]|$)`, "gi"));
          P.obligations.push(new RegExp(`([${LTR}'-]+(?:\\s+[${LTR}'-]+){0,2})\\s+–æ–±–µ—â–∞–ª(?:–∞)?\\s+(?:(?:(${ruRecipientFallback})\\s+)?(.+?))(?:[.,!]|$)`, "gi"));

          P.facts.push(/–≤–∞–∂–Ω–æ:\s*([^.!\n]+)/ig);
          P.facts.push(/–∑–∞–ø–æ–º–Ω–∏:\s*([^.!\n]+)/ig);
          P.facts.push(/—Ñ–∞–∫—Ç:\s*([^.!\n]+)/ig);
          P.factsCues = P.factsCues || [];
          P.factsCues.push(/(?:–≤–∞–∂–Ω–æ|–∑–∞–ø–æ–º–Ω–∏|—Ñ–∞–∫—Ç|–∏—Ç–æ–≥|–≤—ã–≤–æ–¥)\s*[:\-]?\s*(.{8,280})/ig);
        }
        
        // GOALS - Russian patterns only
        P.goals = P.goals || [];
        tryPush(P.goals, "(?:—Ü–µ–ª—å|–∑–∞–¥–∞—á–∞)\\s+([\\p{L}'-]+(?:\\s+[\\p{L}'-]+){0,2})\\s*[:\\-]?\\s*(.{8,200})", "giu");
        tryPush(P.goals, "([\\p{L}'-]+(?:\\s+[\\p{L}'-]+){0,2})\\s+(?:—Ö–æ—á–µ—Ç|–Ω–∞–º–µ—Ä–µ–Ω(?:–∞)?|–ø–ª–∞–Ω–∏—Ä—É–µ—Ç|—Å—Ç—Ä–µ–º–∏—Ç—Å—è|—Ä–µ—à–∏–ª(?:–∞)?|–º–µ—á—Ç–∞–µ—Ç)\\s+(.{8,200})", "giu");
        tryPush(P.goals, "([\\p{L}'-]+(?:\\s+[\\p{L}'-]+){0,2})\\s+(?:–µ–≥–æ|–µ—ë|–µ–µ|–∏—Ö)\\s+(?:—Ü–µ–ª—å|–∑–∞–¥–∞—á–∞|–ø–ª–∞–Ω|–º–µ—á—Ç–∞)\\s*[:\\-]?\\s*(.{8,200})", "giu");
        
        // Social goals
        tryPush(P.goals, "([\\p{L}'-]+(?:\\s+[\\p{L}'-]+){0,2})\\s+(?:—Ö–æ—Ç–µ–ª(?:–∞)?\\s+–ø–æ–¥—Ä—É–∂–∏—Ç—å—Å—è\\s+—Å|—Ä–µ—à–∏–ª(?:–∞)?\\s+–Ω–∞–ª–∞–¥–∏—Ç—å\\s+–æ—Ç–Ω–æ—à–µ–Ω–∏—è\\s*(?:—Å|)?)\\s+(.{3,200})", "giu");
        tryPush(P.goals, "([\\p{L}'-]+(?:\\s+[\\p{L}'-]+){0,2})\\s+(?:—Ö–æ—Ç–µ–ª(?:–∞)?\\s+–ø—Ä–æ–∏–∑–≤–µ—Å—Ç–∏\\s+(?:–Ω–∞\\s+(?:–Ω–µ–µ|–Ω–µ–≥–æ)\\s+)?–≤–ø–µ—á–∞—Ç–ª–µ–Ω–∏–µ|–ø—ã—Ç–∞–ª(?:—Å—è|–∞—Å—å)\\s+–≤–ø–µ—á–∞—Ç–ª–∏—Ç—å)\\s*(.{3,200})", "giu");
        tryPush(P.goals, "([\\p{L}'-]+(?:\\s+[\\p{L}'-]+){0,2})\\s+(?:—Ä–µ—à–∏–ª(?:–∞)?\\s+–æ—Ç–æ–º—Å—Ç–∏—Ç—å|–ø–æ–∫–ª—è–ª(?:—Å—è|–∞—Å—å)\\s+–æ—Ç–æ–º—Å—Ç–∏—Ç—å)\\s*(?:–∑–∞)?\\s*(.{3,200})", "giu");
        
        // Academic/Career goals
        tryPush(P.goals, "([\\p{L}'-]+(?:\\s+[\\p{L}'-]+){0,2})\\s+(?:—Ä–µ—à–∏–ª(?:–∞)?\\s+–∏—Å–ø—Ä–∞–≤–∏—Ç—å\\s+–æ—Ü–µ–Ω–∫–∏|—Ö–æ—Ç–µ–ª(?:–∞)?\\s+–ø–æ–ª—É—á–∏—Ç—å\\s+–æ—Ç–ª–∏—á–Ω–æ)\\s*(.{3,200})", "giu");
        tryPush(P.goals, "([\\p{L}'-]+(?:\\s+[\\p{L}'-]+){0,2})\\s+(?:–µ–≥–æ|–µ—ë|–µ–µ)\\s+—Ü–µ–ª—å—é\\s+–±—ã–ª–∞\\s+–ø–æ–±–µ–¥–∞\\s+–≤\\s+(.{3,200})", "giu");
        tryPush(P.goals, "([\\p{L}'-]+(?:\\s+[\\p{L}'-]+){0,2})\\s+—Ö–æ—Ç–µ–ª(?:–∞)?\\s+–≤—ã–∏–≥—Ä–∞—Ç—å\\s+(.{3,200})", "giu");
        
        // Investigation goals
        tryPush(P.goals, "([\\p{L}'-]+(?:\\s+[\\p{L}'-]+){0,2})\\s+(?:–¥–æ–ª–∂–µ–Ω|–¥–æ–ª–∂–Ω–∞)\\s+–≤—ã—è—Å–Ω–∏—Ç—å,?\\s+(?:—á—Ç–æ\\s+)?(.{3,200})", "giu");
        tryPush(P.goals, "([\\p{L}'-]+(?:\\s+[\\p{L}'-]+){0,2})\\s+(?:—Ö–æ—Ç–µ–ª(?:–∞)?\\s+–¥–æ–∫–æ–ø–∞—Ç—å—Å—è\\s+–¥–æ\\s+–∏—Å—Ç–∏–Ω—ã|—Ä–µ—à–∏–ª(?:–∞)?\\s+—Ä–∞–∑—É–∑–Ω–∞—Ç—å\\s+–ø–æ–±–æ–ª—å—à–µ)\\s*(?:–æ)?\\s*(.{3,200})", "giu");
        
        // Fallback goal patterns for older regex engines
        if (P.goals.length === 0) {
          const LTR = "A-Za-z–ê-–Ø–∞-—è–Å—ë";
          P.goals.push(new RegExp(`(?:—Ü–µ–ª—å|–∑–∞–¥–∞—á–∞)\\s+([${LTR}'-]+(?:\\s+[${LTR}'-]+){0,2})\\s*[:\\-]?\\s*(.{8,200})`, "gi"));
          P.goals.push(new RegExp(`([${LTR}'-]+(?:\\s+[${LTR}'-]+){0,2})\\s+(?:—Ö–æ—á–µ—Ç|–Ω–∞–º–µ—Ä–µ–Ω(?:–∞)?|–ø–ª–∞–Ω–∏—Ä—É–µ—Ç|—Å—Ç—Ä–µ–º–∏—Ç—Å—è|—Ä–µ—à–∏–ª(?:–∞)?|–º–µ—á—Ç–∞–µ—Ç)\\s+(.{8,200})`, "gi"));
          P.goals.push(new RegExp(`([${LTR}'-]+(?:\\s+[${LTR}'-]+){0,2})\\s+(?:–µ–≥–æ|–µ—ë|–µ–µ|–∏—Ö)\\s+(?:—Ü–µ–ª—å|–∑–∞–¥–∞—á–∞|–ø–ª–∞–Ω|–º–µ—á—Ç–∞)\\s*[:\\-]?\\s*(.{8,200})`, "gi"));
          P.goals.push(new RegExp(`([${LTR}'-]+(?:\\s+[${LTR}'-]+){0,2})\\s+(?:—Ö–æ—Ç–µ–ª(?:–∞)?\\s+–ø–æ–¥—Ä—É–∂–∏—Ç—å—Å—è\\s+—Å|—Ä–µ—à–∏–ª(?:–∞)?\\s+–Ω–∞–ª–∞–¥–∏—Ç—å\\s+–æ—Ç–Ω–æ—à–µ–Ω–∏—è\\s*(?:—Å|)?)\\s+(.{3,200})`, "gi"));
          P.goals.push(new RegExp(`([${LTR}'-]+(?:\\s+[${LTR}'-]+){0,2})\\s+(?:—Ö–æ—Ç–µ–ª(?:–∞)?\\s+–ø—Ä–æ–∏–∑–≤–µ—Å—Ç–∏\\s+(?:–Ω–∞\\s+(?:–Ω–µ–µ|–Ω–µ–≥–æ)\\s+)?–≤–ø–µ—á–∞—Ç–ª–µ–Ω–∏–µ|–ø—ã—Ç–∞–ª(?:—Å—è|–∞—Å—å)\\s+–≤–ø–µ—á–∞—Ç–ª–∏—Ç—å)\\s*(.{3,200})`, "gi"));
          P.goals.push(new RegExp(`([${LTR}'-]+(?:\\s+[${LTR}'-]+){0,2})\\s+(?:—Ä–µ—à–∏–ª(?:–∞)?\\s+–æ—Ç–æ–º—Å—Ç–∏—Ç—å|–ø–æ–∫–ª—è–ª(?:—Å—è|–∞—Å—å)\\s+–æ—Ç–æ–º—Å—Ç–∏—Ç—å)\\s*(?:–∑–∞)?\\s*(.{3,200})`, "gi"));
          P.goals.push(new RegExp(`([${LTR}'-]+(?:\\s+[${LTR}'-]+){0,2})\\s+(?:—Ä–µ—à–∏–ª(?:–∞)?\\s+–∏—Å–ø—Ä–∞–≤–∏—Ç—å\\s+–æ—Ü–µ–Ω–∫–∏|—Ö–æ—Ç–µ–ª(?:–∞)?\\s+–ø–æ–ª—É—á–∏—Ç—å\\s+–æ—Ç–ª–∏—á–Ω–æ)\\s*(.{3,200})`, "gi"));
          P.goals.push(new RegExp(`([${LTR}'-]+(?:\\s+[${LTR}'-]+){0,2})\\s+(?:–µ–≥–æ|–µ—ë|–µ–µ)\\s+—Ü–µ–ª—å—é\\s+–±—ã–ª–∞\\s+–ø–æ–±–µ–¥–∞\\s+–≤\\s+(.{3,200})`, "gi"));
          P.goals.push(new RegExp(`([${LTR}'-]+(?:\\s+[${LTR}'-]+){0,2})\\s+—Ö–æ—Ç–µ–ª(?:–∞)?\\s+–≤—ã–∏–≥—Ä–∞—Ç—å\\s+(.{3,200})`, "gi"));
          P.goals.push(new RegExp(`([${LTR}'-]+(?:\\s+[${LTR}'-]+){0,2})\\s+(?:–¥–æ–ª–∂–µ–Ω|–¥–æ–ª–∂–Ω–∞)\\s+–≤—ã—è—Å–Ω–∏—Ç—å,?\\s+(?:—á—Ç–æ\\s+)?(.{3,200})`, "gi"));
          P.goals.push(new RegExp(`([${LTR}'-]+(?:\\s+[${LTR}'-]+){0,2})\\s+(?:—Ö–æ—Ç–µ–ª(?:–∞)?\\s+–¥–æ–∫–æ–ø–∞—Ç—å—Å—è\\s+–¥–æ\\s+–∏—Å—Ç–∏–Ω—ã|—Ä–µ—à–∏–ª(?:–∞)?\\s+—Ä–∞–∑—É–∑–Ω–∞—Ç—å\\s+–ø–æ–±–æ–ª—å—à–µ)\\s*(?:–æ)?\\s*(.{3,200})`, "gi"));
        }
        
        return P;
      },

      patterns: null,

      /**
       * Normalizes character names to their canonical form, handling aliases and case variations.
       * Supports both Russian and English names and their grammatical cases.
       * @param {string} name - The raw character name to normalize
       * @returns {string} The normalized canonical character name, or empty string if invalid
       */
      normalizeCharName(name){
        const n = String(name || "").trim();
        if (!n) return "";
        const aliases = {
          "–º–∞–∫—Å":"–ú–∞–∫—Å–∏–º","max":"–ú–∞–∫—Å–∏–º","maxim":"–ú–∞–∫—Å–∏–º","–±–µ—Ä–≥–º–∞–Ω":"–ú–∞–∫—Å–∏–º","bergman":"–ú–∞–∫—Å–∏–º",
          "–º–∞–∫—Å–∏–º–∞":"–ú–∞–∫—Å–∏–º","–º–∞–∫—Å–∏–º—É":"–ú–∞–∫—Å–∏–º","–º–∞–∫—Å–∏–º–µ":"–ú–∞–∫—Å–∏–º","–º–∞–∫—Å–∏–º–æ–º":"–ú–∞–∫—Å–∏–º",
          "—Ö–ª–æ–∏":"–•–ª–æ—è","—Ö–ª–æ–µ":"–•–ª–æ—è","—Ö–ª–æ—é":"–•–ª–æ—è","—Ö–ª–æ–µ–π":"–•–ª–æ—è","chloe":"–•–ª–æ—è","—Ö–∞—Ä–ø–µ—Ä":"–•–ª–æ—è","harper":"–•–ª–æ—è",
          "—ç—à":"–≠—à–ª–∏","ash":"–≠—à–ª–∏","ashley":"–≠—à–ª–∏",
          "–≥—Ä–µ–π—Å–æ–Ω":"–ú–∏—Å—Å–∏—Å –ì—Ä–µ–π—Å–æ–Ω","grayson":"–ú–∏—Å—Å–∏—Å –ì—Ä–µ–π—Å–æ–Ω","—É—á–∏—Ç–µ–ª—å–Ω–∏—Ü–∞":"–ú–∏—Å—Å–∏—Å –ì—Ä–µ–π—Å–æ–Ω","—É—á–∏—Ç–µ–ª—å–Ω–∏—Ü—É":"–ú–∏—Å—Å–∏—Å –ì—Ä–µ–π—Å–æ–Ω","—É—á–∏—Ç–µ–ª—å–Ω–∏—Ü–µ":"–ú–∏—Å—Å–∏—Å –ì—Ä–µ–π—Å–æ–Ω","—É—á–∏—Ç–µ–ª—å–Ω–∏—Ü–µ–π":"–ú–∏—Å—Å–∏—Å –ì—Ä–µ–π—Å–æ–Ω","teacher":"–ú–∏—Å—Å–∏—Å –ì—Ä–µ–π—Å–æ–Ω",
          "–∫–æ–≤–∞–ª—å—Å–∫–∏":"–î–∏—Ä–µ–∫—Ç–æ—Ä –ö–æ–≤–∞–ª—å—Å–∫–∏","kovalski":"–î–∏—Ä–µ–∫—Ç–æ—Ä –ö–æ–≤–∞–ª—å—Å–∫–∏","–¥–∏—Ä–µ–∫—Ç–æ—Ä":"–î–∏—Ä–µ–∫—Ç–æ—Ä –ö–æ–≤–∞–ª—å—Å–∫–∏","–¥–∏—Ä–µ–∫—Ç–æ—Ä–∞":"–î–∏—Ä–µ–∫—Ç–æ—Ä –ö–æ–≤–∞–ª—å—Å–∫–∏","–¥–∏—Ä–µ–∫—Ç–æ—Ä—É":"–î–∏—Ä–µ–∫—Ç–æ—Ä –ö–æ–≤–∞–ª—å—Å–∫–∏","–¥–∏—Ä–µ–∫—Ç–æ—Ä–æ–º":"–î–∏—Ä–µ–∫—Ç–æ—Ä –ö–æ–≤–∞–ª—å—Å–∫–∏","–¥–∏—Ä–µ–∫—Ç–æ—Ä–µ":"–î–∏—Ä–µ–∫—Ç–æ—Ä –ö–æ–≤–∞–ª—å—Å–∫–∏","–∞–ª–µ–∫—Å–∞–Ω–¥—Ä":"–î–∏—Ä–µ–∫—Ç–æ—Ä –ö–æ–≤–∞–ª—å—Å–∫–∏"
        };
        const low = (LC && typeof LC._normUCached === "function") ? LC._normUCached(n) : n.toLowerCase();
        const aliasIndex = { ...aliases };

        const L = LC.lcInit ? LC.lcInit() : null;
        const displayMap = {
          "–º–∞–∫—Å–∏–º":"–ú–∞–∫—Å–∏–º",
          "—Ö–ª–æ—è":"–•–ª–æ—è",
          "—ç—à–ª–∏":"–≠—à–ª–∏",
          "–º–∏—Å—Å–∏—Å –≥—Ä–µ–π—Å–æ–Ω":"–ú–∏—Å—Å–∏—Å –ì—Ä–µ–π—Å–æ–Ω",
          "–¥–∏—Ä–µ–∫—Ç–æ—Ä –∫–æ–≤–∞–ª—å—Å–∫–∏":"–î–∏—Ä–µ–∫—Ç–æ—Ä –ö–æ–≤–∞–ª—å—Å–∫–∏"
        };

        const userCanonSet = new Set();

        if (L && L.aliases){
          for (const key in L.aliases){
            const canon = String(key || "").trim();
            if (!canon) continue;
            const canonLow = (LC && typeof LC._normUCached === "function") ? LC._normUCached(canon) : canon.toLowerCase();
            userCanonSet.add(canonLow);
            displayMap[canonLow] = canon;
          }
        }

        function canonDisplay(str){
          if (!str) return "";
          if (displayMap[str]) return displayMap[str];
          let out = str;
          try {
            out = str.replace(/\b\p{Ll}/gu, m => m.toUpperCase());
          } catch(e) {
            const words = str.split(/\s+/).filter(Boolean);
            out = words.map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(" ");
          }
          displayMap[str] = out;
          return out;
        }

        const aliasMap = LC.getAliasMap ? LC.getAliasMap() : {};
        for (const canon in aliasMap){
          const canonLow = (LC && typeof LC._normUCached === "function") ? LC._normUCached(canon) : canon.toLowerCase();
          const isUserCanon = userCanonSet.has(canonLow);
          const target = canonDisplay(canonLow);
          const list = aliasMap[canon] || [];
          for (let i=0;i<list.length;i++){
            const rawItem = String(list[i] || "").trim();
            if (!rawItem) continue;
            const item = (LC && typeof LC._normUCached === "function") ? LC._normUCached(rawItem) : rawItem.toLowerCase();
            if (!item) continue;
            if (isUserCanon || !Object.prototype.hasOwnProperty.call(aliasIndex, item)) {
              aliasIndex[item] = target;
            }
          }
          if (isUserCanon || !Object.prototype.hasOwnProperty.call(aliasIndex, canonLow)) {
            aliasIndex[canonLow] = target;
          }
        }

        if (aliasIndex[low]) return aliasIndex[low];

        const tokens = low.split(/\s+/).filter(Boolean);
        for (let i=0;i<tokens.length;i++){
          const token = tokens[i];
          const canon = aliasIndex[token];
          if (canon) return canon;
        }

        return n;
      },
      /**
       * Checks if a character name is in the list of important/core characters.
       * Important characters are those whose state changes should be tracked.
       * @param {string} name - The character name to check (should be normalized)
       * @returns {boolean} True if the character is important, false otherwise
       */
      isImportantCharacter(name){
        const core = ["–ú–∞–∫—Å–∏–º","–•–ª–æ—è","–≠—à–ª–∏","–ú–∏—Å—Å–∏—Å –ì—Ä–µ–π—Å–æ–Ω","–î–∏—Ä–µ–∫—Ç–æ—Ä –ö–æ–≤–∞–ª—å—Å–∫–∏","Maxim","Chloe","Ashley"];
        return core.indexOf(name) !== -1;
      },
      limitCategories(L){
        const maxPer = LC.CONFIG.LIMITS.EVERGREEN_MAX_PER_CATEGORY;
        function limit(obj){
          const keys = Object.keys(obj || {});
          if (keys.length > maxPer){
            const slice = keys.slice(-maxPer);
            const next = {};
            for (let i=0;i<slice.length;i++){ const k = slice[i]; next[k] = obj[k]; }
            return next;
          }
          return obj;
        }
        L.evergreen.relations   = limit(L.evergreen.relations || {});
        L.evergreen.status      = limit(L.evergreen.status || {});
        L.evergreen.obligations = limit(L.evergreen.obligations || {});
        L.evergreen.facts       = limit(L.evergreen.facts || {});
      },
      /**
       * Analyzes text for relations, status changes, obligations, and facts using regex patterns.
       * Updates the evergreen state with detected information and increments stateVersion on changes.
       * @param {string} text - The text to analyze
       * @param {'story'|'input'|'output'|'retry'} actionType - The type of action that triggered the analysis
       * @returns {void}
       */
      analyze(text, actionType){
        const L = LC.lcInit();
        if (!this.patterns) this.patterns = this._buildPatterns();
        if (!L.evergreen || !L.evergreen.enabled || actionType === "retry" || !text) return;
        const originalText = String(text || "");
        const T = LC._normUCached?.(text) ?? LC._normU(text);

        // EVG: extract cue-based facts on normalized text (':' is optional in regex)
        try {
          const TT = T;
          if (Array.isArray(this.patterns.factsCues)) {
            for (let i = 0; i < this.patterns.factsCues.length; i++) {
              const re = this.patterns.factsCues[i];
              if (!re) continue;
              re.lastIndex = 0;
              let m;
              while ((m = re.exec(TT)) !== null) {
                const val = (m[1] || "").trim();
                if (val.length >= 4) {
                  const key = `cue_${Date.now()}_${i}_${Math.random().toString(36).slice(2,6)}`;
                  upd("facts", key, val);
                }
              }
            }
          }
          // Dedup facts by normalized text
          try {
            const cat = (L.evergreen && L.evergreen.facts) || {};
            const keys = Object.keys(cat);
            const seen = new Set();
            for (let i = 0; i < keys.length; i++) {
              const k = keys[i];
              const v = String(cat[k] || "").trim().toLowerCase();
              if (!v) {
                delete cat[k];
                continue;
              }
              if (seen.has(v)) {
                delete cat[k];
                continue;
              }
              seen.add(v);
            }
            LC.EvergreenEngine?.limitCategories?.(L);
          } catch (_) {}
        } catch (e) {
          LC.lcWarn?.("EVG: factsCues analyze failed: " + (e && e.message));
        }

        const formatRelation = (subject, action, object, raw, patternType, options={})=>{
          const subj = String(subject || "").trim();
          const obj = String(object || "").trim();
          const act = String(action || "").trim();
          const rawStr = String(raw || "").trim();
          const subjText = String(options.subjectText || options.subjectRaw || subject || "").trim() || subj;
          const objTextBase = String(options.objectText || options.objectRaw || object || "").trim() || obj;
          const reverse = !!options.reverse;
          const originSubject = String(options.originSubject || "").trim();
          const originSubjectText = String(options.originSubjectText || options.originSubjectRaw || "").trim();
          const agentText = reverse ? (originSubjectText || objTextBase || originSubject || obj) : objTextBase;
          if (!subj) return "";

          const actLower = act.toLowerCase();
          const ruPairMap = {
            "–≤–º–µ—Å—Ç–µ": "—Ç–µ–ø–µ—Ä—å –≤–º–µ—Å—Ç–µ —Å",
            "–ø–∞—Ä–∞": "—Ç–µ–ø–µ—Ä—å –ø–∞—Ä–∞ —Å",
            "—Ä–∞—Å—Å—Ç–∞–ª–∏—Å—å": "—Ç–µ–ø–µ—Ä—å —Ä–∞—Å—Å—Ç–∞–ª–∏—Å—å —Å",
            "–¥—Ä—É–∑—å—è": "—Ç–µ–ø–µ—Ä—å –¥—Ä—É–∑—å—è —Å",
            "–≤—Ä–∞–≥–∏": "—Ç–µ–ø–µ—Ä—å –≤—Ä–∞–≥–∏ —Å"
          };
          const enPairMap = {
            "dating": "is dating",
            "together": "is together with",
            "friends": "is friends with",
            "enemies": "is enemies with"
          };

          function guessGender(name, fallback){
            const normInput = (value) => {
              const str = String(value || "").trim();
              if (!str) return "";
              return (LC && typeof LC._normUCached === "function") ? LC._normUCached(str) : str.toLowerCase();
            };
            const low = normInput(name);
            const map = {
              "–º–∞–∫—Å–∏–º":"m","maxim":"m","–º–∞–∫—Å":"m","bergman":"m","–±–µ—Ä–≥–º–∞–Ω":"m",
              "–¥–∏—Ä–µ–∫—Ç–æ—Ä –∫–æ–≤–∞–ª—å—Å–∫–∏":"m","–∫–æ–≤–∞–ª—å—Å–∫–∏":"m",
              "—Ö–ª–æ—è":"f","chloe":"f","—Ö–∞—Ä–ø–µ—Ä":"f",
              "—ç—à–ª–∏":"f","ashley":"f","ash":"f",
              "–º–∏—Å—Å–∏—Å –≥—Ä–µ–π—Å–æ–Ω":"f","grayson":"f","teacher":"f",
              "—Ä–µ–π—á–µ–ª":"f","—Ä—ç–π—á–µ–ª":"f","rachel":"f"
            };
            if (map[low]) return map[low];
            const fb = normInput(fallback);
            if (fb && map[fb]) return map[fb];
            if (/\b(?:–º–∏—Å—Å–∏—Å)\b/.test(low)) return "f";
            if (/[–∞—è]$/.test(low)) return "f";
            return "";
          }

          function ruBeForm(g){
            if (g === "f") return "–±—ã–ª–∞";
            if (g === "pl") return "–±—ã–ª–∏";
            if (g === "n") return "–±—ã–ª–æ";
            return "–±—ã–ª";
          }

          function buildRuPassive(subjName, actionWord, agent, genderGuess){
            const actKey = (()=>{
              let key = actionWord.toLowerCase();
              if (/^–ø–æ—Ü–µ–ª–æ–≤–∞–ª/.test(key)) return "–ø–æ—Ü–µ–ª–æ–≤–∞–ª";
              if (/^–æ–±–Ω—è–ª/.test(key)) return "–æ–±–Ω—è–ª";
              if (/^—É–¥–∞—Ä–∏–ª/.test(key)) return "—É–¥–∞—Ä–∏–ª";
              if (/^–ø—Ä–µ–¥–∞–ª/.test(key)) return "–ø—Ä–µ–¥–∞–ª";
              if (/^–ø—Ä–æ—Å—Ç–∏–ª/.test(key)) return "–ø—Ä–æ—Å—Ç–∏–ª";
              if (/^–±—Ä–æ—Å–∏–ª/.test(key)) return "–±—Ä–æ—Å–∏–ª";
              return key;
            })();
            const gender = genderGuess || guessGender(subjName, subjText);
            const be = ruBeForm(gender);
            const templates = {
              "–ª—é–±–∏—Ç": { part:{ m:"–ª—é–±–∏–º", f:"–ª—é–±–∏–º–∞", n:"–ª—é–±–∏–º–æ", pl:"–ª—é–±–∏–º—ã" } },
              "–Ω–µ–Ω–∞–≤–∏–¥–∏—Ç": { part:{ m:"–Ω–µ–Ω–∞–≤–∏–¥–∏–º", f:"–Ω–µ–Ω–∞–≤–∏–¥–∏–º–∞", n:"–Ω–µ–Ω–∞–≤–∏–¥–∏–º–æ", pl:"–Ω–µ–Ω–∞–≤–∏–¥–∏–º—ã" } },
              "—Ä–µ–≤–Ω—É–µ—Ç": {
                custom(g){
                  const base = g === "f" ? "—Å—Ç–∞–ª–∞" : g === "pl" ? "—Å—Ç–∞–ª–∏" : g === "n" ? "—Å—Ç–∞–ª–æ" : "—Å—Ç–∞–ª";
                  const agentPart = agent ? ` —É ${agent}` : "";
                  return `${subjText} ${base} –æ–±—ä–µ–∫—Ç–æ–º —Ä–µ–≤–Ω–æ—Å—Ç–∏${agentPart}`.trim();
                }
              },
              "–ø–æ—Ü–µ–ª–æ–≤–∞–ª": { part:{ m:"–ø–æ—Ü–µ–ª–æ–≤–∞–Ω", f:"–ø–æ—Ü–µ–ª–æ–≤–∞–Ω–∞", n:"–ø–æ—Ü–µ–ª–æ–≤–∞–Ω–æ", pl:"–ø–æ—Ü–µ–ª–æ–≤–∞–Ω—ã" } },
              "–æ–±–Ω—è–ª": { part:{ m:"–æ–±–Ω—è—Ç", f:"–æ–±–Ω—è—Ç–∞", n:"–æ–±–Ω—è—Ç–æ", pl:"–æ–±–Ω—è—Ç—ã" } },
              "—É–¥–∞—Ä–∏–ª": { part:{ m:"—É–¥–∞—Ä–µ–Ω", f:"—É–¥–∞—Ä–µ–Ω–∞", n:"—É–¥–∞—Ä–µ–Ω–æ", pl:"—É–¥–∞—Ä–µ–Ω—ã" } },
              "–ø—Ä–µ–¥–∞–ª": { part:{ m:"–ø—Ä–µ–¥–∞–Ω", f:"–ø—Ä–µ–¥–∞–Ω–∞", n:"–ø—Ä–µ–¥–∞–Ω–æ", pl:"–ø—Ä–µ–¥–∞–Ω—ã" } },
              "–ø—Ä–æ—Å—Ç–∏–ª": { part:{ m:"–ø—Ä–æ—â—ë–Ω", f:"–ø—Ä–æ—â–µ–Ω–∞", n:"–ø—Ä–æ—â–µ–Ω–æ", pl:"–ø—Ä–æ—â–µ–Ω—ã" } },
              "–±—Ä–æ—Å–∏–ª": { part:{ m:"–±—Ä–æ—à–µ–Ω", f:"–±—Ä–æ—à–µ–Ω–∞", n:"–±—Ä–æ—à–µ–Ω–æ", pl:"–±—Ä–æ—à–µ–Ω—ã" } }
            };
            const tpl = templates[actKey];
            if (tpl){
              if (typeof tpl.custom === "function") return tpl.custom(gender);
              const part = (tpl.part && (tpl.part[gender] || tpl.part.m)) || "";
              const agentPart = agent ? ` ${agent}` : "";
              return `${subjText} ${be} ${part}${agentPart}`.trim();
            }
            if (actionWord){
              const agentPart = agent ? ` ${agent}` : "";
              return `${subjText} ${be} ${actionWord}${agentPart}`.trim();
            }
            if (agent){
              return `${subjText} ${be} ${agent}`.trim();
            }
            return subjText;
          }

          function buildEnPassive(actionWord, agent){
            const key = actionWord.toLowerCase();
            const templates = {
              "loves": { be:"is", part:"loved" },
              "hates": { be:"is", part:"hated" },
              "kissed": { be:"was", part:"kissed" },
              "hugged": { be:"was", part:"hugged" }
            };
            const tpl = templates[key];
            if (tpl){
              const agentPart = agent ? ` by ${agent}` : "";
              return `${subjText} ${tpl.be} ${tpl.part}${agentPart}`.trim();
            }
            if (actionWord){
              const agentPart = agent ? ` by ${agent}` : "";
              return `${subjText} was ${actionWord}${agentPart}`.trim();
            }
            return subjText;
          }

          let phrase = "";
          if (reverse && act) {
            if (patternType === "verbRu") {
              phrase = buildRuPassive(subj, act, agentText, guessGender(subj, subjText));
            } else if (patternType === "verbEn") {
              phrase = buildEnPassive(act, agentText);
            }
          }

          if (!phrase){
            if ((patternType === "pairRu" || patternType === "pairEn") && !act) {
              phrase = rawStr ? `${subjText} ${rawStr}` : subjText;
            } else if (ruPairMap[actLower]) {
              phrase = `${subjText} ${ruPairMap[actLower]}${agentText ? ` ${agentText}` : ""}`;
            } else if (enPairMap[actLower]) {
              const link = enPairMap[actLower];
              phrase = `${subjText} ${link}${agentText ? ` ${agentText}` : ""}`;
            } else if (act) {
              phrase = `${subjText} ${act}${agentText ? ` ${agentText}` : ""}`;
            } else if (agentText) {
              phrase = `${subjText} ${agentText}`;
            } else {
              phrase = rawStr || subjText;
            }
          }

          return phrase.replace(/\s+/g, " ").trim();
        };

        function upd(cat, key, val){
          if (!val || val.length < 2) return;
          const box = (L.evergreen[cat] = L.evergreen[cat] || {});
          const prev = box[key];
          if (prev !== val){
            if (prev) {
              L.evergreen.history.push({ turn:L.turn, category:cat, old:prev, new:val });
              const capNum = Number(L.evergreenHistoryCap);
              const cap = Number.isFinite(capNum) ? capNum : 0;
              if (cap > 0 && Array.isArray(L.evergreen.history) && L.evergreen.history.length > cap) {
                const overflow = L.evergreen.history.length - cap;
                if (overflow > 0) L.evergreen.history.splice(0, overflow);
              }
            }
            box[key] = val;
            
            // Increment stateVersion to invalidate context cache
            L.stateVersion++;
          }
        }

        // RELATIONS
        for (let i=0;i<this.patterns.relations.length;i++){
          const p = this.patterns.relations[i]; p.lastIndex = 0;
          let m;
          try {
            while ((m = p.exec(T)) !== null){
              const patternType = p._relPattern || "";
              let subjectRaw = "";
              let counterpartRaw = "";
              let actionRaw = "";
              if (patternType === "verbRu" || patternType === "verbEn") {
                subjectRaw = String(m[1] || "").trim();
                actionRaw = String(m[2] || "").trim();
                counterpartRaw = String(m[3] || "").trim();
              } else {
                subjectRaw = String(m[1] || "").trim();
                counterpartRaw = String(m[2] || "").trim();
                actionRaw = String(m[3] || "").trim();
              }

              const subject = this.normalizeCharName(subjectRaw);
              const counterpart = this.normalizeCharName(counterpartRaw);
              const action = actionRaw;

              if (!subject || !counterpart) continue;
              const importantSubject = this.isImportantCharacter(subject);
              const importantCounterpart = this.isImportantCharacter(counterpart);
              if (!importantSubject && !importantCounterpart) continue;

              // Determine modifier based on action
              let modifier = 5; // Default positive modifier
              const actionLower = action.toLowerCase();
              
              // Negative actions
              if (/–ø—Ä–µ–¥–∞–ª|–ø—Ä–µ–¥–∞–ª–∞|–∏–∑–º–µ–Ω–∞|betrayed|betray|backstab/.test(actionLower)) {
                modifier = -25; // betrayal
              } else if (/—É–¥–∞—Ä–∏–ª|—É–¥–∞—Ä–∏–ª–∞|—Å—Å–æ—Ä|–∫—Ä–∏–∫|fight|hit|punch/.test(actionLower)) {
                modifier = -10; // conflict
              } else if (/–Ω–µ–Ω–∞–≤–∏–¥|hate/.test(actionLower)) {
                modifier = -15;
              } else if (/—Ä–∞—Å—Å—Ç–∞–ª|broke up|enemies|–≤—Ä–∞–≥–∏/.test(actionLower)) {
                modifier = -20;
              }
              // Positive actions
              else if (/–ø–æ—Ü–µ–ª–æ–≤–∞–ª|–ø–æ—Ü–µ–ª–æ–≤–∞–ª–∞|kiss|together|–≤–º–µ—Å—Ç–µ|–ø–∞—Ä–∞|dating/.test(actionLower)) {
                modifier = 15; // romance
              } else if (/–≤–µ—Ä–Ω–æ—Å—Ç—å|–ø—Ä–µ–¥–∞–Ω–Ω–æ—Å—Ç—å|loyal|support|stood by|–ø—Ä–æ—Å—Ç–∏–ª|–ø—Ä–æ—â/.test(actionLower)) {
                modifier = 10; // loyalty
              } else if (/–ª—é–±–∏—Ç|love|–æ–±–Ω—è–ª|–æ–±–Ω—è–ª–∞|hug/.test(actionLower)) {
                modifier = 12;
              } else if (/–¥—Ä—É–∑—å—è|–¥—Ä—É–≥|friend/.test(actionLower)) {
                modifier = 8;
              }

              // Initialize nested structure if needed
              if (typeof L.evergreen.relations[subject] !== 'object' || L.evergreen.relations[subject] === null) {
                L.evergreen.relations[subject] = {};
              }
              if (typeof L.evergreen.relations[counterpart] !== 'object' || L.evergreen.relations[counterpart] === null) {
                L.evergreen.relations[counterpart] = {};
              }

              // Update numeric values (default to 50 if not set)
              const currentVal1 = typeof L.evergreen.relations[subject][counterpart] === 'number' 
                ? L.evergreen.relations[subject][counterpart] : 50;
              const currentVal2 = typeof L.evergreen.relations[counterpart][subject] === 'number' 
                ? L.evergreen.relations[counterpart][subject] : 50;

              L.evergreen.relations[subject][counterpart] = Math.max(-100, Math.min(100, currentVal1 + modifier));
              L.evergreen.relations[counterpart][subject] = Math.max(-100, Math.min(100, currentVal2 + modifier));
            }
          } catch (err) {
            LC.lcWarn(`Regex engine issue: ${err && err.message ? err.message : err}`);
          }
        }
        // STATUS
        for (let i=0;i<this.patterns.status.length;i++){
          const p = this.patterns.status[i]; p.lastIndex = 0;
          let m;
          try {
            while ((m = p.exec(T)) !== null){
              const A = this.normalizeCharName(m[1]);
              const S = String(m[2] || "").replace(/[.,!?]+$/, "").trim();
              if (A && S && this.isImportantCharacter(A)) upd("status", A, S);
            }
          } catch (err) {
            LC.lcWarn(`Regex engine issue: ${err && err.message ? err.message : err}`);
          }
        }
        // OBLIGATIONS
        for (let i=0;i<this.patterns.obligations.length;i++){
          const p = this.patterns.obligations[i]; p.lastIndex = 0;
          const rawPattern = new RegExp(p.source, p.flags);
          rawPattern.lastIndex = 0;
          let m;
          try {
            while ((m = rawPattern.exec(originalText)) !== null){
              const A = this.normalizeCharName(m[1]);
              const captureCount = (m.length || 0) - 1;
              let rawTarget = "";
              let rawDesc = "";
              if (captureCount >= 3) {
                rawTarget = m[2] || "";
                rawDesc = m[3] || "";
              } else if (captureCount === 2) {
                rawDesc = m[2] || "";
              } else if (captureCount >= 1) {
                rawDesc = m[captureCount] || "";
              }
              let B = "";
              if (captureCount >= 3) {
                let trimmedTarget = String(rawTarget || "").trim();
                const originalTarget = trimmedTarget;
                if (trimmedTarget) {
                  const targetParts = trimmedTarget.split(/\s+/).filter(Boolean);
                  if (targetParts.length > 1) {
                    let cutIndex = targetParts.length;
                    while (cutIndex > 0) {
                      const word = targetParts[cutIndex - 1];
                      const first = word ? word.charAt(0) : "";
                      const isLetter = first && first.toLowerCase() !== first.toUpperCase();
                      if (!isLetter || first === first.toUpperCase()) break;
                      cutIndex--;
                    }
                    if (cutIndex < targetParts.length) {
                      const extra = targetParts.slice(cutIndex).join(" ");
                      rawDesc = `${extra} ${rawDesc}`.trim();
                      targetParts.length = cutIndex;
                      trimmedTarget = targetParts.join(" ");
                    }
                  }
                  if (trimmedTarget) {
                    const pronRegex = /^(?:–µ–º—É|–µ–π|–∏–º|–Ω–∞–º|—Ç–µ–±–µ|–º–Ω–µ|–≤–∞–º|–µ–≥–æ|–µ–µ|–Ω–∏—Ö|–Ω–∞—Å|–≤–∞—Å|him|her|them|you|us|me)$/i;
                    const normalizedTarget = this.normalizeCharName(trimmedTarget);
                    let hasUppercase = false;
                    try {
                      hasUppercase = /[\p{Lu}]/u.test(trimmedTarget);
                    } catch (_) {
                      hasUppercase = /[A-Z–ê-–Ø–Å]/.test(trimmedTarget);
                    }
                    const displayTarget = originalTarget || normalizedTarget;
                    if (pronRegex.test(trimmedTarget)) {
                      B = displayTarget;
                    } else if (normalizedTarget) {
                      B = normalizedTarget;
                    } else if (hasUppercase) {
                      B = displayTarget;
                    } else {
                      rawDesc = `${trimmedTarget} ${rawDesc}`.trim();
                    }
                  }
                }
              }
              const D = String(rawDesc || "").replace(/[.,!?]+$/, "").trim();
              if (A && D && this.isImportantCharacter(A)){
                upd("obligations", A, B ? `${A} owes ${B}: ${D}` : `${A}: ${D}`);
              }
            }
          } catch (err) {
            LC.lcWarn(`Regex engine issue: ${err && err.message ? err.message : err}`);
          }
        }
        // FACTS
        for (let i=0;i<this.patterns.facts.length;i++){
          const p = this.patterns.facts[i]; p.lastIndex = 0;
          let m;
          try {
            while ((m = p.exec(T)) !== null){
              const F = String(m[1] || "").replace(/[.,!?]+$/, "").trim();
              if (F.length >= 5){
                const key = `f_${L.turn}_${Math.random().toString(36).slice(2,6)}`;
                upd("facts", key, F);
              }
            }
          } catch (err) {
            LC.lcWarn(`Regex engine issue: ${err && err.message ? err.message : err}`);
          }
        }

        this.limitCategories(L);
        L.evergreen.lastUpdate = L.turn;
      },
      getCanon(){
        const L = LC.lcInit();
        if (!L.evergreen || !L.evergreen.enabled) return "";
        function pick(obj, n){ const vals = Object.values(obj || {}); return vals.slice(-n); }
        const n = LC.CONFIG.LIMITS.EVERGREEN_MAX_PER_CATEGORY;

        // Convert numeric relationship values to text descriptions
        const relationDescriptions = [];
        if (L.evergreen.relations && typeof L.evergreen.relations === 'object') {
          for (const char in L.evergreen.relations) {
            const rels = L.evergreen.relations[char];
            if (typeof rels === 'object' && rels !== null) {
              for (const other in rels) {
                const value = rels[other];
                let description = '';
                
                if (typeof value === 'number') {
                  // Legacy numeric value
                  if (value > 75) {
                    description = `${char} –∏ ${other} ‚Äî –±–ª–∏–∑–∫–∏–µ –¥—Ä—É–∑—å—è`;
                  } else if (value > 50) {
                    description = `${char} –∏ ${other} ‚Äî —Ö–æ—Ä–æ—à–∏–µ –¥—Ä—É–∑—å—è`;
                  } else if (value > 25) {
                    description = `${char} –∏ ${other} ‚Äî –∑–Ω–∞–∫–æ–º—ã`;
                  } else if (value > 0) {
                    description = `${char} –∏ ${other} ‚Äî –Ω–µ–π—Ç—Ä–∞–ª—å–Ω—ã–µ –æ—Ç–Ω–æ—à–µ–Ω–∏—è`;
                  } else if (value > -25) {
                    description = `${char} –∏ ${other} ‚Äî –Ω–∞—Ç—è–Ω—É—Ç—ã–µ –æ—Ç–Ω–æ—à–µ–Ω–∏—è`;
                  } else if (value > -50) {
                    description = `${char} –∏ ${other} ‚Äî –∫–æ–Ω—Ñ–ª–∏–∫—Ç—É—é—Ç`;
                  } else {
                    description = `${char} –∏ ${other} ‚Äî –≤—Ä–∞–≥–∏`;
                  }
                } else if (typeof value === 'object' && value !== null) {
                  // Multi-vector format
                  const aff = value.affection || 50;
                  const trust = value.trust || 50;
                  const resp = value.respect || 50;
                  const riv = value.rivalry || 50;
                  
                  // Create nuanced description based on vectors
                  const parts = [];
                  if (aff > 70) parts.push('–±–ª–∏–∑–∫–∏');
                  else if (aff > 50) parts.push('–¥—Ä—É–∂–µ–ª—é–±–Ω—ã');
                  else if (aff < 30) parts.push('—Ö–æ–ª–æ–¥–Ω—ã');
                  
                  if (trust > 70) parts.push('–¥–æ–≤–µ—Ä—è—é—Ç');
                  else if (trust < 30) parts.push('–Ω–µ –¥–æ–≤–µ—Ä—è—é—Ç');
                  
                  if (resp > 70) parts.push('—É–≤–∞–∂–∞—é—Ç');
                  else if (resp < 30) parts.push('–Ω–µ —É–≤–∞–∂–∞—é—Ç');
                  
                  if (riv > 70) parts.push('—Å–æ–ø–µ—Ä–Ω–∏—á–∞—é—Ç');
                  
                  if (parts.length > 0) {
                    description = `${char} –∏ ${other} ‚Äî ${parts.join(', ')}`;
                  } else {
                    description = `${char} –∏ ${other} ‚Äî –Ω–µ–π—Ç—Ä–∞–ª—å–Ω—ã–µ –æ—Ç–Ω–æ—à–µ–Ω–∏—è`;
                  }
                }
                
                if (description) {
                  relationDescriptions.push(description);
                }
              }
            }
          }
        }
        
        // Remove duplicates (since relationships are bidirectional)
        const uniqueRelations = [];
        const seen = new Set();
        for (let i = 0; i < relationDescriptions.length; i++) {
          const rel = relationDescriptions[i];
          // Create a normalized key by sorting character names
          const match = rel.match(/^(.+?) –∏ (.+?) ‚Äî/);
          if (match) {
            const char1 = match[1];
            const char2 = match[2];
            const key = [char1, char2].sort().join('|');
            if (!seen.has(key)) {
              seen.add(key);
              uniqueRelations.push(rel);
            }
          }
        }
        
        const rel = uniqueRelations.slice(-n);
        const st  = pick(L.evergreen.status, n);
        const ob  = pick(L.evergreen.obligations, n);
        const fa  = pick(L.evergreen.facts, n);

        const parts = [];
        if (rel.length) parts.push(`Relations: ${rel.join("; ")}`);
        if (st.length)  parts.push(`Status: ${st.join("; ")}`);
        if (ob.length)  parts.push(`Obligations: ${ob.join("; ")}`);
        if (fa.length)  parts.push(`Facts: ${fa.join("; ")}`);
        return parts.join(" | ").slice(0, 600);
      },
      getSummary(){
        const L = LC.lcInit();
        const E = L.evergreen || {};
        
        // Count relationship pairs (numeric values)
        let relationCount = 0;
        if (E.relations && typeof E.relations === 'object') {
          for (const char in E.relations) {
            const rels = E.relations[char];
            if (typeof rels === 'object' && rels !== null) {
              for (const other in rels) {
                if (typeof rels[other] === 'number') {
                  relationCount++;
                }
              }
            }
          }
          // Divide by 2 since relationships are bidirectional
          relationCount = Math.floor(relationCount / 2);
        }
        
        return [
          "=== EVERGREEN CANON ===",
          `Enabled: ${E.enabled ? "Yes" : "No"}`,
          `Relations: ${relationCount}`,
          `Status: ${Object.keys(E.status || {}).length}`,
          `Obligations: ${Object.keys(E.obligations || {}).length}`,
          `Facts: ${Object.keys(E.facts || {}).length}`
        ].join("\n");
      },
      toggle(on){ const L=LC.lcInit(); L.evergreen.enabled=!!on; LC.lcSys(`Evergreen ${on?"enabled":"disabled"}.`); },
      clear(){
        const L=LC.lcInit();
        L.evergreen = { enabled:true, relations:{}, status:{}, obligations:{}, facts:{}, history:[], lastUpdate:L.turn };
        LC.lcSys("Evergreen storage cleared.");
      }
    },

    // ========== Unified Analyzer ==========
    UnifiedAnalyzer: {
      patterns: null,
      
      _buildUnifiedPatterns(){
        // Get patterns from EvergreenEngine
        const autoEvergreen = LC.EvergreenEngine;
        if (!autoEvergreen) return [];
        if (!autoEvergreen.patterns) autoEvergreen.patterns = autoEvergreen._buildPatterns();
        
        const unified = [];
        const P = autoEvergreen.patterns;
        
        // Add goals patterns
        if (Array.isArray(P.goals)) {
          for (let i = 0; i < P.goals.length; i++) {
            unified.push({
              pattern: P.goals[i],
              engine: 'GoalsEngine',
              category: 'goals'
            });
          }
        }
        
        // Add relations patterns
        if (Array.isArray(P.relations)) {
          for (let i = 0; i < P.relations.length; i++) {
            unified.push({
              pattern: P.relations[i],
              engine: 'EvergreenEngine',
              category: 'relations',
              metadata: P.relations[i]._relPattern
            });
          }
        }
        
        // Add status patterns
        if (Array.isArray(P.status)) {
          for (let i = 0; i < P.status.length; i++) {
            unified.push({
              pattern: P.status[i],
              engine: 'EvergreenEngine',
              category: 'status'
            });
          }
        }
        
        // Add obligations patterns
        if (Array.isArray(P.obligations)) {
          for (let i = 0; i < P.obligations.length; i++) {
            unified.push({
              pattern: P.obligations[i],
              engine: 'EvergreenEngine',
              category: 'obligations'
            });
          }
        }
        
        // Add facts patterns
        if (Array.isArray(P.facts)) {
          for (let i = 0; i < P.facts.length; i++) {
            unified.push({
              pattern: P.facts[i],
              engine: 'EvergreenEngine',
              category: 'facts'
            });
          }
        }
        
        // Add factsCues patterns
        if (Array.isArray(P.factsCues)) {
          for (let i = 0; i < P.factsCues.length; i++) {
            unified.push({
              pattern: P.factsCues[i],
              engine: 'EvergreenEngine',
              category: 'factsCues'
            });
          }
        }
        
        // Add CKB (Chronological Knowledge Base) patterns
        const CKB = LC.ChronologicalKnowledgeBase;
        if (CKB) {
          for (const category in CKB) {
            if (CKB.hasOwnProperty(category)) {
              const ckbEntry = CKB[category];
              if (ckbEntry && Array.isArray(ckbEntry.patterns)) {
                for (let i = 0; i < ckbEntry.patterns.length; i++) {
                  unified.push({
                    pattern: ckbEntry.patterns[i],
                    engine: 'TimeEngine',
                    category: 'chronological',
                    action: ckbEntry.action
                  });
                }
              }
            }
          }
        }
        
        return unified;
      },
      
      /**
       * Analyzes text using all available engines (TimeEngine, EvergreenEngine, GoalsEngine, MoodEngine).
       * Processes patterns in order of priority and delegates to appropriate engines.
       * @param {string} text - The text to analyze (input or output)
       * @param {string} actionType - The type of action ('input', 'output', 'retry', etc.)
       */
      analyze(text, actionType){
        const L = LC.lcInit();
        if (!text) return;
        
        // Defensive programming: ensure evergreen exists
        if (!L.evergreen || typeof L.evergreen !== 'object') {
          L.evergreen = { enabled: true, relations: {}, status: {}, obligations: {}, facts: {}, history: [] };
        }
        if (!L.evergreen.enabled || actionType === "retry") return;
        
        // Build patterns on first use
        if (!this.patterns) {
          this.patterns = this._buildUnifiedPatterns();
        }
        
        // Process ChronologicalKnowledgeBase patterns first
        try {
          if (this.patterns && Array.isArray(this.patterns)) {
            const textLower = String(text || "").toLowerCase();
            
            for (let i = 0; i < this.patterns.length; i++) {
              const item = this.patterns[i];
              if (item.engine === 'TimeEngine' && item.category === 'chronological' && item.action) {
                if (item.pattern && item.pattern.test) {
                  item.pattern.lastIndex = 0;
                  if (item.pattern.test(textLower)) {
                    LC.TimeEngine?.processSemanticAction?.(item.action);
                    break; // Process only first matching time action
                  }
                }
              }
            }
          }
        } catch (e) {
          LC.lcWarn?.("UnifiedAnalyzer TimeEngine error: " + (e && e.message));
        }
        
        // Delegate to individual engines for now
        // The unified analyzer collects patterns but engines do the heavy processing
        try {
          LC.EvergreenEngine?.analyze?.(text, actionType);
        } catch (e) {
          LC.lcWarn?.("UnifiedAnalyzer EvergreenEngine error: " + (e && e.message));
        }
        
        try {
          LC.GoalsEngine?.analyze?.(text, actionType);
        } catch (e) {
          LC.lcWarn?.("UnifiedAnalyzer GoalsEngine error: " + (e && e.message));
        }
        
        try {
          LC.MoodEngine?.analyze?.(text);
        } catch (e) {
          LC.lcWarn?.("UnifiedAnalyzer MoodEngine error: " + (e && e.message));
        }
        
        try {
          LC.EnvironmentEngine?.analyze?.(text);
        } catch (e) {
          LC.lcWarn?.("UnifiedAnalyzer EnvironmentEngine error: " + (e && e.message));
        }
        
        try {
          LC.GossipEngine?.analyze?.(text);
        } catch (e) {
          LC.lcWarn?.("UnifiedAnalyzer GossipEngine error: " + (e && e.message));
        }
        
        try {
          LC.RelationsEngine?.analyze?.(text);
        } catch (e) {
          LC.lcWarn?.("UnifiedAnalyzer RelationsEngine error: " + (e && e.message));
        }
        
        // Demographic Pressure Detection
        try {
          LC.DemographicPressure?.analyze?.(text);
        } catch (e) {
          LC.lcWarn?.("UnifiedAnalyzer DemographicPressure error: " + (e && e.message));
        }
        
        // Social Hierarchy Recalculation (periodic)
        // Recalculate status every 20 turns to reflect changes in social capital
        try {
          if (L.turn && L.turn % 20 === 0) {
            LC.HierarchyEngine?.recalculateStatus?.();
          }
        } catch (e) {
          LC.lcWarn?.("UnifiedAnalyzer HierarchyEngine error: " + (e && e.message));
        }
      }
    },

    // ========== Demographic Pressure System ==========
    DemographicPressure: {
      suggestions: [], // Temporary storage for suggestions to add to context
      
      /**
       * Analyzes text to detect situations requiring new characters.
       * Detects: loneliness, need for experts, specific roles.
       */
      analyze(text) {
        if (!text) return;
        const L = LC.lcInit();
        
        this.suggestions = []; // Clear previous suggestions
        
        const textLower = String(text).toLowerCase();
        
        // Pattern: Loneliness - single character focus for extended period
        const activeChars = Object.keys(L.characters || {}).filter(name => {
          const char = L.characters[name];
          return char.lastSeen && (L.turn - char.lastSeen) <= 3;
        });
        
        if (activeChars.length === 1) {
          const charName = activeChars[0];
          // Check for loneliness indicators
          if (textLower.match(/–æ–¥–∏–Ω(?:–∞|–∏)?|—Å–∞–º(?:–∞|–∏)?|–≤\s+–æ–¥–∏–Ω–æ—á–µ—Å—Ç–≤–µ|–Ω–∏–∫–æ–≥–æ\s+(?:–Ω–µ\s+)?(?:–±—ã–ª–æ|–Ω–µ—Ç)/iu)) {
            this.suggestions.push(`‚ü¶SUGGESTION‚üß ${charName} –æ–¥–∏–Ω. –í–æ–∑–º–æ–∂–Ω–æ, –æ–Ω —Å –∫–µ–º-—Ç–æ —Å—Ç–æ–ª–∫–Ω–µ—Ç—Å—è.`);
          }
        }
        
        // Pattern: Need for Expert
        const expertPatterns = [
          { pattern: /(?:–≤–∑–ª–æ–º–∞—Ç—å|—Ö–∞–∫–Ω—É—Ç—å|–≤–∑–ª–æ–º|–∫–æ–¥|–ø—Ä–æ–≥—Ä–∞–º–º)/iu, expert: '–∫—Ç–æ-—Ç–æ, –∫—Ç–æ —Ä–∞–∑–±–∏—Ä–∞–µ—Ç—Å—è –≤ –∫–æ–º–ø—å—é—Ç–µ—Ä–∞—Ö' },
          { pattern: /(?:–Ω–∞–π—Ç–∏\s+–∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é|—Ä–∞—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ|—É–ª–∏–∫)/iu, expert: '–∫—Ç–æ-—Ç–æ, –∫—Ç–æ –º–æ–∂–µ—Ç –ø–æ–º–æ—á—å —Å –ø–æ–∏—Å–∫–æ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏' },
          { pattern: /(?:–≤—ã–ª–µ—á–∏—Ç—å|–ª–µ—á–µ–Ω–∏–µ|–º–µ–¥–∏—Ü–∏–Ω|—Ç—Ä–∞–≤–º|—Ä–∞–Ω)/iu, expert: '–∫—Ç–æ-—Ç–æ —Å –º–µ–¥–∏—Ü–∏–Ω—Å–∫–∏–º–∏ –∑–Ω–∞–Ω–∏—è–º–∏' },
          { pattern: /(?:–ø–æ—á–∏–Ω–∏—Ç—å|–æ—Ç—Ä–µ–º–æ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å|—Å–ª–æ–º–∞–Ω)/iu, expert: '–∫—Ç–æ-—Ç–æ —Å —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–º–∏ –Ω–∞–≤—ã–∫–∞–º–∏' },
          { pattern: /(?:–∑–∞—â–∏—Ç–∏—Ç—å|–æ—Ö—Ä–∞–Ω|—Ç–µ–ª–æ—Ö—Ä–∞–Ω–∏—Ç–µ–ª—å)/iu, expert: '–∫—Ç–æ-—Ç–æ, –∫—Ç–æ –º–æ–∂–µ—Ç –∑–∞—â–∏—Ç–∏—Ç—å' }
        ];
        
        for (let i = 0; i < expertPatterns.length; i++) {
          const item = expertPatterns[i];
          if (item.pattern.test(textLower)) {
            this.suggestions.push(`‚ü¶SUGGESTION‚üß –ù—É–∂–µ–Ω ${item.expert}.`);
            break; // Only one expert suggestion per turn
          }
        }
      },
      
      /**
       * Returns current suggestions for context overlay.
       */
      getSuggestions() {
        return this.suggestions;
      }
    },

    // ========== Goals Engine ==========
    // ========== Goals Tracking Engine ==========
    GoalsEngine: {
      /**
       * Analyzes text to extract character goals and store them in state.
       * Only processes goals from important characters and increments stateVersion on changes.
       * @param {string} text - The text to analyze
       * @param {string} actionType - The type of action ('input', 'output', 'retry', etc.)
       */
      analyze(text, actionType){
        const L = LC.lcInit();
        const autoEvergreen = LC.EvergreenEngine;
        if (!autoEvergreen) return;
        if (!autoEvergreen.patterns) autoEvergreen.patterns = autoEvergreen._buildPatterns();
        if (!L.evergreen || !L.evergreen.enabled || actionType === "retry" || !text) return;
        if (!Array.isArray(autoEvergreen.patterns.goals) || autoEvergreen.patterns.goals.length === 0) return;
        
        const originalText = String(text || "");
        const T = LC._normUCached?.(text) ?? LC._normU(text);
        
        // GOALS
        for (let i=0; i<autoEvergreen.patterns.goals.length; i++){
          const p = autoEvergreen.patterns.goals[i];
          p.lastIndex = 0;
          let m;
          try {
            while ((m = p.exec(T)) !== null){
              let charRaw = "";
              let goalText = "";
              
              // Extract character and goal text from match groups
              // Pattern can have character in group 1 or 2 depending on structure
              if (m[1] && m[2]) {
                // Most patterns: character in [1], goal in [2]
                charRaw = String(m[1] || "").trim();
                goalText = String(m[2] || "").trim();
              }
              
              if (!charRaw || !goalText) continue;
              
              const character = autoEvergreen.normalizeCharName(charRaw);
              if (!character || !autoEvergreen.isImportantCharacter(character)) continue;
              
              // Clean up goal text
              goalText = goalText.replace(/[.,!?]+$/, "").trim();
              if (goalText.length < 8 || goalText.length > 200) continue;
              
              // Create unique key for this goal
              const goalKey = `${character}_${Date.now()}_${Math.random().toString(36).slice(2,6)}`;
              
              // Generate a basic plan for the goal
              const plan = this.generateBasicPlan(goalText);
              
              // Store goal in state.lincoln.goals
              L.goals[goalKey] = {
                character: character,
                text: goalText,
                status: "active",
                turnCreated: L.turn,
                plan: plan,
                planProgress: 0 // Tracks which step is currently being worked on
              };
              
              // Increment stateVersion to invalidate context cache
              L.stateVersion++;
            }
          } catch (err) {
            LC.lcWarn?.(`Goal analysis regex error: ${err && err.message ? err.message : err}`);
          }
        }
      },

      /**
       * Generates a basic plan with subtasks for a goal.
       * This creates a simple hierarchical structure based on goal keywords.
       * @param {string} goalText - The goal text
       * @returns {Array} Array of subtask objects
       */
      generateBasicPlan(goalText) {
        if (!goalText) return [];
        
        const textLower = goalText.toLowerCase();
        const plan = [];
        
        // Pattern-based plan generation
        if (textLower.includes('–Ω–∞–π—Ç–∏') || textLower.includes('—É–∑–Ω–∞—Ç—å') || textLower.includes('—Ä–∞—Å–∫—Ä—ã—Ç—å')) {
          plan.push({ text: '–°–æ–±—Ä–∞—Ç—å –ø–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é', status: 'pending' });
          plan.push({ text: '–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∏—Å—Ç–æ—á–Ω–∏–∫–∏', status: 'pending' });
          plan.push({ text: '–°–¥–µ–ª–∞—Ç—å –≤—ã–≤–æ–¥', status: 'pending' });
        } else if (textLower.includes('–ø–æ–±–µ–¥–∏—Ç—å') || textLower.includes('–ø–æ–±–µ–¥—ã') || textLower.includes('—Å–æ—Ä–µ–≤–Ω–æ–≤–∞–Ω–∏–µ')) {
          plan.push({ text: '–ü–æ–¥–≥–æ—Ç–æ–≤–∏—Ç—å—Å—è', status: 'pending' });
          plan.push({ text: '–í—ã–ø–æ–ª–Ω–∏—Ç—å –æ—Å–Ω–æ–≤–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ', status: 'pending' });
          plan.push({ text: '–î–æ–±–∏—Ç—å—Å—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞', status: 'pending' });
        } else if (textLower.includes('–ø–æ–º–æ—á—å') || textLower.includes('–ø–æ–¥–¥–µ—Ä–∂–∞—Ç—å')) {
          plan.push({ text: '–û–ø—Ä–µ–¥–µ–ª–∏—Ç—å, —á—Ç–æ –Ω—É–∂–Ω–æ', status: 'pending' });
          plan.push({ text: '–ü—Ä–µ–¥–ø—Ä–∏–Ω—è—Ç—å –¥–µ–π—Å—Ç–≤–∏–µ', status: 'pending' });
        } else if (textLower.includes('—Å—Ç–∞—Ç—å') || textLower.includes('–¥–æ–±–∏—Ç—å—Å—è')) {
          plan.push({ text: '–ù–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É –Ω–∞–¥ —Ü–µ–ª—å—é', status: 'pending' });
          plan.push({ text: '–î–æ—Å—Ç–∏—á—å –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞', status: 'pending' });
          plan.push({ text: '–ó–∞–≤–µ—Ä—à–∏—Ç—å –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–µ', status: 'pending' });
        } else {
          // Generic plan for unknown goal types
          plan.push({ text: '–ù–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É', status: 'pending' });
          plan.push({ text: '–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å —É—Å–∏–ª–∏—è', status: 'pending' });
          plan.push({ text: '–î–æ—Å—Ç–∏—á—å —Ü–µ–ª–∏', status: 'pending' });
        }
        
        return plan;
      },

      /**
       * Updates plan progress for a goal.
       * Marks current step as in-progress or complete and advances to next step.
       * @param {string} goalKey - The goal key
       * @param {string} status - New status ('in-progress' or 'complete')
       */
      updatePlanProgress(goalKey, status) {
        const L = LC.lcInit();
        if (!L.goals || !L.goals[goalKey]) return;
        
        const goal = L.goals[goalKey];
        if (!goal.plan || !Array.isArray(goal.plan)) return;
        
        const currentStep = goal.planProgress || 0;
        if (currentStep >= goal.plan.length) return; // All steps complete
        
        if (status === 'in-progress') {
          goal.plan[currentStep].status = 'in-progress';
        } else if (status === 'complete') {
          goal.plan[currentStep].status = 'complete';
          goal.planProgress = (goal.planProgress || 0) + 1;
          
          // Check if all steps are complete
          if (goal.planProgress >= goal.plan.length) {
            goal.status = 'completed';
          }
        }
        
        L.stateVersion++;
      }
    },

    // ========== Relations Engine ==========
    RelationsEngine: {
      MODIFIERS: {
        romance: 15,
        conflict: -10,
        betrayal: -25,
        loyalty: 10
      },

      /**
       * Gets the relationship value between two characters.
       * Prioritizes new perceptions system, falls back to legacy evergreen.relations.
       * @param {string} char1 - First character name (perceiver)
       * @param {string} char2 - Second character name (perceived)
       * @returns {number|object} Relationship value (number for legacy, object for multi-vector)
       */
      getRelation(char1, char2) {
        const L = LC.lcInit();
        
        // Try new perceptions system first
        if (L.characters?.[char1]?.perceptions?.[char2]) {
          return L.characters[char1].perceptions[char2];
        }
        
        // Fall back to legacy evergreen.relations
        if (!L.evergreen?.relations?.[char1]?.[char2]) return null;
        return L.evergreen.relations[char1][char2];
      },

      /**
       * Gets a specific vector value from a relationship.
       * Prioritizes perceptions, falls back to legacy numeric relations.
       * @param {string} char1 - First character name (perceiver)
       * @param {string} char2 - Second character name (perceived)
       * @param {string} vector - Vector name (affection, trust, respect, rivalry)
       * @returns {number} Vector value (0-100 scale)
       */
      getVector(char1, char2, vector = 'affection') {
        const rel = this.getRelation(char1, char2);
        if (rel === null) return 50; // Default neutral
        if (typeof rel === 'number') {
          // Legacy numeric - map to affection, derive others
          if (vector === 'affection') return Math.max(0, Math.min(100, rel + 50));
          if (vector === 'trust') return Math.max(0, Math.min(100, rel * 0.8 + 50));
          if (vector === 'respect') return Math.max(0, Math.min(100, rel * 0.7 + 50));
          if (vector === 'rivalry') return Math.max(0, Math.min(100, -rel * 0.6 + 50));
          return 50;
        }
        if (typeof rel === 'object' && rel !== null) {
          return typeof rel[vector] === 'number' ? rel[vector] : 50;
        }
        return 50;
      },

      /**
       * Updates relationship between two characters.
       * Now supports asymmetric perceptions via InformationEngine interpretation.
       * Falls back to legacy symmetric mode if usePerceptions=false.
       * @param {string} char1 - First character name (perceiver)
       * @param {string} char2 - Second character name (perceived)
       * @param {number|object} change - Numeric change for legacy mode, or object with vector changes
       * @param {object} options - {usePerceptions: boolean, interpretedEvent: object}
       */
      updateRelation(char1, char2, change, options) {
        const L = LC.lcInit();
        options = options || {};
        
        // Use perceptions system if:
        // 1. Characters exist in L.characters
        // 2. usePerceptions is not explicitly false
        // 3. Characters have perceptions or qualia_state (indicating they're "full" characters)
        const char1Obj = L.characters?.[char1];
        const char2Obj = L.characters?.[char2];
        const hasFullChars = char1Obj && char2Obj && 
          (char1Obj.perceptions || char1Obj.qualia_state || char2Obj.perceptions || char2Obj.qualia_state);
        const usePerceptions = options.usePerceptions !== false && hasFullChars;
        
        if (usePerceptions) {
          // Modern asymmetric perceptions mode
          const char1Obj = L.characters[char1];
          const char2Obj = L.characters[char2];
          
          // Ensure perceptions objects exist
          if (!char1Obj.perceptions) char1Obj.perceptions = {};
          if (!char2Obj.perceptions) char2Obj.perceptions = {};
          
          // Initialize perceptions if not exist
          if (!char1Obj.perceptions[char2]) {
            char1Obj.perceptions[char2] = { affection: 50, trust: 50, respect: 50, rivalry: 50 };
          }
          if (!char2Obj.perceptions[char1]) {
            char2Obj.perceptions[char1] = { affection: 50, trust: 50, respect: 50, rivalry: 50 };
          }
          
          // If we have an interpreted event, use InformationEngine to apply it
          if (options.interpretedEvent) {
            const event1 = { ...options.interpretedEvent, target: char2 };
            const event2 = { ...options.interpretedEvent, target: char1 };
            
            // Each character interprets the event through their own lens
            const interp1 = LC.InformationEngine.interpret(char1Obj, event1);
            const interp2 = LC.InformationEngine.interpret(char2Obj, event2);
            
            // Apply interpretations asymmetrically
            LC.InformationEngine.updatePerception(char1, char2, interp1);
            LC.InformationEngine.updatePerception(char2, char1, interp2);
          }
          // Otherwise use direct change (backward compatible)
          else if (typeof change === 'number') {
            // Simple numeric change - apply to affection
            char1Obj.perceptions[char2].affection = Math.max(0, Math.min(100, 
              char1Obj.perceptions[char2].affection + change));
            char2Obj.perceptions[char1].affection = Math.max(0, Math.min(100,
              char2Obj.perceptions[char1].affection + change));
          }
          else if (typeof change === 'object' && change !== null) {
            // Multi-vector change
            const vectors = ['affection', 'trust', 'respect', 'rivalry'];
            for (const vector of vectors) {
              if (typeof change[vector] === 'number') {
                char1Obj.perceptions[char2][vector] = Math.max(0, Math.min(100,
                  char1Obj.perceptions[char2][vector] + change[vector]));
                char2Obj.perceptions[char1][vector] = Math.max(0, Math.min(100,
                  char2Obj.perceptions[char1][vector] + change[vector]));
              }
            }
          }
        }
        else {
          // Legacy symmetric mode (for backward compatibility)
          if (!L.evergreen) L.evergreen = {};
          if (!L.evergreen.relations) L.evergreen.relations = {};
          
          // Ensure character relation objects exist
          if (typeof L.evergreen.relations[char1] !== 'object' || L.evergreen.relations[char1] === null) {
            L.evergreen.relations[char1] = {};
          }
          if (typeof L.evergreen.relations[char2] !== 'object' || L.evergreen.relations[char2] === null) {
            L.evergreen.relations[char2] = {};
          }

          // Get current values
          const current1to2 = L.evergreen.relations[char1][char2];
          const current2to1 = L.evergreen.relations[char2][char1];

          if (typeof change === 'number') {
            // Legacy numeric mode - maintain backward compatibility
            const val1 = typeof current1to2 === 'number' ? current1to2 : 50;
            const val2 = typeof current2to1 === 'number' ? current2to1 : 50;
            L.evergreen.relations[char1][char2] = Math.max(-100, Math.min(100, val1 + change));
            L.evergreen.relations[char2][char1] = Math.max(-100, Math.min(100, val2 + change));
            return;
          }

          if (typeof change === 'object' && change !== null) {
            // Multi-vector mode
            // Initialize as multi-vector if not already
            if (typeof current1to2 !== 'object' || current1to2 === null) {
              const oldVal = typeof current1to2 === 'number' ? current1to2 : 0;
              L.evergreen.relations[char1][char2] = {
                affection: Math.max(0, Math.min(100, oldVal + 50)),
                trust: Math.max(0, Math.min(100, oldVal * 0.8 + 50)),
                respect: Math.max(0, Math.min(100, oldVal * 0.7 + 50)),
                rivalry: Math.max(0, Math.min(100, -oldVal * 0.6 + 50))
              };
            } else {
              // Already object, ensure all vectors exist
              if (typeof L.evergreen.relations[char1][char2].affection !== 'number') {
                L.evergreen.relations[char1][char2].affection = 50;
              }
              if (typeof L.evergreen.relations[char1][char2].trust !== 'number') {
                L.evergreen.relations[char1][char2].trust = 50;
              }
              if (typeof L.evergreen.relations[char1][char2].respect !== 'number') {
                L.evergreen.relations[char1][char2].respect = 50;
              }
              if (typeof L.evergreen.relations[char1][char2].rivalry !== 'number') {
                L.evergreen.relations[char1][char2].rivalry = 50;
              }
            }
            
            if (typeof current2to1 !== 'object' || current2to1 === null) {
              const oldVal = typeof current2to1 === 'number' ? current2to1 : 0;
              L.evergreen.relations[char2][char1] = {
                affection: Math.max(0, Math.min(100, oldVal + 50)),
                trust: Math.max(0, Math.min(100, oldVal * 0.8 + 50)),
                respect: Math.max(0, Math.min(100, oldVal * 0.7 + 50)),
                rivalry: Math.max(0, Math.min(100, -oldVal * 0.6 + 50))
              };
            } else {
              // Already object, ensure all vectors exist
              if (typeof L.evergreen.relations[char2][char1].affection !== 'number') {
                L.evergreen.relations[char2][char1].affection = 50;
              }
              if (typeof L.evergreen.relations[char2][char1].trust !== 'number') {
                L.evergreen.relations[char2][char1].trust = 50;
              }
              if (typeof L.evergreen.relations[char2][char1].respect !== 'number') {
                L.evergreen.relations[char2][char1].respect = 50;
              }
              if (typeof L.evergreen.relations[char2][char1].rivalry !== 'number') {
                L.evergreen.relations[char2][char1].rivalry = 50;
              }
            }

            // Apply vector changes
            const vectors = ['affection', 'trust', 'respect', 'rivalry'];
            for (const vector of vectors) {
              if (typeof change[vector] === 'number') {
                L.evergreen.relations[char1][char2][vector] = Math.max(0, Math.min(100, 
                  L.evergreen.relations[char1][char2][vector] + change[vector]));
                L.evergreen.relations[char2][char1][vector] = Math.max(0, Math.min(100,
                  L.evergreen.relations[char2][char1][vector] + change[vector]));
              }
            }
          }
        }
      },

      /**
       * Analyzes text for relationship events between characters.
       * Detects events like conflicts, romance, authority interactions, and achievements.
       * Applies relationship modifiers based on event types and updates character relations.
       * @param {string} text - The text to analyze for relationship events
       * @returns {void}
       */
      analyze(text){
        if (!text) return;
        const L = LC.lcInit();
        if (!L.evergreen) L.evergreen = {};
        if (!L.evergreen.relations) L.evergreen.relations = {};

        const low = toStr(text).toLowerCase();
        
        // Helper function to extract character names from a sentence
        const extractCharacters = (sentence) => {
          const characters = [];
          const normalized = LC._normUCached?.(sentence) ?? LC._normU(sentence);
          
          // Use EvergreenEngine patterns to find character names
          const autoEvergreen = LC.EvergreenEngine;
          if (autoEvergreen && typeof autoEvergreen.normalizeCharName === 'function') {
            // Split sentence into words and try to find character names
            const words = normalized.split(/\s+/);
            for (let i = 0; i < words.length; i++) {
              // Try single word
              let candidate = words[i];
              let normalized_name = autoEvergreen.normalizeCharName(candidate);
              if (normalized_name && normalized_name !== candidate && autoEvergreen.isImportantCharacter(normalized_name)) {
                if (characters.indexOf(normalized_name) === -1) {
                  characters.push(normalized_name);
                }
              }
              
              // Try two-word combinations
              if (i < words.length - 1) {
                candidate = words[i] + ' ' + words[i + 1];
                normalized_name = autoEvergreen.normalizeCharName(candidate);
                if (normalized_name && normalized_name !== candidate && autoEvergreen.isImportantCharacter(normalized_name)) {
                  if (characters.indexOf(normalized_name) === -1) {
                    characters.push(normalized_name);
                  }
                }
              }
              
              // Try three-word combinations
              if (i < words.length - 2) {
                candidate = words[i] + ' ' + words[i + 1] + ' ' + words[i + 2];
                normalized_name = autoEvergreen.normalizeCharName(candidate);
                if (normalized_name && normalized_name !== candidate && autoEvergreen.isImportantCharacter(normalized_name)) {
                  if (characters.indexOf(normalized_name) === -1) {
                    characters.push(normalized_name);
                  }
                }
              }
            }
          }
          return characters;
        };

        // Split text into sentences for better context
        const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);

        // Check for relationship-affecting events
        const relationshipEvents = ['romance', 'conflict', 'betrayal', 'loyalty'];
        for (const type of relationshipEvents) {
          if (!LC._eventPatterns || !LC._eventPatterns[type]) continue;
          const regs = LC._eventPatterns[type];
          for (let i = 0; i < regs.length; i++) {
            if (regs[i].test(low)) {
              const modifier = this.MODIFIERS[type];
              if (!modifier) continue;
              
              // Find the sentence that triggered this event
              for (let s = 0; s < sentences.length; s++) {
                const sentence = sentences[s];
                if (regs[i].test(sentence.toLowerCase())) {
                  const participants = extractCharacters(sentence);
                  
                  // If we found at least 2 characters, update their relationship
                  if (participants.length >= 2) {
                    // Update relationship between first two detected characters
                    const char1 = participants[0];
                    const char2 = participants[1];
                    
                    // Map event types to vector changes (multi-vector mode)
                    let vectorChange = null;
                    if (type === 'romance') {
                      vectorChange = { affection: 12, trust: 8, respect: 5, rivalry: -3 };
                    } else if (type === 'conflict') {
                      vectorChange = { affection: -8, trust: -5, respect: 2, rivalry: 7 };
                    } else if (type === 'betrayal') {
                      vectorChange = { affection: -20, trust: -25, respect: -10, rivalry: 15 };
                    } else if (type === 'loyalty') {
                      vectorChange = { affection: 8, trust: 12, respect: 5, rivalry: -5 };
                    }
                    
                    // Use InformationEngine for subjective interpretation if characters exist
                    if (L.characters?.[char1] && L.characters?.[char2] && LC.InformationEngine) {
                      // Create event objects for interpretation
                      const event = {
                        type: 'relation_event',
                        eventType: type,
                        action: type,
                        rawModifier: modifier,
                        vectorChange: vectorChange,
                        actor: char1,
                        target: char2
                      };
                      
                      // Use interpreted update
                      this.updateRelation(char1, char2, modifier, { interpretedEvent: event });
                    } else {
                      // Fallback to direct update for legacy/non-character entities
                      this.updateRelation(char1, char2, modifier);
                    }
                    
                    // Notify Crucible about significant relationship changes
                    if (LC.Crucible && typeof LC.Crucible.analyzeEvent === 'function') {
                      const finalValue = this.getRelation(char1, char2);
                      LC.Crucible.analyzeEvent({
                        type: 'RELATION_CHANGE',
                        character: char1,
                        otherCharacter: char2,
                        change: modifier,
                        finalValue: finalValue,
                        vectorChange: vectorChange
                      });
                      LC.Crucible.analyzeEvent({
                        type: 'RELATION_CHANGE',
                        character: char2,
                        otherCharacter: char1,
                        change: modifier,
                        finalValue: this.getRelation(char2, char1),
                        vectorChange: vectorChange
                      });
                    }
                    
                    // Increment stateVersion to invalidate context cache
                    L.stateVersion++;
                  }
                  break;
                }
              }
              break;
            }
          }
        }
      }
    },

    // ========== Information Engine (Subjective Reality) ==========
    InformationEngine: {
      /**
       * Interprets an event through a character's subjective lens.
       * The same event can be interpreted differently based on the character's
       * current phenomenal state (qualia_state).
       * @param {object} character - The character object from L.characters
       * @param {object} event - Event object {type, action, actor, target, intensity, rawModifier}
       * @returns {object} Interpreted event with subjective modifiers
       */
      interpret(character, event) {
        if (!character || !event) return event;
        
        // Ensure qualia state exists
        if (!character.qualia_state) {
          character.qualia_state = {
            somatic_tension: 0.3,
            valence: 0.5,
            focus_aperture: 0.7,
            energy_level: 0.8
          };
        }
        
        const qs = character.qualia_state;
        const interpretation = {
          ...event,
          subjectiveModifier: event.rawModifier || 0,
          interpretation: 'neutral'
        };
        
        // Interpret based on event type and qualia state
        if (event.type === 'social') {
          if (event.action === 'compliment' || event.action === 'praise') {
            // High valence (pleasant) ‚Üí interpret as sincere
            if (qs.valence > 0.7) {
              interpretation.interpretation = 'sincere';
              interpretation.subjectiveModifier = (event.rawModifier || 5) * 1.3;
            }
            // High tension ‚Üí interpret as sarcasm/suspicion
            else if (qs.somatic_tension > 0.8) {
              interpretation.interpretation = 'sarcasm';
              interpretation.subjectiveModifier = (event.rawModifier || 5) * 0.3;
              // Actually decrease trust instead
              interpretation.trustModifier = -5;
            }
            // Neutral state
            else {
              interpretation.interpretation = 'polite';
              interpretation.subjectiveModifier = event.rawModifier || 5;
            }
          }
          else if (event.action === 'insult' || event.action === 'criticism') {
            // High tension ‚Üí interpret as threat
            if (qs.somatic_tension > 0.7) {
              interpretation.interpretation = 'threatening';
              interpretation.subjectiveModifier = (event.rawModifier || -10) * 1.5;
            }
            // High valence ‚Üí dismiss as joke
            else if (qs.valence > 0.7) {
              interpretation.interpretation = 'banter';
              interpretation.subjectiveModifier = (event.rawModifier || -10) * 0.4;
            }
            else {
              interpretation.interpretation = 'offensive';
              interpretation.subjectiveModifier = event.rawModifier || -10;
            }
          }
          else if (event.action === 'threat' || event.action === 'aggression') {
            // Always serious but magnitude depends on bravery/energy
            if (qs.energy_level < 0.3) {
              // Low energy ‚Üí feel more threatened
              interpretation.interpretation = 'overwhelming';
              interpretation.subjectiveModifier = (event.rawModifier || -15) * 1.4;
            }
            else {
              interpretation.interpretation = 'hostile';
              interpretation.subjectiveModifier = event.rawModifier || -15;
            }
          }
        }
        else if (event.type === 'relation_event') {
          // For betrayal, loyalty, romance, conflict events
          if (event.eventType === 'betrayal') {
            // High trust personality makes betrayal hurt more
            const trustTrait = character.personality?.trust || 0.5;
            if (trustTrait > 0.7) {
              interpretation.interpretation = 'devastating';
              interpretation.subjectiveModifier = (event.rawModifier || -25) * 1.3;
            } else {
              interpretation.interpretation = 'expected';
              interpretation.subjectiveModifier = (event.rawModifier || -25) * 0.9;
            }
          }
          else if (event.eventType === 'loyalty') {
            // Cynical characters (low trust) appreciate loyalty more
            const trustTrait = character.personality?.trust || 0.5;
            if (trustTrait < 0.3) {
              interpretation.interpretation = 'surprising';
              interpretation.subjectiveModifier = (event.rawModifier || 10) * 1.4;
            } else {
              interpretation.interpretation = 'appreciated';
              interpretation.subjectiveModifier = event.rawModifier || 10;
            }
          }
        }
        
        return interpretation;
      },
      
      /**
       * Updates a character's perception of another based on interpreted event.
       * This creates asymmetric, subjective perceptions.
       * @param {string} perceiver - The character doing the perceiving
       * @param {string} perceived - The character being perceived
       * @param {object} interpretation - Result from interpret()
       */
      updatePerception(perceiver, perceived, interpretation) {
        const L = LC.lcInit();
        if (!L.characters[perceiver]) return;
        if (!L.characters[perceived]) return;
        
        const char = L.characters[perceiver];
        if (!char.perceptions) char.perceptions = {};
        
        // Initialize perception if not exists
        if (!char.perceptions[perceived]) {
          char.perceptions[perceived] = {
            affection: 50,
            trust: 50,
            respect: 50,
            rivalry: 50
          };
        }
        
        const perc = char.perceptions[perceived];
        
        // Apply subjective modifier to affection (main relationship value)
        if (typeof interpretation.subjectiveModifier === 'number') {
          perc.affection = Math.max(0, Math.min(100, perc.affection + interpretation.subjectiveModifier));
        }
        
        // Apply trust modifier if specified
        if (typeof interpretation.trustModifier === 'number') {
          perc.trust = Math.max(0, Math.min(100, perc.trust + interpretation.trustModifier));
        }
        
        // Apply vector changes if provided
        if (interpretation.vectorChange) {
          const vectors = ['affection', 'trust', 'respect', 'rivalry'];
          for (const vector of vectors) {
            if (typeof interpretation.vectorChange[vector] === 'number') {
              perc[vector] = Math.max(0, Math.min(100, perc[vector] + interpretation.vectorChange[vector]));
            }
          }
        }
      }
    },

    // ========== Mood Engine ==========
    // ========== Knowledge Engine (Secrets System) ==========
    KnowledgeEngine: {
      // Extract character names from scene focus line
      extractFocusCharacters(contextText){
        if (!contextText) return [];
        const focusMatch = contextText.match(/‚ü¶SCENE‚üß\s+Focus\s+on:\s*([^\n]+)/i);
        if (!focusMatch) return [];
        
        const focusLine = focusMatch[1];
        const characters = [];
        const parts = focusLine.split(/,\s*/);
        
        for (let i = 0; i < parts.length; i++) {
          const name = parts[i].trim();
          if (name) characters.push(name);
        }
        
        return characters;
      },
      
      // Check if a secret should be visible to current focus
      isSecretVisible(secret, focusCharacters){
        if (!secret || !secret.known_by || !Array.isArray(secret.known_by)) return false;
        if (!focusCharacters || focusCharacters.length === 0) return false;
        
        // Check if any focus character knows this secret
        for (let i = 0; i < focusCharacters.length; i++) {
          const focusChar = focusCharacters[i].toLowerCase().trim();
          for (let j = 0; j < secret.known_by.length; j++) {
            const knownBy = secret.known_by[j].toLowerCase().trim();
            if (focusChar === knownBy) return true;
          }
        }
        
        return false;
      }
    },

    // ========== Character Mood Tracking Engine ==========
    MoodEngine: {
      /**
       * Analyzes text to detect character mood changes and stores them with expiration.
       * Detects moods like angry, happy, scared, tired, wounded from text patterns.
       * Increments stateVersion when moods are detected to invalidate context cache.
       * @param {string} text - The text to analyze
       */
      analyze(text){
        if (!text) return;
        const L = LC.lcInit();
        if (!L.character_status) L.character_status = {};

        const low = toStr(text).toLowerCase();
        
        // Helper to extract character name from text around a match
        const findCharacterInText = (text) => {
          const autoEvergreen = LC.EvergreenEngine;
          if (!autoEvergreen || typeof autoEvergreen.normalizeCharName !== 'function') return null;
          
          // Get all words from the text
          const normalized = LC._normUCached?.(text) ?? LC._normU(text);
          const words = normalized.split(/\s+/);
          
          // Try to find character names by checking each word/phrase
          for (let i = 0; i < words.length; i++) {
            // Try three-word combinations first (e.g., "–ú–∏—Å—Å–∏—Å –ì—Ä–µ–π—Å–æ–Ω")
            if (i < words.length - 2) {
              const threeWord = words[i] + ' ' + words[i + 1] + ' ' + words[i + 2];
              const normalized3 = autoEvergreen.normalizeCharName(threeWord);
              if (normalized3 && autoEvergreen.isImportantCharacter(normalized3)) {
                return normalized3;
              }
            }
            
            // Try two-word combinations (e.g., "–ú–∞–∫—Å–∏–º –ë–µ—Ä–≥–º–∞–Ω")
            if (i < words.length - 1) {
              const twoWord = words[i] + ' ' + words[i + 1];
              const normalized2 = autoEvergreen.normalizeCharName(twoWord);
              if (normalized2 && autoEvergreen.isImportantCharacter(normalized2)) {
                return normalized2;
              }
            }
            
            // Try single word (e.g., "–ú–∞–∫—Å–∏–º", "–ú–∞–∫—Å")
            const oneWord = words[i];
            const normalized1 = autoEvergreen.normalizeCharName(oneWord);
            if (normalized1 && autoEvergreen.isImportantCharacter(normalized1)) {
              return normalized1;
            }
          }
          
          return null;
        };

        // Split text into sentences
        const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);

        // Mood patterns: Russian-only markers
        const moodPatterns = [
          // Angry - Russian
          { regex: /—Ä–∞–∑–æ–∑–ª–∏(–ª(?:—Å—è|—Å—å)?|–≤—à)/i, mood: 'angry', reason: '—Å—Å–æ—Ä–∞' },
          { regex: /(?:–±—ã–ª|–±—ã–ª–∞|—Å—Ç–∞–ª|—Å—Ç–∞–ª–∞)\s+(?:–∑–æ–ª|–∑–ª–∞|—Å–µ—Ä–¥–∏—Ç|—Å–µ—Ä–¥–∏—Ç–∞|—Ä–∞–∑–¥—Ä–∞–∂–µ–Ω|—Ä–∞–∑–¥—Ä–∞–∂–µ–Ω–∞)/i, mood: 'angry', reason: '–∫–æ–Ω—Ñ–ª–∏–∫—Ç' },
          { regex: /(?:–≤ —è—Ä–æ—Å—Ç–∏|–≤ –≥–Ω–µ–≤–µ|–≤ –±–µ—à–µ–Ω—Å—Ç–≤–µ)/i, mood: 'angry', reason: '—è—Ä–æ—Å—Ç—å' },
          { regex: /(?:—Ä–∞—Å—Å–µ—Ä–¥–∏|—Ä–∞–∑—ä—è—Ä–∏)/i, mood: 'angry', reason: '—Ä–∞–∑–¥—Ä–∞–∂–µ–Ω–∏–µ' },
          
          // Happy - Russian
          { regex: /(?:–±—ã–ª|–±—ã–ª–∞|—Å—Ç–∞–ª|—Å—Ç–∞–ª–∞)\s+(?:—Å—á–∞—Å—Ç–ª–∏–≤|—Å—á–∞—Å—Ç–ª–∏–≤–∞|—Ä–∞–¥|—Ä–∞–¥–∞|–¥–æ–≤–æ–ª–µ–Ω|–¥–æ–≤–æ–ª—å–Ω–∞)/i, mood: 'happy', reason: '—Ä–∞–¥–æ—Å—Ç—å' },
          { regex: /(?:–æ–±—Ä–∞–¥–æ–≤–∞|–æ–±—Ä–∞–¥–æ–≤–∞–ª|–æ–±—Ä–∞–¥–æ–≤–∞–ª–∞|–≤–æ–∑–ª–∏–∫–æ–≤–∞)/i, mood: 'happy', reason: '—Ö–æ—Ä–æ—à–∏–µ –Ω–æ–≤–æ—Å—Ç–∏' },
          { regex: /(?:–≤ –≤–æ—Å—Ç–æ—Ä–≥–µ|–≤ –ø—Ä–∏–ø–æ–¥–Ω—è—Ç–æ–º –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–∏)/i, mood: 'happy', reason: '—É—Å–ø–µ—Ö' },
          
          // Scared - Russian
          { regex: /(?:–∏—Å–ø—É–≥–∞|–Ω–∞–ø—É–≥–∞|–ø–µ—Ä–µ–ø—É–≥–∞|—É—Å—Ç—Ä–∞—à–∏)/i, mood: 'scared', reason: '—Å—Ç—Ä–∞—Ö' },
          { regex: /(?:–±—ã–ª|–±—ã–ª–∞|—Å—Ç–∞–ª|—Å—Ç–∞–ª–∞)\s+(?:–Ω–∞–ø—É–≥–∞–Ω|–Ω–∞–ø—É–≥–∞–Ω–∞|–∏—Å–ø—É–≥–∞–Ω|–∏—Å–ø—É–≥–∞–Ω–∞)/i, mood: 'scared', reason: '—É–≥—Ä–æ–∑–∞' },
          { regex: /(?:–≤ —Å—Ç—Ä–∞—Ö–µ|–≤ —É–∂–∞—Å–µ|–≤ –ø–∞–Ω–∏–∫–µ)/i, mood: 'scared', reason: '–æ–ø–∞—Å–Ω–æ—Å—Ç—å' },
          
          // Tired - Russian
          { regex: /(?:—É—Å—Ç–∞–ª|—É—Å—Ç–∞–ª–∞|–∏–∑–Ω–µ–º–æ–≥|–∏–∑–Ω–µ–º–æ–≥–ª–∞|–≤—ã–º–æ—Ç–∞–ª|–≤—ã–º–æ—Ç–∞–ª–∞)/i, mood: 'tired', reason: '—É—Å—Ç–∞–ª–æ—Å—Ç—å' },
          { regex: /(?:–±—ã–ª|–±—ã–ª–∞|—Å—Ç–∞–ª|—Å—Ç–∞–ª–∞)\s+(?:—É—Å—Ç–∞–≤—à|–∏–∑–º—É—á–µ–Ω|–∏–∑–º—É—á–µ–Ω–∞|–∏—Å—Ç–æ—â–µ–Ω|–∏—Å—Ç–æ—â–µ–Ω–∞)/i, mood: 'tired', reason: '–∏—Å—Ç–æ—â–µ–Ω–∏–µ' },
          { regex: /(?:–±–µ–∑ —Å–∏–ª|–∏–∑–Ω—É—Ä–µ–Ω|–∏–∑–Ω—É—Ä–µ–Ω–∞)/i, mood: 'tired', reason: '–ø–µ—Ä–µ–Ω–∞–ø—Ä—è–∂–µ–Ω–∏–µ' },
          
          // Wounded/Hurt - Russian
          { regex: /(?:—Ä–∞–Ω–µ–Ω|—Ä–∞–Ω–µ–Ω–∞|–ø–æ—Ä–∞–Ω–µ–Ω|–ø–æ—Ä–∞–Ω–µ–Ω–∞|—Ç—Ä–∞–≤–º–∏—Ä–æ–≤–∞–Ω|—Ç—Ä–∞–≤–º–∏—Ä–æ–≤–∞–Ω–∞)/i, mood: 'wounded', reason: '—Ä–∞–Ω–µ–Ω–∏–µ' },
          { regex: /(?:–±—ã–ª|–±—ã–ª–∞)\s+(?:—Ä–∞–Ω–µ–Ω|—Ä–∞–Ω–µ–Ω–∞|–∏–∑–±–∏—Ç|–∏–∑–±–∏—Ç–∞)/i, mood: 'wounded', reason: '—Ç—Ä–∞–≤–º–∞' },
          { regex: /(?:–ø–æ–ª—É—á–∏–ª|–ø–æ–ª—É—á–∏–ª–∞)\s+(?:—Ä–∞–Ω—É|—Ç—Ä–∞–≤–º—É|—Ä–∞–Ω–µ–Ω–∏–µ|—É–≤–µ—á—å–µ)/i, mood: 'wounded', reason: '–ø–æ–≤—Ä–µ–∂–¥–µ–Ω–∏–µ' },
          
          // Embarrassed/Awkward - Russian
          { regex: /—Å–º—É—Ç–∏(–ª(?:—Å—è|—Å—å)?|–≤—à)/i, mood: 'embarrassed', reason: '—Å–º—É—â–µ–Ω–∏–µ' },
          { regex: /–ø–æ–∫—Ä–∞—Å–Ω–µ–ª(?:–∞)?/i, mood: 'embarrassed', reason: '–Ω–µ–ª–æ–≤–∫–æ—Å—Ç—å' },
          { regex: /(?:—Å—Ç–∞–ª–æ|–±—ã–ª–æ)\s+–Ω–µ–ª–æ–≤–∫–æ/i, mood: 'embarrassed', reason: '–Ω–µ—É–¥–æ–±—Å—Ç–≤–æ' },
          { regex: /–ø–æ—á—É–≤—Å—Ç–≤–æ–≤–∞–ª(?:–∞)?\s+—Å–µ–±—è\s+–Ω–µ\s+–≤\s+—Å–≤–æ–µ–π\s+—Ç–∞—Ä–µ–ª–∫–µ/i, mood: 'embarrassed', reason: '–¥–∏—Å–∫–æ–º—Ñ–æ—Ä—Ç' },
          { regex: /(?:–≤\s+)?—Å–º—É—â–µ–Ω–∏(?:–∏|–µ|–µ–º)/i, mood: 'embarrassed', reason: '—Å–º—É—â–µ–Ω–∏–µ' },
          
          // Jealous - Russian
          { regex: /–ø—Ä–∏—Ä–µ–≤–Ω–æ–≤–∞–ª(?:–∞)?/i, mood: 'jealous', reason: '—Ä–µ–≤–Ω–æ—Å—Ç—å' },
          { regex: /–ø–æ—á—É–≤—Å—Ç–≤–æ–≤–∞–ª(?:–∞)?\s+—É–∫–æ–ª\s+—Ä–µ–≤–Ω–æ—Å—Ç–∏/i, mood: 'jealous', reason: '—Ä–µ–≤–Ω–æ—Å—Ç—å' },
          { regex: /–∑–∞—Ä–µ–≤–Ω–æ–≤–∞–ª(?:–∞)?/i, mood: 'jealous', reason: '—Ä–µ–≤–Ω–æ—Å—Ç—å' },
          { regex: /(?:–µ–≥–æ|–µ—ë|–µ–µ)\s+—Å—ä–µ–¥–∞–ª–∞\s+—Ä–µ–≤–Ω–æ—Å—Ç—å/i, mood: 'jealous', reason: '—Ä–µ–≤–Ω–æ—Å—Ç—å' },
          { regex: /(?:–±—ã–ª|–±—ã–ª–∞)\s+—Ä–µ–≤–Ω–∏–≤(?:—ã–º|–æ–π)/i, mood: 'jealous', reason: '—Ä–µ–≤–Ω–æ—Å—Ç—å' },
          { regex: /(?:–∏–∑|–æ—Ç)\s+—Ä–µ–≤–Ω–æ—Å—Ç(?:–∏|—å)/i, mood: 'jealous', reason: '—Ä–µ–≤–Ω–æ—Å—Ç—å' },
          
          // Offended - Russian
          { regex: /–æ–±–∏–¥–µ–ª(?:—Å—è|–∞—Å—å)/i, mood: 'offended', reason: '–æ–±–∏–¥–∞' },
          { regex: /(?:–µ–≥–æ|–µ—ë|–µ–µ)\s+–∑–∞–¥–µ–ª–∏\s+—Å–ª–æ–≤–∞/i, mood: 'offended', reason: '–æ–±–∏–¥–∞' },
          { regex: /(?:–æ–Ω–∞|–æ–Ω)\s+–Ω–∞–¥—É–ª–∞—Å—å/i, mood: 'offended', reason: '–æ–±–∏–¥–∞' },
          { regex: /–æ–±–∏–∂–µ–Ω–Ω–æ\s+(?:–æ—Ç–≤–µ—Ç–∏–ª|–æ—Ç–≤–µ—Ç–∏–ª–∞|—Å–∫–∞–∑–∞–ª|—Å–∫–∞–∑–∞–ª–∞)/i, mood: 'offended', reason: '–æ–±–∏–¥–∞' },
          { regex: /(?:–±—ã–ª|–±—ã–ª–∞)\s+–æ–±–∏–∂–µ–Ω(?:–∞)?/i, mood: 'offended', reason: '–æ–±–∏–¥–∞' },
          { regex: /–ø–æ—á—É–≤—Å—Ç–≤–æ–≤–∞–ª(?:–∞)?\s+–æ–±–∏–¥—É/i, mood: 'offended', reason: '–æ–±–∏–¥–∞' },
          
          // Guilty - Russian
          { regex: /–ø–æ—á—É–≤—Å—Ç–≤–æ–≤–∞–ª(?:–∞)?\s+—Å–µ–±—è\s+–≤–∏–Ω–æ–≤–∞—Ç(?:—ã–º|–æ–π)/i, mood: 'guilty', reason: '–≤–∏–Ω–∞' },
          { regex: /(?:–µ–≥–æ|–µ—ë|–µ–µ)\s+–º—É—á–∏–ª–∞\s+—Å–æ–≤–µ—Å—Ç—å/i, mood: 'guilty', reason: '—Å–æ–≤–µ—Å—Ç—å' },
          { regex: /—Å–æ–∂–∞–ª–µ–ª(?:–∞)?\s+–æ\s+—Å–æ–¥–µ—è–Ω–Ω–æ–º/i, mood: 'guilty', reason: '—Å–æ–∂–∞–ª–µ–Ω–∏–µ' },
          { regex: /(?:–±—ã–ª|–±—ã–ª–∞)\s+–≤–∏–Ω–æ–≤–∞—Ç(?:—ã–º|–æ–π)/i, mood: 'guilty', reason: '–≤–∏–Ω–∞' },
          { regex: /(?:—á—É–≤—Å—Ç–≤–æ|–æ—â—É—â–µ–Ω–∏–µ)\s+–≤–∏–Ω—ã/i, mood: 'guilty', reason: '–≤–∏–Ω–∞' },
          { regex: /(?:–º—É—á–∏–ª|—Ç–µ—Ä–∑–∞–ª)(?:–∞|–æ)?\s+(?:—á—É–≤—Å—Ç–≤–æ\s+)?–≤–∏–Ω(?:–∞|—ã)/i, mood: 'guilty', reason: '–≤–∏–Ω–∞' },
          
          // Disappointed - Russian
          { regex: /—Ä–∞–∑–æ—á–∞—Ä–æ–≤–∞–ª(?:—Å—è|–∞—Å—å)\s+–≤\s+(?:–Ω–µ–º|–Ω–µ–π|–Ω–∏—Ö)/i, mood: 'disappointed', reason: '—Ä–∞–∑–æ—á–∞—Ä–æ–≤–∞–Ω–∏–µ' },
          { regex: /—ç—Ç–æ\s+–±—ã–ª–æ\s+–ø–æ–ª–Ω–æ–µ\s+—Ä–∞–∑–æ—á–∞—Ä–æ–≤–∞–Ω–∏–µ/i, mood: 'disappointed', reason: '—Ä–∞–∑–æ—á–∞—Ä–æ–≤–∞–Ω–∏–µ' },
          { regex: /–∏—Å–ø—ã—Ç–∞–ª(?:–∞)?\s+—Ä–∞–∑–æ—á–∞—Ä–æ–≤–∞–Ω–∏–µ/i, mood: 'disappointed', reason: '—Ä–∞–∑–æ—á–∞—Ä–æ–≤–∞–Ω–∏–µ' },
          { regex: /(?:–±—ã–ª|–±—ã–ª–∞)\s+—Ä–∞–∑–æ—á–∞—Ä–æ–≤–∞–Ω(?:–∞)?/i, mood: 'disappointed', reason: '—Ä–∞–∑–æ—á–∞—Ä–æ–≤–∞–Ω–∏–µ' },
          { regex: /–ø–æ—á—É–≤—Å—Ç–≤–æ–≤–∞–ª(?:–∞)?\s+—Ä–∞–∑–æ—á–∞—Ä–æ–≤–∞–Ω–∏–µ/i, mood: 'disappointed', reason: '—Ä–∞–∑–æ—á–∞—Ä–æ–≤–∞–Ω–∏–µ' }
        ];

        // Check each sentence for mood markers
        for (let s = 0; s < sentences.length; s++) {
          const sentence = sentences[s];
          const sentenceLow = sentence.toLowerCase();
          
          for (let p = 0; p < moodPatterns.length; p++) {
            const pattern = moodPatterns[p];
            if (pattern.regex.test(sentenceLow)) {
              // Try to find a character name in this sentence
              const character = findCharacterInText(sentence);
              
              if (character) {
                const mood = pattern.mood;
                const reason = pattern.reason;
                const expires = (L.turn || 0) + 5;
                
                // Store mood status
                L.character_status[character] = {
                  mood: mood,
                  reason: reason,
                  expires: expires
                };
                
                // Increment stateVersion to invalidate context cache
                L.stateVersion++;
                
                break; // Found a mood for this sentence
              }
            }
          }
        }
      }
    },

    // ========== Environment Engine ==========
    EnvironmentEngine: {
      /**
       * Analyzes text for location changes and returns detected location.
       * @param {string} text - The text to analyze
       * @returns {string|null} Detected location or null
       */
      detectLocation(text) {
        if (!text) return null;
        const low = text.toLowerCase();
        
        // Location patterns (Russian only)
        const locationPatterns = [
          { regex: /–≤\s+(–∫–ª–∞—Å—Å(?:–µ|–Ω–æ–π)|–∞—É–¥–∏—Ç–æ—Ä–∏(?:–∏|—é))/i, location: 'classroom' },
          { regex: /(?:–≤|–Ω–∞)\s+(—Å—Ç–æ–ª–æ–≤(?:–∞—è|—É—é|–æ–π)|–∫–∞—Ñ–µ—Ç–µ—Ä–∏(?:–∏|–π))/i, location: 'cafeteria' },
          { regex: /(?:–≤|–Ω–∞)\s+(—Å–ø–æ—Ä—Ç–∑–∞–ª(?:–µ|)|—Ç—Ä–µ–Ω–∞–∂—ë—Ä–Ω(?:—ã–π|–æ–º)\s+–∑–∞–ª)/i, location: 'gym' },
          { regex: /(?:–≤|–Ω–∞)\s+(–±–∏–±–ª–∏–æ—Ç–µ–∫(?:–∞|–µ|—É)|—á–∏—Ç–∞–ª—å–Ω(?:—ã–π|–æ–º)\s+–∑–∞–ª)/i, location: 'library' },
          { regex: /(?:–≤|–Ω–∞)\s+(–∫–æ—Ä–∏–¥–æ—Ä(?:–µ|)|—Ö–æ–ª–ª(?:–µ|))/i, location: 'hallway' },
          { regex: /(?:–≤|–Ω–∞)\s+(?:—à–∫–æ–ª—å–Ω(?:–æ–º|—ã–π)|–∏–≥—Ä–æ–≤(?:–æ–º|–∞—è))\s+(–ø–ª–æ—â–∞–¥–∫(?:–∞|–µ|—É)|–¥–≤–æ—Ä(?:–µ|))/i, location: 'schoolyard' },
          { regex: /(?:–≤|–Ω–∞)\s+(–ø–∞—Ä–∫(?:–µ|)|—Å–∞–¥(?:—É|))/i, location: 'park' },
          { regex: /–¥–æ–º(?:–∞|–µ|—É)|–∫–≤–∞—Ä—Ç–∏—Ä(?:–∞|–µ|—É)/i, location: 'home' },
          { regex: /(?:–≤|–Ω–∞)\s+—É–ª–∏—Ü(?:–∞|–µ|—É)/i, location: 'street' }
        ];
        
        for (const pattern of locationPatterns) {
          if (pattern.regex.test(low)) {
            return pattern.location;
          }
        }
        
        return null;
      },
      
      /**
       * Changes weather with optional notification.
       * Weather changes may affect character moods.
       * @param {string} newWeather - New weather state (clear, rain, snow, storm, fog)
       * @param {boolean} [silent=false] - If true, no system message is generated
       */
      changeWeather(newWeather, silent = false) {
        const L = LC.lcInit();
        const validWeather = ['clear', 'rain', 'snow', 'storm', 'fog', 'cloudy'];
        
        if (!validWeather.includes(newWeather)) {
          LC.lcWarn?.(`Invalid weather: ${newWeather}`);
          return;
        }
        
        const oldWeather = L.environment.weather;
        L.environment.weather = newWeather;
        L.stateVersion++;
        
        if (!silent) {
          const weatherDesc = {
            clear: '‚òÄÔ∏è –Ø—Å–Ω–∞—è –ø–æ–≥–æ–¥–∞',
            rain: 'üåßÔ∏è –î–æ–∂–¥—å',
            snow: '‚ùÑÔ∏è –°–Ω–µ–≥',
            storm: '‚õàÔ∏è –ì—Ä–æ–∑–∞',
            fog: 'üå´Ô∏è –¢—É–º–∞–Ω',
            cloudy: '‚òÅÔ∏è –û–±–ª–∞—á–Ω–æ'
          };
          LC.lcSys({ text: `–ü–æ–≥–æ–¥–∞ –∏–∑–º–µ–Ω–∏–ª–∞—Å—å: ${weatherDesc[newWeather] || newWeather}`, level: 'director' });
        }
        
        // Weather may affect moods (with probability)
        this.applyWeatherMoodEffects(newWeather);
      },
      
      /**
       * Apply weather effects on character moods (probabilistic).
       * @param {string} weather - Current weather
       */
      applyWeatherMoodEffects(weather) {
        const L = LC.lcInit();
        if (!L.characters) return;
        
        // Weather mood effects (20% chance to apply)
        if (Math.random() > 0.2) return;
        
        const moodEffects = {
          rain: { mood: 'melancholic', reason: '–¥–æ–∂–¥–ª–∏–≤–∞—è –ø–æ–≥–æ–¥–∞' },
          storm: { mood: 'anxious', reason: '–≥—Ä–æ–∑–∞' },
          clear: { mood: 'cheerful', reason: '—Ö–æ—Ä–æ—à–∞—è –ø–æ–≥–æ–¥–∞' },
          snow: { mood: 'excited', reason: '—Å–Ω–µ–≥' }
        };
        
        const effect = moodEffects[weather];
        if (!effect) return;
        
        // Apply to one random active character
        const activeChars = Object.keys(L.characters).filter(name => {
          const char = L.characters[name];
          return char.lastSeen && (L.turn - char.lastSeen) < 5;
        });
        
        if (activeChars.length > 0) {
          const randomChar = activeChars[Math.floor(Math.random() * activeChars.length)];
          if (!L.character_status) L.character_status = {};
          L.character_status[randomChar] = {
            mood: effect.mood,
            reason: effect.reason,
            expires: L.turn + 3
          };
          L.stateVersion++;
          LC.lcSys({ text: `${randomChar} affected by weather`, level: 'director' });
        }
      },
      
      /**
       * Analyzes text for environment changes and updates state.
       * @param {string} text - The text to analyze
       */
      analyze(text) {
        if (!text) return;
        const L = LC.lcInit();
        
        // Detect location change
        const newLocation = this.detectLocation(text);
        if (newLocation && newLocation !== L.environment.location) {
          L.environment.location = newLocation;
          L.stateVersion++;
          LC.lcSys({ text: `Location: ${newLocation}`, level: 'director' });
        }
      }
    },

    // ========== Gossip Engine ==========
    GossipEngine: {
      /**
       * Generates a unique ID for a rumor.
       * @returns {string} Unique rumor ID
       */
      generateRumorId() {
        return 'rumor_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      },
      
      /**
       * Observer sub-module: watches for events and generates gossip.
       * Uses "Interpretation Matrix" based on witness's relationship to participants.
       * @param {string} text - The text to analyze for gossip-worthy events
       */
      Observer: {
        /**
         * Detects gossip-worthy events in text and creates rumors.
         * @param {string} text - Text to analyze
         */
        observe(text) {
          if (!text) return;
          const L = LC.lcInit();
          if (!L.rumors) L.rumors = [];
          if (!L.characters) L.characters = {};
          
          const low = text.toLowerCase();
          
          // Gossip-worthy event patterns (Russian-only)
          const eventPatterns = [
            // Romance
            { regex: /([\p{L}\s]+)\s+(?:–ø–æ—Ü–µ–ª–æ–≤–∞(?:–ª|–ª–∞|–ª—Å—è|–ª–∞—Å—å)|—Ü–µ–ª–æ–≤–∞(?:–ª|–ª–∞))\s+([\p{L}\s]+)/iu, 
              type: 'romance', spin: 'neutral' },
            { regex: /([\p{L}\s]+)\s+(?:–ø—Ä–∏–∑–Ω–∞–ª(?:—Å—è|–∞—Å—å)|–ø—Ä–∏–∑–Ω–∞–ª–∞—Å—å)\s+–≤\s+–ª—é–±–≤–∏\s+([\p{L}\s]+)/iu, 
              type: 'romance', spin: 'neutral' },
              
            // Conflict
            { regex: /([\p{L}\s]+)\s+(?:–ø–æ–¥—Ä–∞–ª(?:—Å—è|–∞—Å—å)|–¥—Ä–∞–ª(?:—Å—è|–∞—Å—å)|–ø–æ—Å—Å–æ—Ä–∏–ª(?:—Å—è|–∞—Å—å))\s+—Å\s+([\p{L}\s]+)/iu, 
              type: 'conflict', spin: 'negative' },
              
            // Betrayal
            { regex: /([\p{L}\s]+)\s+(?:–ø—Ä–µ–¥–∞–ª(?:–∞|)|–æ–±–º–∞–Ω—É–ª(?:–∞|)|–∏–∑–º–µ–Ω–∏–ª(?:–∞|))\s+([\p{L}\s]+)/iu, 
              type: 'betrayal', spin: 'negative' },
              
            // Achievement
            { regex: /([\p{L}\s]+)\s+(?:–≤—ã–∏–≥—Ä–∞–ª(?:–∞|)|–ø–æ–±–µ–¥–∏–ª(?:–∞|)|–ø–æ–ª—É—á–∏–ª(?:–∞|)\s+–Ω–∞–≥—Ä–∞–¥—É)/iu, 
              type: 'achievement', spin: 'positive' },
            
            // Bad grade
            { regex: /([\p{L}\s]+)\s+(?:–ø–æ–ª—É—á–∏–ª(?:–∞|)\s+–¥–≤–æ–π–∫—É|–ø—Ä–æ–≤–∞–ª–∏–ª(?:–∞|)\s+–∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—É—é)/iu, 
              type: 'academic_failure', spin: 'neutral' },
            
            // Teacher meeting
            { regex: /([\p{L}\s]+)\s+(?:–≤—ã–∑–≤–∞–ª–∏\s+–∫\s+–¥–∏—Ä–µ–∫—Ç–æ—Ä—É|—Ä–∞–∑–≥–æ–≤–∞—Ä–∏–≤–∞–ª(?:–∞|)\s+—Å\s+—É—á–∏—Ç–µ–ª–µ–º\s+–ø–æ—Å–ª–µ\s+—É—Ä–æ–∫–æ–≤)/iu, 
              type: 'teacher_meeting', spin: 'neutral' },
            
            // Skipping class
            { regex: /([\p{L}\s]+)\s+(?:–ø—Ä–æ–≥—É–ª—è–ª(?:–∞|)\s+—É—Ä–æ–∫|–Ω–µ\s+–ø—Ä–∏—à–µ–ª(?:–∞|)?\s+–Ω–∞\s+(?:–ø–∞—Ä—É|—É—Ä–æ–∫))/iu, 
              type: 'truancy', spin: 'neutral' }
          ];
          
          for (const pattern of eventPatterns) {
            const match = text.match(pattern.regex);
            if (match) {
              // Extract character names
              const autoEvergreen = LC.EvergreenEngine;
              const char1Raw = match[1] ? match[1].trim() : null;
              const char2Raw = match[2] ? match[2].trim() : null;
              
              if (!char1Raw) continue;
              
              // Normalize character names
              const char1 = autoEvergreen?.normalizeCharName?.(char1Raw) || char1Raw;
              const char2 = char2Raw ? (autoEvergreen?.normalizeCharName?.(char2Raw) || char2Raw) : null;
              
              // Check if characters are important
              const char1Important = autoEvergreen?.isImportantCharacter?.(char1);
              const char2Important = char2 ? autoEvergreen?.isImportantCharacter?.(char2) : false;
              
              if (!char1Important && !char2Important) continue;
              
              // Create rumor
              const rumor = {
                id: LC.GossipEngine.generateRumorId(),
                text: match[0],
                type: pattern.type,
                subject: char1,
                target: char2,
                spin: pattern.spin,
                turn: L.turn,
                knownBy: [], // Will be populated by witnesses
                distortion: 0,
                verified: false,
                status: 'ACTIVE'
              };
              
              // Find witnesses (characters active in recent turns)
              const witnesses = Object.keys(L.characters).filter(name => {
                const char = L.characters[name];
                return char.lastSeen && (L.turn - char.lastSeen) <= 2 && name !== char1 && name !== char2;
              });
              
              // Apply interpretation matrix based on witness relationships
              for (const witness of witnesses) {
                rumor.knownBy.push(witness);
                // Interpretation affects spin based on witness's relationship to participants
                this.applyInterpretationMatrix(rumor, witness);
              }
              
              L.rumors.push(rumor);
              L.stateVersion++;
              
              LC.lcSys({ 
                text: `üó£Ô∏è –ù–æ–≤—ã–π —Å–ª—É—Ö: "${rumor.text}" (witnessed by ${witnesses.length} people)`, 
                level: 'director' 
              });
              
              break; // Only one rumor per analyze call
            }
          }
        },
        
        /**
         * Applies interpretation matrix to modify rumor based on witness's relationship and mood.
         * @param {object} rumor - The rumor object
         * @param {string} witness - Witness character name
         */
        applyInterpretationMatrix(rumor, witness) {
          const L = LC.lcInit();
          if (!L.evergreen?.relations) return;
          
          // Get witness's relationship to subject
          const relationKey1 = `${witness}‚Üí${rumor.subject}`;
          const relationKey2 = `${rumor.subject}‚Üí${witness}`;
          const relation1 = L.evergreen.relations[relationKey1] || 0;
          const relation2 = L.evergreen.relations[relationKey2] || 0;
          const avgRelation = (relation1 + relation2) / 2;
          
          // Get witness's current mood
          const witnessMood = L.character_status?.[witness]?.mood;
          
          // Apply mood-based interpretation modifiers
          if (witnessMood === 'angry') {
            // Angry witnesses interpret events more aggressively
            rumor.spin = 'negative';
            rumor.distortion += 0.5;
          } else if (witnessMood === 'jealous') {
            // Jealous witnesses interpret events negatively against the subject
            if (rumor.type === 'romance' || rumor.type === 'achievement') {
              rumor.spin = 'negative';
              rumor.distortion += 0.3;
            }
          }
          
          // Base interpretation on relationship
          // Positive relationship with subject = positive spin
          // Negative relationship with subject = negative spin
          if (avgRelation > 20) {
            rumor.spin = 'positive';
          } else if (avgRelation < -20) {
            rumor.spin = 'negative';
          }
          
          // Special interpretations for new event types based on relationship
          if (rumor.type === 'academic_failure') {
            if (avgRelation > 20) {
              // Friend: sympathetic interpretation
              rumor.spin = 'positive'; // "—É—á–∏—Ç–µ–ª—å –µ–≥–æ –∑–∞–≤–∞–ª–∏–ª"
            } else {
              rumor.spin = 'neutral'; // "–æ–Ω —Å–æ–≤—Å–µ–º –Ω–µ —É—á–∏—Ç—Å—è"
            }
          } else if (rumor.type === 'teacher_meeting') {
            if (avgRelation < -10) {
              rumor.spin = 'negative'; // "–µ–≥–æ –æ—Ç—á–∏—Ç—ã–≤–∞–ª–∏ –∑–∞ –ø–æ–≤–µ–¥–µ–Ω–∏–µ"
            } else if (witnessMood === 'jealous') {
              rumor.spin = 'negative'; // "–æ–Ω —Ç–µ–ø–µ—Ä—å –ª—é–±–∏–º—á–∏–∫" (enviously)
            }
          } else if (rumor.type === 'truancy') {
            if (avgRelation > 10) {
              rumor.spin = 'neutral'; // "–∫–∞–∂–µ—Ç—Å—è, –æ–Ω –∑–∞–±–æ–ª–µ–ª"
            } else {
              rumor.spin = 'negative'; // "–æ–Ω –ø–æ—Å—Ç–æ—è–Ω–Ω–æ –ø—Ä–æ–≥—É–ª–∏–≤–∞–µ—Ç"
            }
          }
          
          // Add small distortion based on relationship strength
          const distortionAmount = Math.abs(avgRelation) / 50; // 0-2 distortion
          rumor.distortion += distortionAmount;
        }
      },
      
      /**
       * Propagator sub-module: spreads and distorts rumors when characters interact.
       */
      Propagator: {
        /**
         * Spreads a rumor from one character to another, potentially distorting it.
         * @param {string} rumorId - ID of rumor to spread
         * @param {string} from - Character spreading the rumor
         * @param {string} to - Character receiving the rumor
         */
        spreadRumor(rumorId, from, to) {
          const L = LC.lcInit();
          if (!L.rumors) return;
          
          const rumor = L.rumors.find(r => r.id === rumorId);
          if (!rumor) return;
          
          // Only spread ACTIVE rumors
          if (rumor.status !== 'ACTIVE') return;
          
          // Check if 'to' already knows
          if (rumor.knownBy.includes(to)) return;
          
          // Check social status of source for credibility
          // Leaders spread rumors more effectively, outcasts are less believed
          const fromChar = L.characters[from];
          let credibilityMultiplier = 1.0;
          if (fromChar && fromChar.social) {
            if (fromChar.social.status === 'leader') {
              credibilityMultiplier = 1.5; // Leaders' rumors spread faster and are more believed
            } else if (fromChar.social.status === 'outcast') {
              credibilityMultiplier = 0.2; // Outcasts' rumors are largely dismissed
            }
          }
          
          // Only spread if credibility check passes
          if (Math.random() > credibilityMultiplier) {
            return; // Rumor not believed/spread
          }
          
          // Spread the rumor
          rumor.knownBy.push(to);
          
          // Distort the rumor (small chance with each spread)
          // Outcasts add more distortion
          const distortionChance = fromChar?.social?.status === 'outcast' ? 0.5 : 0.3;
          if (Math.random() < distortionChance) {
            rumor.distortion += 0.5;
          }
          
          L.stateVersion++;
          
          LC.lcSys({ 
            text: `üó£Ô∏è –°–ª—É—Ö —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–∏–ª—Å—è: ${from} ‚Üí ${to}`, 
            level: 'director' 
          });
          
          // Update reputation based on rumor type and spin
          this.updateReputation(rumor);
        },
        
        /**
         * Updates character reputation based on rumor spread.
         * @param {object} rumor - The rumor object
         */
        updateReputation(rumor) {
          const L = LC.lcInit();
          if (!L.characters[rumor.subject]) return;
          if (!L.characters[rumor.subject].reputation) {
            L.characters[rumor.subject].reputation = 50;
          }
          
          // Reputation change based on rumor type and spin
          let reputationChange = 0;
          
          if (rumor.type === 'romance') {
            reputationChange = rumor.spin === 'positive' ? 2 : -1;
          } else if (rumor.type === 'conflict') {
            reputationChange = -3;
          } else if (rumor.type === 'betrayal') {
            reputationChange = -5;
          } else if (rumor.type === 'achievement') {
            reputationChange = 5;
          }
          
          // Apply distortion penalty
          reputationChange -= Math.floor(rumor.distortion);
          
          L.characters[rumor.subject].reputation += reputationChange;
          
          // Clamp reputation between 0 and 100
          L.characters[rumor.subject].reputation = Math.max(0, Math.min(100, L.characters[rumor.subject].reputation));
          
          L.stateVersion++;
        },
        
        /**
         * Automatically propagate rumors when characters interact.
         * @param {string} char1 - First character
         * @param {string} char2 - Second character
         */
        autoPropagate(char1, char2) {
          const L = LC.lcInit();
          if (!L.rumors || L.rumors.length === 0) return;
          
          // Find rumors known by char1 but not char2, and only ACTIVE rumors
          const rumorsToSpread = L.rumors.filter(r => 
            r.status === 'ACTIVE' && r.knownBy.includes(char1) && !r.knownBy.includes(char2)
          );
          
          // Spread one random rumor (20% chance)
          if (rumorsToSpread.length > 0 && Math.random() < 0.2) {
            const randomRumor = rumorsToSpread[Math.floor(Math.random() * rumorsToSpread.length)];
            this.spreadRumor(randomRumor.id, char1, char2);
          }
        }
      },
      
      /**
       * Main analyze function that observes events and potentially spreads rumors.
       * @param {string} text - Text to analyze
       */
      analyze(text) {
        if (!text) return;
        
        // Observe for new gossip-worthy events
        this.Observer.observe(text);
        
        // Auto-propagate rumors when characters interact
        // Detect character interactions in text
        const L = LC.lcInit();
        if (!L.characters) return;
        
        const activeChars = Object.keys(L.characters).filter(name => {
          const char = L.characters[name];
          return char.lastSeen && (L.turn - char.lastSeen) <= 1;
        });
        
        // If 2+ characters are active, try to propagate rumors
        if (activeChars.length >= 2) {
          for (let i = 0; i < activeChars.length - 1; i++) {
            for (let j = i + 1; j < activeChars.length; j++) {
              this.Propagator.autoPropagate(activeChars[i], activeChars[j]);
            }
          }
        }
      },
      
      /**
       * Garbage Collection: manages rumor lifecycle and removes stale rumors.
       * ACTIVE ‚Üí FADED (when 75% of characters know it)
       * FADED ‚Üí ARCHIVED (after 50 turns)
       * ARCHIVED rumors are removed from L.rumors
       */
      runGarbageCollection() {
        const L = LC.lcInit();
        if (!L.rumors || L.rumors.length === 0) return;
        
        const KNOWLEDGE_THRESHOLD = 0.75; // 75% of characters
        const FADE_AGE_THRESHOLD = 50; // 50 turns
        
        // Count total important characters
        const totalCharacters = Object.keys(L.characters || {}).length;
        if (totalCharacters === 0) return;
        
        let fadedCount = 0;
        let archivedCount = 0;
        
        // Process each rumor
        for (const rumor of L.rumors) {
          // Ensure status field exists (for backward compatibility)
          if (!rumor.status) rumor.status = 'ACTIVE';
          
          // ACTIVE ‚Üí FADED transition
          if (rumor.status === 'ACTIVE') {
            const knowledgePercent = rumor.knownBy.length / totalCharacters;
            if (knowledgePercent >= KNOWLEDGE_THRESHOLD) {
              rumor.status = 'FADED';
              rumor.fadedAtTurn = L.turn;
              fadedCount++;
              L.stateVersion++;
            }
          }
          // FADED ‚Üí ARCHIVED transition
          else if (rumor.status === 'FADED') {
            const turnsSinceFaded = L.turn - (rumor.fadedAtTurn || L.turn);
            if (turnsSinceFaded >= FADE_AGE_THRESHOLD) {
              rumor.status = 'ARCHIVED';
              archivedCount++;
              L.stateVersion++;
            }
          }
        }
        
        // Remove ARCHIVED rumors
        const beforeCount = L.rumors.length;
        L.rumors = L.rumors.filter(r => r.status !== 'ARCHIVED');
        const removedCount = beforeCount - L.rumors.length;
        
        // Log summary if any changes occurred
        if (fadedCount > 0 || archivedCount > 0 || removedCount > 0) {
          LC.lcSys({ 
            text: `üóëÔ∏è GossipGC: ${fadedCount} faded, ${removedCount} archived/removed`, 
            level: 'director' 
          });
        }
      }
    },

    // ========== Character Garbage Collector ==========
    CharacterGC: {
      /**
       * Manages character lifecycle: promotion, freezing, unfreezing, and deletion.
       * - EXTRA ‚Üí SECONDARY: if mentioned >5 times in last 50 turns
       * - SECONDARY ‚Üí FROZEN: if not seen for >100 turns
       * - FROZEN ‚Üí ACTIVE: automatically on mention (handled in updateCharacterActivity)
       * - EXTRA deletion: if not seen for >200 turns and has ‚â§2 mentions total
       */
      run() {
        const L = LC.lcInit();
        if (!L.characters || typeof L.characters !== 'object') return;
        
        const currentTurn = L.turn || 0;
        const PROMOTION_MENTIONS = 5;
        const PROMOTION_WINDOW = 50;
        const FREEZE_THRESHOLD = 100;
        const DELETE_THRESHOLD = 200;
        const DELETE_MAX_MENTIONS = 2;
        
        let promotedCount = 0;
        let frozenCount = 0;
        let deletedCount = 0;
        
        const charactersToDelete = [];
        
        for (const charName in L.characters) {
          if (!Object.prototype.hasOwnProperty.call(L.characters, charName)) continue;
          
          const char = L.characters[charName];
          
          // Ensure type and status fields exist
          if (!char.type) char.type = 'EXTRA';
          if (!char.status) char.status = 'ACTIVE';
          
          const turnsSinceLastSeen = currentTurn - (char.lastSeen || 0);
          const turnsSinceFirstSeen = currentTurn - (char.firstSeen || 0);
          
          // Promotion Logic: EXTRA ‚Üí SECONDARY
          if (char.type === 'EXTRA' && char.mentions > PROMOTION_MENTIONS && turnsSinceFirstSeen <= PROMOTION_WINDOW) {
            char.type = 'SECONDARY';
            promotedCount++;
            L.stateVersion++;
          }
          
          // Freezing Logic: SECONDARY ‚Üí FROZEN
          if (char.type === 'SECONDARY' && char.status === 'ACTIVE' && turnsSinceLastSeen > FREEZE_THRESHOLD) {
            char.status = 'FROZEN';
            frozenCount++;
            L.stateVersion++;
          }
          
          // Deletion Logic: EXTRA with minimal interaction
          if (char.type === 'EXTRA' && turnsSinceLastSeen > DELETE_THRESHOLD && char.mentions <= DELETE_MAX_MENTIONS) {
            charactersToDelete.push(charName);
            deletedCount++;
          }
        }
        
        // Delete characters
        for (let i = 0; i < charactersToDelete.length; i++) {
          delete L.characters[charactersToDelete[i]];
        }
        
        if (deletedCount > 0) {
          L.stateVersion++;
        }
        
        // Log summary if any changes occurred
        if (promotedCount > 0 || frozenCount > 0 || deletedCount > 0) {
          LC.lcSys({ 
            text: `üìä CharacterGC: ${promotedCount} promoted, ${frozenCount} frozen, ${deletedCount} deleted`, 
            level: 'director' 
          });
        }
      }
    },

    // ========== Chronological Knowledge Base ==========
    ChronologicalKnowledgeBase: {
      SLEEP: {
        patterns: [
          /–ª–µ–≥\s+—Å–ø–∞—Ç—å/iu,
          /–ª–µ–≥–ª–∞\s+—Å–ø–∞—Ç—å/iu,
          /–ª–µ–≥–ª–∏\s+—Å–ø–∞—Ç—å/iu,
          /–∑–∞—Å–Ω—É–ª(?:–∞|–∏)?/iu,
          /–æ—Ç–ø—Ä–∞–≤–∏–ª(?:—Å—è|–∞—Å—å|–∏—Å—å)\s+(?:–≤\s+)?(?:–∫—Ä–æ–≤–∞—Ç—å|–ø–æ—Å—Ç–µ–ª—å|—Å–ø–∞—Ç—å)/iu,
          /–ø–æ—à(?:—ë–ª|–ª–∞|–ª–∏)\s+—Å–ø–∞—Ç—å/iu,
          /–¥–æ\s+–≥–ª—É–±–æ–∫–æ–π\s+–Ω–æ—á–∏/iu,
          /–≤—Å—é\s+–Ω–æ—á—å/iu,
          /–¥–æ\s+—É—Ç—Ä–∞/iu,
          /–∑–∞—Å–Ω—É–ª(?:–∞|–∏)?\s+(?:–Ω–∞|–≤)/iu,
          /–¥–æ\s+—Ä–∞—Å—Å–≤–µ—Ç–∞/iu
        ],
        action: { type: 'ADVANCE_TO_NEXT_MORNING' }
      },
      
      END_OF_SCHOOL_DAY: {
        patterns: [
          /–ø–æ—Å–ª–µ\s+—É—Ä–æ–∫–æ–≤/iu,
          /–ø–æ—Å–ª–µ\s+—à–∫–æ–ª—ã/iu,
          /–∑–∞–Ω—è—Ç–∏—è\s+–∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å/iu,
          /—É—Ä–æ–∫–∏\s+(?:–æ–∫–æ–Ω—á–∏–ª–∏—Å—å|–∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å|–∑–∞–≤–µ—Ä—à–∏–ª–∏—Å—å)/iu,
          /(?:–∫–æ–Ω–µ—Ü|–æ–∫–æ–Ω—á–∞–Ω–∏–µ)\s+(?:—É—Ä–æ–∫–æ–≤|–∑–∞–Ω—è—Ç–∏–π|—à–∫–æ–ª—å–Ω–æ–≥–æ\s+–¥–Ω—è)/iu
        ],
        action: { type: 'SET_TIME_OF_DAY', value: '–î–µ–Ω—å' }
      },
      
      LUNCH: {
        patterns: [
          /–ø–æ–æ–±–µ–¥–∞–ª(?:–∞|–∏)?/iu,
          /–≤–æ\s+–≤—Ä–µ–º—è\s+(?:–ª–∞–Ω—á–∞|–æ–±–µ–¥–∞)/iu,
          /(?:–∑–∞|–Ω–∞)\s+–æ–±–µ–¥(?:–æ–º|–µ)/iu,
          /—Å—ä–µ–ª(?:–∞|–∏)?\s+–æ–±–µ–¥/iu,
          /–æ–±–µ–¥–µ–Ω–Ω—ã–π\s+–ø–µ—Ä–µ—Ä—ã–≤/iu
        ],
        action: { type: 'SET_TIME_OF_DAY', value: '–î–µ–Ω—å' }
      },
      
      DINNER: {
        patterns: [
          /–ø–æ—É–∂–∏–Ω–∞–ª(?:–∞|–∏)?/iu,
          /(?:–∑–∞|–Ω–∞)\s+—É–∂–∏–Ω(?:–æ–º|–µ)/iu,
          /–≤–æ\s+–≤—Ä–µ–º—è\s+—É–∂–∏–Ω–∞/iu,
          /—Å—ä–µ–ª(?:–∞|–∏)?\s+—É–∂–∏–Ω/iu,
          /–≤–µ—á–µ—Ä–Ω–∏–π\s+–ø—Ä–∏–µ–º\s+–ø–∏—â–∏/iu
        ],
        action: { type: 'SET_TIME_OF_DAY', value: '–í–µ—á–µ—Ä' }
      },
      
      SHORT_TIME_JUMP: {
        patterns: [
          /—á–∞—Å\s+—Å–ø—É—Å—Ç—è/iu,
          /(?:—á–µ—Ä–µ–∑|—Å–ø—É—Å—Ç—è)\s+—á–∞—Å/iu,
          /(?:—á–µ—Ä–µ–∑|—Å–ø—É—Å—Ç—è)\s+(?:–Ω–µ—Å–∫–æ–ª—å–∫–æ|–ø–∞—Ä—É)\s+—á–∞—Å(?:–æ–≤|–∞)/iu,
          /–∫\s+–≤–µ—á–µ—Ä—É/iu,
          /–∫\s+–∫–æ–Ω—Ü—É\s+–¥–Ω—è/iu,
          /(?:—á–µ—Ä–µ–∑|—Å–ø—É—Å—Ç—è)\s+–Ω–µ–∫–æ—Ç–æ—Ä–æ–µ\s+–≤—Ä–µ–º—è/iu
        ],
        action: { type: 'ADVANCE_TIME_OF_DAY', steps: 1 }
      },
      
      NEXT_DAY: {
        patterns: [
          /–Ω–∞\s+—Å–ª–µ–¥—É—é—â–∏–π\s+–¥–µ–Ω—å/iu,
          /—Å–ª–µ–¥—É—é—â–∏–º\s+(?:—É—Ç—Ä–æ–º|–¥–Ω–µ–º|–≤–µ—á–µ—Ä–æ–º)/iu,
          /–Ω–∞\s+–¥—Ä—É–≥–æ–π\s+–¥–µ–Ω—å/iu,
          /–Ω–∞–∑–∞–≤—Ç—Ä–∞/iu,
          /–Ω–∞\s+—Å–ª–µ–¥—É—é—â–µ–µ\s+—É—Ç—Ä–æ/iu
        ],
        action: { type: 'ADVANCE_DAY', days: 1 }
      },
      
      WEEK_JUMP: {
        patterns: [
          /(?:–ø—Ä–æ—à–ª–∞|–ø—Ä–æ—à–ª–æ)\s+–Ω–µ–¥–µ–ª—è/iu,
          /—á–µ—Ä–µ–∑\s+–Ω–µ–¥–µ–ª—é/iu,
          /—Å–ø—É—Å—Ç—è\s+–Ω–µ–¥–µ–ª—é/iu,
          /–Ω–µ–¥–µ–ª–µ–π\s+(?:–ø–æ–∑–∂–µ|—Å–ø—É—Å—Ç—è)/iu,
          /(?:–ø—Ä–æ—à–ª–æ|–º–∏–Ω–æ–≤–∞–ª–æ)\s+(?:–Ω–µ—Å–∫–æ–ª—å–∫–æ\s+)?(?:–Ω–µ–¥–µ–ª—å|–¥–Ω–µ–π)/iu
        ],
        action: { type: 'ADVANCE_DAY', days: 7 }
      },
      
      MORNING: {
        patterns: [
          /(?:^|[^–∞-—è—ë])—É—Ç—Ä(?:–æ–º|–∞)(?:[^–∞-—è—ë]|$)/iu,
          /—Ä–∞–Ω–Ω–∏–º\s+—É—Ç—Ä–æ–º/iu,
          /—Å\s+—É—Ç—Ä–∞/iu,
          /–Ω–∞\s+—Ä–∞—Å—Å–≤–µ—Ç–µ/iu
        ],
        action: { type: 'SET_TIME_OF_DAY', value: '–£—Ç—Ä–æ' }
      },
      
      EVENING: {
        patterns: [
          /(?:^|[^–∞-—è—ë])–≤–µ—á–µ—Ä(?:–æ–º|–∞)(?:[^–∞-—è—ë]|$)/iu,
          /–ø–æ–∑–¥–Ω–∏–º\s+–≤–µ—á–µ—Ä–æ–º/iu,
          /–∫\s+–≤–µ—á–µ—Ä—É/iu,
          /–≤\s+—Å—É–º–µ—Ä–∫–∞—Ö/iu
        ],
        action: { type: 'SET_TIME_OF_DAY', value: '–í–µ—á–µ—Ä' }
      },
      
      NIGHT: {
        patterns: [
          /(?:^|[^–∞-—è—ë])–Ω–æ—á(?:—å—é|—å)(?:[^–∞-—è—ë]|$)/iu,
          /–≥–ª—É–±–æ–∫–æ–π\s+–Ω–æ—á—å—é/iu,
          /–ø–æ–∑–¥–Ω–µ–π\s+–Ω–æ—á—å—é/iu,
          /—Å—Ä–µ–¥–∏\s+–Ω–æ—á–∏/iu,
          /–ø–æ–ª–Ω–æ—á—å/iu
        ],
        action: { type: 'SET_TIME_OF_DAY', value: '–ù–æ—á—å' }
      },
      
      // New categories for enhanced understanding
      PARTY: {
        patterns: [
          /–≤–µ—á–µ—Ä–∏–Ω–∫(?:–∞|–µ|—É|–æ–π)/iu,
          /—Ç—É—Å–æ–≤–∫(?:–∞|–µ|—É|–æ–π)/iu,
          /—Å–±–æ—Ä\s+—É\s+–¥—Ä—É–∑–µ–π/iu,
          /–ø–æ—à(?:—ë–ª|–ª–∞|–ª–∏)\s+–≤\s+–∫–ª—É–±/iu,
          /(?:–Ω–∞|–≤)\s+–≤–µ—á–µ—Ä–∏–Ω–∫(?:–µ|—É)/iu,
          /(?:–Ω–∞|–≤)\s+—Ç—É—Å–æ–≤–∫(?:–µ|—É)/iu
        ],
        action: { type: 'SET_TIME_OF_DAY', value: '–í–µ—á–µ—Ä' }
      },
      
      TRAINING: {
        patterns: [
          /—Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫(?:–∞|–µ|—É|–æ–π)/iu,
          /—Ä–µ–ø–µ—Ç–∏—Ü–∏(?:—è|–∏|—é|–µ–π)/iu,
          /–¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω(?:—ã–µ|—ã—Ö)\s+–∑–∞–Ω—è—Ç–∏–π/iu,
          /—Å–µ–∫—Ü–∏(?:—è|–∏|—é|–µ–π)/iu,
          /(?:–Ω–∞|–≤)\s+—Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫(?:–µ|—É)/iu,
          /(?:–Ω–∞|–≤)\s+—Ä–µ–ø–µ—Ç–∏—Ü(?:–∏–∏|–∏—é)/iu
        ],
        action: { type: 'SET_TIME_OF_DAY', value: '–î–µ–Ω—å' }
      },
      
      DATE: {
        patterns: [
          /—Å–≤–∏–¥–∞–Ω–∏(?:–µ|—è|—é|–µ–º)/iu,
          /–ø–æ—à(?:—ë–ª|–ª–∞)\s+–Ω–∞\s+—Å–≤–∏–¥–∞–Ω–∏–µ/iu,
          /(?:—É|–±—ã–ª–æ)\s+—Å–≤–∏–¥–∞–Ω–∏–µ/iu,
          /–ø—Ä–∏–≥–ª–∞—Å–∏–ª(?:–∞)?\s+–Ω–∞\s+—Å–≤–∏–¥–∞–Ω–∏–µ/iu
        ],
        action: { type: 'SET_TIME_OF_DAY', value: '–í–µ—á–µ—Ä' }
      },
      
      MIDNIGHT: {
        patterns: [
          /–∫\s+–ø–æ–ª—É–Ω–æ—á–∏/iu,
          /–≤\s+–ø–æ–ª–Ω–æ—á—å/iu,
          /–¥–∞–ª–µ–∫–æ\s+–∑–∞\s+–ø–æ–ª–Ω–æ—á—å/iu,
          /–ø–æ—Å–ª–µ\s+–ø–æ–ª—É–Ω–æ—á–∏/iu
        ],
        action: { type: 'SET_TIME_OF_DAY', value: '–ù–æ—á—å' }
      },
      
      DAWN: {
        patterns: [
          /–¥–æ\s+—Ä–∞—Å—Å–≤–µ—Ç–∞/iu,
          /–Ω–∞\s+—Ä–∞—Å—Å–≤–µ—Ç–µ/iu,
          /–ø—Ä–æ—Å–Ω—É–ª(?:—Å—è|–∞—Å—å)\s+—Å\s+–ø–µ—Ä–≤—ã–º–∏\s+–ª—É—á–∞–º–∏\s+—Å–æ–ª–Ω—Ü–∞/iu,
          /—Å\s+—Ä–∞—Å—Å–≤–µ—Ç–æ–º/iu,
          /–ø–µ—Ä–µ–¥\s+—Ä–∞—Å—Å–≤–µ—Ç–æ–º/iu
        ],
        action: { type: 'SET_TIME_OF_DAY', value: '–£—Ç—Ä–æ' }
      },
      
      FEW_DAYS_LATER: {
        patterns: [
          /—á–µ—Ä–µ–∑\s+–ø–∞—Ä—É\s+–¥–Ω–µ–π/iu,
          /–Ω–µ—Å–∫–æ–ª—å–∫–æ\s+–¥–Ω–µ–π\s+—Å–ø—É—Å—Ç—è/iu,
          /–ø—Ä–æ—à–ª–æ\s+(?:–¥–≤–∞|—Ç—Ä–∏)\s+–¥–Ω—è/iu,
          /(?:—á–µ—Ä–µ–∑|—Å–ø—É—Å—Ç—è)\s+(?:–¥–≤–∞|—Ç—Ä–∏|2|3)\s+–¥–Ω—è/iu,
          /–ø–∞—Ä—É\s+–¥–Ω–µ–π\s+(?:—Å–ø—É—Å—Ç—è|–ø–æ–∑–∂–µ)/iu
        ],
        action: { type: 'ADVANCE_DAY', days: 2 }
      }
    },

    // ========== Time Engine ==========
    TimeEngine: {
      advance(){
        const L = LC.lcInit();
        if (!L.time) {
          L.time = {
            currentDay: 1,
            dayName: '–ü–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫',
            timeOfDay: '–£—Ç—Ä–æ',
            turnsPerToD: 5,
            turnsInCurrentToD: 0,
            scheduledEvents: []
          };
        }
        
        // OLD TURN-BASED MECHANICS DISABLED
        // Time now flows based on semantic actions from ChronologicalKnowledgeBase
        // The old turn counter is preserved for backward compatibility but not used
        // L.time.turnsInCurrentToD = (L.time.turnsInCurrentToD || 0) + 1;
        // if (L.time.turnsInCurrentToD >= L.time.turnsPerToD) { ... }
        
        // Check if a time jump occurred and return information about it
        const lastJump = L.time.lastTimeJump || { type: 'NONE' };
        // Clear the jump flag after reading it
        if (L.time.lastTimeJump) {
          delete L.time.lastTimeJump;
        }
        return lastJump;
      },
      
      /**
       * Processes semantic time-related actions (e.g., advancing time, setting time of day).
       * Updates L.time state based on the action type and parameters.
       * @param {object} action - The semantic action object
       * @param {string} action.type - The action type ('ADVANCE_TO_NEXT_MORNING', 'SET_TIME_OF_DAY', 'ADVANCE_TIME_OF_DAY')
       * @param {string} [action.value] - The value for SET_TIME_OF_DAY actions
       * @param {number} [action.steps] - The number of steps for ADVANCE_TIME_OF_DAY actions
       */
      processSemanticAction(action){
        const L = LC.lcInit();
        if (!L.time) {
          L.time = {
            currentDay: 1,
            dayName: '–ü–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫',
            timeOfDay: '–£—Ç—Ä–æ',
            turnsPerToD: 5,
            turnsInCurrentToD: 0,
            scheduledEvents: []
          };
        }
        
        if (!action || !action.type) return;
        
        const timeSequence = ['–£—Ç—Ä–æ', '–î–µ–Ω—å', '–í–µ—á–µ—Ä', '–ù–æ—á—å'];
        const dayNames = ['–ü–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫', '–í—Ç–æ—Ä–Ω–∏–∫', '–°—Ä–µ–¥–∞', '–ß–µ—Ç–≤–µ—Ä–≥', '–ü—è—Ç–Ω–∏—Ü–∞', '–°—É–±–±–æ—Ç–∞', '–í–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ'];
        
        switch(action.type) {
          case 'ADVANCE_TO_NEXT_MORNING':
            // Go to next day, morning
            L.time.currentDay = (L.time.currentDay || 1) + 1;
            L.time.timeOfDay = '–£—Ç—Ä–æ';
            L.time.turnsInCurrentToD = 0;
            
            // Update day name
            const dayIndex = ((L.time.currentDay - 1) % 7);
            L.time.dayName = dayNames[dayIndex];
            
            // Store time jump information for Living World Engine
            L.time.lastTimeJump = { type: 'ADVANCE_TO_NEXT_MORNING', duration: 'night' };
            break;
            
          case 'SET_TIME_OF_DAY':
            // Set specific time of day
            if (action.value && timeSequence.indexOf(action.value) >= 0) {
              L.time.timeOfDay = action.value;
              L.time.turnsInCurrentToD = 0;
            }
            break;
            
          case 'ADVANCE_TIME_OF_DAY':
            // Advance time of day by N steps
            const steps = action.steps || 1;
            const currentIndex = timeSequence.indexOf(L.time.timeOfDay);
            
            if (currentIndex >= 0) {
              let newIndex = currentIndex + steps;
              
              // Handle day wrap
              while (newIndex >= timeSequence.length) {
                newIndex -= timeSequence.length;
                L.time.currentDay = (L.time.currentDay || 1) + 1;
                const dayIdx = ((L.time.currentDay - 1) % 7);
                L.time.dayName = dayNames[dayIdx];
              }
              
              L.time.timeOfDay = timeSequence[newIndex];
              L.time.turnsInCurrentToD = 0;
            }
            break;
            
          case 'ADVANCE_DAY':
            // Advance by N days
            const days = action.days || 1;
            L.time.currentDay = (L.time.currentDay || 1) + days;
            L.time.timeOfDay = '–£—Ç—Ä–æ';
            L.time.turnsInCurrentToD = 0;
            
            // Update day name
            const newDayIndex = ((L.time.currentDay - 1) % 7);
            L.time.dayName = dayNames[newDayIndex];
            
            // Store time jump information for Living World Engine
            L.time.lastTimeJump = { type: 'ADVANCE_DAY', days: days, duration: days === 1 ? 'day' : 'days' };
            break;
        }
        
        // Increment stateVersion to invalidate context cache
        L.stateVersion++;
      }
    },

    // ========== Living World Engine ==========
    LivingWorld: {
      /**
       * Main entry point for off-screen simulation cycle.
       * Simulates NPC actions during time jumps (e.g., overnight, between days).
       * @param {object} timeJump - Information about the time jump that occurred
       * @param {string} timeJump.type - Type of time jump ('ADVANCE_TO_NEXT_MORNING', 'ADVANCE_DAY', etc.)
       * @param {string} [timeJump.duration] - Duration description ('night', 'day', 'days')
       */
      runOffScreenCycle(timeJump) {
        if (!timeJump || timeJump.type === 'NONE') return;
        
        const L = LC.lcInit();
        
        // Get list of all ACTIVE characters (not FROZEN)
        const activeCharacters = [];
        for (const name in (L.characters || {})) {
          const char = L.characters[name];
          if (char && char.status === 'ACTIVE') {
            activeCharacters.push({ name: name, data: char });
          }
        }
        
        // Simulate each character's actions
        for (let i = 0; i < activeCharacters.length; i++) {
          try {
            this.simulateCharacter(activeCharacters[i]);
          } catch (e) {
            LC.lcWarn?.("LivingWorld simulation error for " + activeCharacters[i].name + ": " + (e && e.message));
          }
        }
      },
      
      /**
       * Simulates a single character's decision-making and actions during off-screen time.
       * Uses a "Motivation Pyramid" to prioritize character actions:
       * 1. Active goals (highest priority)
       * 2. Strong relationships (positive or negative)
       * 3. Upcoming calendar events
       * @param {object} character - Character object with name and data
       * @param {string} character.name - Character's normalized name
       * @param {object} character.data - Character's state data
       */
      simulateCharacter(character) {
        const L = LC.lcInit();
        const charName = character.name;
        
        // Motivation Pyramid: Analyze what drives this character's actions
        let action = null;
        let targetChar = null;
        
        // Priority 1: Check for active goals
        if (L.goals && typeof L.goals === 'object') {
          for (const goalKey in L.goals) {
            const goal = L.goals[goalKey];
            if (goal && goal.character === charName && goal.status === 'active') {
              action = { type: 'PURSUE_GOAL', goal: goal, goalKey: goalKey };
              break;
            }
          }
        }
        
        // Priority 2: Check for strong relationships (if no goal)
        if (!action && L.evergreen && L.evergreen.relations && L.evergreen.relations[charName]) {
          const relations = L.evergreen.relations[charName];
          let strongestRelation = null;
          let strongestValue = 0;
          
          for (const otherChar in relations) {
            const rel = relations[otherChar];
            let absValue = 0;
            let value = 0;
            
            if (typeof rel === 'number') {
              // Legacy numeric
              absValue = Math.abs(rel);
              value = rel;
            } else if (typeof rel === 'object' && rel !== null) {
              // Multi-vector: use affection as primary indicator
              const aff = (rel.affection || 50) - 50; // Convert to -50 to +50 scale
              absValue = Math.abs(aff);
              value = aff;
            }
            
            if (absValue > strongestValue && absValue >= 30) { // Threshold for "strong" relation
              strongestValue = absValue;
              strongestRelation = {
                target: otherChar,
                value: value
              };
            }
          }
          
          if (strongestRelation) {
            targetChar = strongestRelation.target;
            if (strongestRelation.value > 0) {
              action = { type: 'SOCIAL_POSITIVE', target: targetChar, strength: strongestRelation.value };
            } else {
              action = { type: 'SOCIAL_NEGATIVE', target: targetChar, strength: Math.abs(strongestRelation.value) };
            }
          }
        }
        
        // Priority 3: Check for upcoming calendar events (if no goal or strong relation)
        if (!action && L.time && L.time.scheduledEvents && L.time.scheduledEvents.length > 0) {
          const currentDay = L.time.currentDay || 1;
          for (let i = 0; i < L.time.scheduledEvents.length; i++) {
            const event = L.time.scheduledEvents[i];
            if (event && event.day && event.day <= currentDay + 3 && event.day >= currentDay) {
              // Event is coming up soon (within 3 days)
              action = { type: 'PREPARE_EVENT', event: event };
              break;
            }
          }
        }
        
        // Mood Modifier: Check current mood to affect action intensity
        if (action && L.character_status && L.character_status[charName]) {
          const mood = L.character_status[charName].mood;
          if (mood) {
            action.mood = mood; // Attach mood to the action for intensity calculation
          }
        }
        
        // If we determined an action, generate the corresponding fact
        if (action) {
          this.generateFact(charName, action);
        }
      },
      
      /**
       * Generates concrete state changes ("facts") based on character actions.
       * Does NOT generate narrative text - only modifies state silently.
       * @param {string} characterName - The name of the character performing the action
       * @param {object} action - The action object with type and relevant data
       * @param {string} action.type - Action type ('PURSUE_GOAL', 'SOCIAL_POSITIVE', 'SOCIAL_NEGATIVE', 'GOSSIP', etc.)
       */
      generateFact(characterName, action) {
        if (!action || !action.type) return;
        
        const L = LC.lcInit();
        
        switch (action.type) {
          case 'PURSUE_GOAL':
            // Character worked on their goal - add progress flag
            if (action.goal && action.goalKey) {
              const char = L.characters[characterName];
              if (char) {
                // Create flags object if it doesn't exist
                if (!char.flags) char.flags = {};
                
                // Add goal progress indicator
                const progressKey = 'goal_progress_' + action.goalKey;
                char.flags[progressKey] = (char.flags[progressKey] || 0) + 0.25;
                
                // Update plan progress if goal has a plan
                if (L.goals[action.goalKey] && L.goals[action.goalKey].plan) {
                  const goal = L.goals[action.goalKey];
                  const currentStep = goal.planProgress || 0;
                  
                  // Every 4 work sessions (1.0 progress), complete one step
                  if (char.flags[progressKey] >= 1.0 && currentStep < goal.plan.length) {
                    if (LC.GoalsEngine && typeof LC.GoalsEngine.updatePlanProgress === 'function') {
                      LC.GoalsEngine.updatePlanProgress(action.goalKey, 'complete');
                      // Reset progress for next step
                      char.flags[progressKey] = 0;
                    }
                  } else if (char.flags[progressKey] > 0) {
                    // Mark current step as in-progress
                    if (LC.GoalsEngine && typeof LC.GoalsEngine.updatePlanProgress === 'function') {
                      LC.GoalsEngine.updatePlanProgress(action.goalKey, 'in-progress');
                    }
                  }
                }
                
                // Cap progress at 1.0
                if (char.flags[progressKey] > 1.0) {
                  char.flags[progressKey] = 1.0;
                }
                
                // Notify QualiaEngine about sensations from working on goal
                if (LC.QualiaEngine && typeof LC.QualiaEngine.resonate === 'function') {
                  // Working on a goal creates focused energy
                  LC.QualiaEngine.resonate(char, {
                    type: 'achievement',
                    actor: characterName,
                    action: 'progress',
                    intensity: 0.5
                  });
                }
              }
            }
            break;
            
          case 'SOCIAL_NEGATIVE':
            // Negative social interaction - decrease relationship
            if (action.target && LC.RelationsEngine) {
              // Apply relationship change (magnitude based on mood if present)
              let modifier = -5; // Base negative interaction
              if (action.mood === 'ANGRY' || action.mood === 'FRUSTRATED') {
                modifier = -10; // More intense when angry
              }
              
              // Use InformationEngine for subjective interpretation if available
              const event = {
                type: 'social',
                action: 'insult',
                rawModifier: modifier,
                actor: characterName,
                target: action.target
              };
              
              LC.RelationsEngine.updateRelation(characterName, action.target, modifier, { 
                interpretedEvent: event 
              });
              
              // Notify Crucible about relationship changes
              if (LC.Crucible && typeof LC.Crucible.analyzeEvent === 'function') {
                LC.Crucible.analyzeEvent({
                  type: 'RELATION_CHANGE',
                  character: characterName,
                  otherCharacter: action.target,
                  change: modifier,
                  finalValue: LC.RelationsEngine.getRelation(characterName, action.target)
                });
                LC.Crucible.analyzeEvent({
                  type: 'RELATION_CHANGE',
                  character: action.target,
                  otherCharacter: characterName,
                  change: modifier,
                  finalValue: LC.RelationsEngine.getRelation(action.target, characterName)
                });
              }
              
              // Notify QualiaEngine about bodily sensations from negative interaction
              if (LC.QualiaEngine && typeof LC.QualiaEngine.resonate === 'function') {
                const actorChar = L.characters[characterName];
                const targetChar = L.characters[action.target];
                
                if (actorChar) {
                  // Actor feels tension/aggression during negative interaction
                  LC.QualiaEngine.resonate(actorChar, {
                    type: 'social',
                    actor: characterName,
                    action: 'aggression',
                    target: action.target,
                    intensity: Math.min(1, Math.abs(modifier) / 10)
                  });
                }
                
                if (targetChar) {
                  // Target receives insult/criticism
                  LC.QualiaEngine.resonate(targetChar, {
                    type: 'social',
                    actor: characterName,
                    action: 'insult',
                    target: action.target,
                    intensity: Math.min(1, Math.abs(modifier) / 10)
                  });
                }
              }
              
              // Update social capital for negative interaction
              if (LC.HierarchyEngine && typeof LC.HierarchyEngine.updateCapital === 'function') {
                LC.HierarchyEngine.updateCapital(characterName, {
                  type: 'NEGATIVE_ACTION',
                  target: action.target
                });
              }
              
              L.stateVersion++;
            }
            break;
            
          case 'SOCIAL_POSITIVE':
            // Positive social interaction - increase relationship
            if (action.target && LC.RelationsEngine) {
              // Apply relationship change (magnitude based on mood if present)
              let modifier = 5; // Base positive interaction
              if (action.mood === 'HAPPY' || action.mood === 'EXCITED') {
                modifier = 8; // More intense when happy
              }
              
              // Use InformationEngine for subjective interpretation if available
              const event = {
                type: 'social',
                action: 'compliment',
                rawModifier: modifier,
                actor: characterName,
                target: action.target
              };
              
              LC.RelationsEngine.updateRelation(characterName, action.target, modifier, { 
                interpretedEvent: event 
              });
              
              // Notify Crucible about relationship changes
              if (LC.Crucible && typeof LC.Crucible.analyzeEvent === 'function') {
                LC.Crucible.analyzeEvent({
                  type: 'RELATION_CHANGE',
                  character: characterName,
                  otherCharacter: action.target,
                  change: modifier,
                  finalValue: LC.RelationsEngine.getRelation(characterName, action.target)
                });
                LC.Crucible.analyzeEvent({
                  type: 'RELATION_CHANGE',
                  character: action.target,
                  otherCharacter: characterName,
                  change: modifier,
                  finalValue: LC.RelationsEngine.getRelation(action.target, characterName)
                });
              }
              
              // Notify QualiaEngine about bodily sensations from positive interaction
              if (LC.QualiaEngine && typeof LC.QualiaEngine.resonate === 'function') {
                const actorChar = L.characters[characterName];
                const targetChar = L.characters[action.target];
                
                if (targetChar) {
                  // Target receives compliment/praise
                  LC.QualiaEngine.resonate(targetChar, {
                    type: 'social',
                    actor: characterName,
                    action: 'compliment',
                    target: action.target,
                    intensity: Math.min(1, modifier / 10)
                  });
                }
                
                if (actorChar) {
                  // Actor feels positive from giving kindness
                  LC.QualiaEngine.resonate(actorChar, {
                    type: 'social',
                    actor: characterName,
                    action: 'compliment',
                    target: action.target,
                    intensity: Math.min(1, modifier / 15) // Smaller effect for giver
                  });
                }
              }
              
              // Update social capital for positive interaction
              if (LC.HierarchyEngine && typeof LC.HierarchyEngine.updateCapital === 'function') {
                LC.HierarchyEngine.updateCapital(characterName, {
                  type: 'POSITIVE_ACTION',
                  target: action.target
                });
              }
              
              L.stateVersion++;
            }
            break;
            
          case 'GOSSIP':
            // Character spreads gossip - create or spread a rumor
            if (action.rumor && LC.GossipEngine && LC.GossipEngine.Propagator) {
              if (!L.rumors) L.rumors = [];
              
              // Try to find an existing rumor to spread
              let rumorToSpread = null;
              for (let i = 0; i < L.rumors.length; i++) {
                const rumor = L.rumors[i];
                if (rumor && rumor.knownBy && rumor.knownBy.indexOf(characterName) >= 0) {
                  rumorToSpread = rumor;
                  break;
                }
              }
              
              if (rumorToSpread && action.target) {
                // Spread existing rumor to target
                if (!rumorToSpread.knownBy.includes(action.target)) {
                  rumorToSpread.knownBy.push(action.target);
                  rumorToSpread.distortion = (rumorToSpread.distortion || 0) + 0.1;
                }
              }
            }
            break;
            
          case 'PREPARE_EVENT':
            // Character prepares for upcoming event
            if (action.event) {
              const char = L.characters[characterName];
              if (char) {
                if (!char.flags) char.flags = {};
                char.flags['event_preparation_' + (action.event.id || action.event.title)] = true;
              }
            }
            break;
        }
      }
    },

    // ========== The Crucible: Character Evolution Engine ==========
    Crucible: {
      /**
       * Analyzes events for their potential to trigger personality evolution.
       * This is the core "Catalyst" detector that determines if an event is significant
       * enough to fundamentally change a character's personality traits.
       * @param {object} eventData - Event data from other engines
       * @param {string} eventData.type - Event type ('RELATION_CHANGE', 'GOAL_COMPLETE', 'RUMOR_SPREAD')
       * @param {string} eventData.character - The character experiencing the event
       * @param {string} [eventData.otherCharacter] - Other character involved (for relationship events)
       * @param {number} [eventData.change] - The magnitude of change (for relationship events)
       * @param {number} [eventData.finalValue] - Final value after change (for relationship events)
       */
      analyzeEvent(eventData) {
        if (!eventData || !eventData.type || !eventData.character) return;
        
        const L = LC.lcInit();
        const character = L.characters[eventData.character];
        if (!character) return;
        
        // Ensure personality exists
        if (!character.personality) {
          character.personality = {
            trust: 0.5,
            bravery: 0.5,
            idealism: 0.5,
            aggression: 0.3
          };
        }
        
        // Check if character is important enough for evolution
        // Only MAIN and SECONDARY characters evolve significantly
        const isImportant = character.type === 'MAIN' || character.type === 'SECONDARY';
        
        switch (eventData.type) {
          case 'RELATION_CHANGE':
            this._handleRelationChange(character, eventData, isImportant);
            break;
            
          case 'GOAL_COMPLETE':
            this._handleGoalComplete(character, eventData, isImportant);
            break;
            
          case 'RUMOR_SPREAD':
            this._handleRumorSpread(character, eventData, isImportant);
            break;
        }
        
        // Archive exceptionally powerful formative events for mythologization
        // Events that trigger significant personality changes or status changes
        const shouldArchive = this._shouldArchiveEvent(eventData, isImportant);
        if (shouldArchive) {
          this._archiveFormativeEvent(eventData, character);
        }
        
        // Ensure all personality values stay within [0, 1]
        for (const trait in character.personality) {
          character.personality[trait] = Math.max(0, Math.min(1, character.personality[trait]));
        }
        
        // Ensure all self-concept values stay within [0, 1]
        if (character.self_concept) {
          for (const trait in character.self_concept) {
            character.self_concept[trait] = Math.max(0, Math.min(1, character.self_concept[trait]));
          }
        }
      },
      
      /**
       * Handles personality evolution from relationship changes.
       * Major betrayals decrease trust and idealism.
       * Major acts of heroism/rescue increase trust and bravery.
       * 
       * CrucibleEngine 2.0: Now primarily modifies self-concept (how character sees themselves)
       * rather than objective personality traits.
       */
      _handleRelationChange(character, eventData, isImportant) {
        const change = eventData.change || 0;
        const finalValue = eventData.finalValue || 0;
        const otherChar = eventData.otherCharacter;
        
        // Ensure self-concept exists
        if (!character.self_concept) {
          character.self_concept = {
            perceived_trust: character.personality.trust,
            perceived_bravery: character.personality.bravery,
            perceived_idealism: character.personality.idealism,
            perceived_aggression: character.personality.aggression
          };
        }
        
        // Only process significant changes
        if (Math.abs(change) < 30) return;
        
        // Major negative event (betrayal, abandonment)
        if (change < -40 && isImportant) {
          // Self-concept changes MORE than objective personality
          character.self_concept.perceived_trust = Math.max(0, character.self_concept.perceived_trust - 0.25);
          character.self_concept.perceived_idealism = Math.max(0, character.self_concept.perceived_idealism - 0.15);
          
          // Objective personality changes less
          character.personality.trust = Math.max(0, character.personality.trust - 0.1);
          character.personality.idealism = Math.max(0, character.personality.idealism - 0.05);
          
          LC.lcSys?.({ 
            text: `${eventData.character} –ø–µ—Ä–µ–∂–∏–ª(–∞) –ø—Ä–µ–¥–∞—Ç–µ–ª—å—Å—Ç–≤–æ –∏ —Ç–µ–ø–µ—Ä—å —Å—á–∏—Ç–∞–µ—Ç —Å–µ–±—è –º–µ–Ω–µ–µ –¥–æ–≤–µ—Ä—á–∏–≤(—ã–º/–æ–π).`, 
            level: 'director' 
          });
        }
        // Major positive event (heroic rescue, deep loyalty)
        else if (change > 40 && isImportant) {
          // Self-concept changes MORE than objective personality
          character.self_concept.perceived_trust = Math.min(1, character.self_concept.perceived_trust + 0.2);
          character.self_concept.perceived_bravery = Math.min(1, character.self_concept.perceived_bravery + 0.15);
          
          // Objective personality changes less
          character.personality.trust = Math.min(1, character.personality.trust + 0.08);
          character.personality.bravery = Math.min(1, character.personality.bravery + 0.05);
          
          LC.lcSys?.({ 
            text: `${eventData.character} –±—ã–ª(–∞) —Å–ø–∞—Å–µ–Ω(–∞) –∏ —Ç–µ–ø–µ—Ä—å —Å—á–∏—Ç–∞–µ—Ç —Å–µ–±—è –±–æ–ª–µ–µ —Å–º–µ–ª(—ã–º/–æ–π) –∏ –Ω–∞–¥–µ–∂–Ω(—ã–º/–æ–π).`, 
            level: 'director' 
          });
        }
        // Extreme hatred can increase aggression
        else if (finalValue < -70 && isImportant) {
          character.self_concept.perceived_aggression = Math.min(1, character.self_concept.perceived_aggression + 0.15);
          character.personality.aggression = Math.min(1, character.personality.aggression + 0.05);
        }
      },
      
      /**
       * Handles personality evolution from goal completion.
       * Completing difficult goals increases bravery.
       * Repeated failures decrease idealism.
       * 
       * CrucibleEngine 2.0: Now primarily modifies self-concept.
       */
      _handleGoalComplete(character, eventData, isImportant) {
        const success = eventData.success;
        
        // Ensure self-concept exists
        if (!character.self_concept) {
          character.self_concept = {
            perceived_trust: character.personality.trust,
            perceived_bravery: character.personality.bravery,
            perceived_idealism: character.personality.idealism,
            perceived_aggression: character.personality.aggression
          };
        }
        
        if (success && isImportant) {
          // Self-concept changes MORE than objective personality
          character.self_concept.perceived_bravery = Math.min(1, character.self_concept.perceived_bravery + 0.15);
          character.self_concept.perceived_idealism = Math.min(1, character.self_concept.perceived_idealism + 0.1);
          
          // Objective personality changes less
          character.personality.bravery = Math.min(1, character.personality.bravery + 0.05);
          character.personality.idealism = Math.min(1, character.personality.idealism + 0.03);
          
          LC.lcSys?.({ 
            text: `${eventData.character} –¥–æ—Å—Ç–∏–≥(–ª–∞) –≤–∞–∂–Ω–æ–π —Ü–µ–ª–∏ –∏ —Ç–µ–ø–µ—Ä—å –≤–µ—Ä–∏—Ç –≤ —Å–≤–æ—é —Å–º–µ–ª–æ—Å—Ç—å.`, 
            level: 'director' 
          });
        } else if (!success && isImportant) {
          // Failure damages self-concept more than objective traits
          character.self_concept.perceived_idealism = Math.max(0, character.self_concept.perceived_idealism - 0.15);
          character.self_concept.perceived_bravery = Math.max(0, character.self_concept.perceived_bravery - 0.1);
          
          character.personality.idealism = Math.max(0, character.personality.idealism - 0.05);
        }
      },
      
      /**
       * Handles personality evolution from rumor spread.
       * Being the subject of widespread negative gossip can change personality.
       * 
       * CrucibleEngine 2.0: Public humiliation primarily damages self-concept.
       */
      _handleRumorSpread(character, eventData, isImportant) {
        const spreadCount = eventData.spreadCount || 0;
        const spin = eventData.spin || 'neutral';
        
        // Ensure self-concept exists
        if (!character.self_concept) {
          character.self_concept = {
            perceived_trust: character.personality.trust,
            perceived_bravery: character.personality.bravery,
            perceived_idealism: character.personality.idealism,
            perceived_aggression: character.personality.aggression
          };
        }
        
        // Only very widespread rumors affect personality
        if (spreadCount < 5) return;
        
        if (spin === 'negative' && isImportant) {
          // Public humiliation damages self-concept severely
          character.self_concept.perceived_trust = Math.max(0, character.self_concept.perceived_trust - 0.15);
          character.self_concept.perceived_bravery = Math.max(0, character.self_concept.perceived_bravery - 0.1);
          
          // Objective personality changes less
          character.personality.trust = Math.max(0, character.personality.trust - 0.05);
          character.personality.aggression = Math.min(1, character.personality.aggression + 0.03);
          
          LC.lcSys?.({ 
            text: `${eventData.character} —Å—Ç–∞–ª(–∞) –º–µ–Ω–µ–µ —É–≤–µ—Ä–µ–Ω(–æ–π) –≤ —Å–µ–±–µ –∏–∑-–∑–∞ —Å–ª—É—Ö–æ–≤.`, 
            level: 'director' 
          });
        }
      },
      
      /**
       * Determines if an event is significant enough to archive for mythologization.
       * Formative events are those that cause major personality shifts or status changes.
       */
      _shouldArchiveEvent(eventData, isImportant) {
        if (!isImportant) return false;
        
        const L = LC.lcInit();
        
        switch (eventData.type) {
          case 'RELATION_CHANGE':
            // Archive extreme relationship changes (>80 points)
            const change = Math.abs(eventData.change || 0);
            return change > 80;
            
          case 'GOAL_COMPLETE':
            // Archive significant goal achievements
            return eventData.success === true;
            
          case 'STATUS_CHANGE':
            // Archive first time someone becomes a leader
            const character = L.characters[eventData.character];
            if (character?.social?.status === 'leader') {
              // Check if this is the first leader in the society
              const leaders = Object.keys(L.characters).filter(name => 
                L.characters[name]?.social?.status === 'leader'
              );
              return leaders.length === 1;
            }
            return false;
            
          default:
            return false;
        }
      },
      
      /**
       * Archives a formative event into L.society.myths for later mythologization.
       */
      _archiveFormativeEvent(eventData, character) {
        const L = LC.lcInit();
        
        if (!L.society.myths) L.society.myths = [];
        
        // Create event record
        const eventRecord = {
          type: 'event_record',
          turn: L.turn,
          eventType: eventData.type,
          character: eventData.character,
          details: this._extractEventDetails(eventData),
          archived: L.turn
        };
        
        L.society.myths.push(eventRecord);
      },
      
      /**
       * Extracts relevant details from an event for archiving.
       * Now captures subjective interpretations when available, not just objective facts.
       */
      _extractEventDetails(eventData) {
        const details = {
          eventType: eventData.type
        };
        
        switch (eventData.type) {
          case 'RELATION_CHANGE':
            details.otherCharacter = eventData.otherCharacter;
            details.change = eventData.change;
            
            // Capture interpretation if available (from InformationEngine)
            if (eventData.interpretation) {
              details.interpretation = eventData.interpretation;
              // The "official history" is the dominant interpretation
              // If interpreted as sarcasm, betrayal theme is stronger
              if (eventData.interpretation === 'sarcasm' || eventData.interpretation === 'suspicion') {
                details.theme = 'betrayal';
              } else {
                details.theme = eventData.change > 0 ? 'loyalty_rescue' : 'betrayal';
              }
            } else {
              // Fallback to objective theme
              details.theme = eventData.change > 0 ? 'loyalty_rescue' : 'betrayal';
            }
            
            // Store subjective modifier if different from raw change
            if (eventData.subjectiveModifier && eventData.subjectiveModifier !== eventData.change) {
              details.perceivedMagnitude = eventData.subjectiveModifier;
            }
            break;
            
          case 'GOAL_COMPLETE':
            details.success = eventData.success;
            details.theme = 'achievement';
            break;
            
          case 'STATUS_CHANGE':
            details.newStatus = eventData.newStatus;
            details.theme = 'leadership';
            break;
        }
        
        return details;
      }
    },

    // ========== Qualia Engine (Phenomenal Core) ==========
    /**
     * The Qualia Engine simulates the raw, pre-cognitive, bodily sensations
     * of characters. This is the lowest-level layer of consciousness that
     * colors all thoughts and decisions.
     */
    QualiaEngine: {
      /**
       * Translates external events into changes in internal sensations.
       * This is the "Limbic Resonator" that directly modifies qualia_state
       * without cognitive interpretation.
       * @param {object} character - The character object from L.characters
       * @param {object} event - The event object {type, actor, action, target, intensity}
       */
      resonate(character, event) {
        if (!character || !event || !event.type) return;
        
        // Ensure qualia_state exists
        if (!character.qualia_state) {
          character.qualia_state = {
            somatic_tension: 0.3,
            valence: 0.5,
            focus_aperture: 0.7,
            energy_level: 0.8
          };
        }
        
        const qs = character.qualia_state;
        const intensity = event.intensity || 1.0;
        
        // Event-to-qualia mapping
        switch (event.type) {
          case 'social':
            if (event.action === 'compliment' || event.action === 'praise') {
              qs.valence = Math.min(1, qs.valence + 0.1 * intensity);
              qs.somatic_tension = Math.max(0, qs.somatic_tension - 0.05 * intensity);
            } else if (event.action === 'insult' || event.action === 'criticism') {
              qs.valence = Math.max(0, qs.valence - 0.2 * intensity);
              qs.somatic_tension = Math.min(1, qs.somatic_tension + 0.15 * intensity);
            } else if (event.action === 'threat' || event.action === 'aggression') {
              qs.valence = Math.max(0, qs.valence - 0.25 * intensity);
              qs.somatic_tension = Math.min(1, qs.somatic_tension + 0.3 * intensity);
              qs.focus_aperture = Math.max(0, qs.focus_aperture - 0.2 * intensity);
            }
            break;
            
          case 'environmental':
            if (event.action === 'loud_noise' || event.action === 'sudden_sound') {
              qs.somatic_tension = Math.min(1, qs.somatic_tension + 0.3 * intensity);
              qs.focus_aperture = Math.max(0, qs.focus_aperture - 0.2 * intensity);
            } else if (event.action === 'calm' || event.action === 'peaceful') {
              qs.somatic_tension = Math.max(0, qs.somatic_tension - 0.1 * intensity);
              qs.valence = Math.min(1, qs.valence + 0.05 * intensity);
            }
            break;
            
          case 'physical':
            if (event.action === 'pain' || event.action === 'injury') {
              qs.valence = Math.max(0, qs.valence - 0.3 * intensity);
              qs.somatic_tension = Math.min(1, qs.somatic_tension + 0.4 * intensity);
              qs.energy_level = Math.max(0, qs.energy_level - 0.2 * intensity);
            } else if (event.action === 'rest' || event.action === 'relaxation') {
              qs.somatic_tension = Math.max(0, qs.somatic_tension - 0.15 * intensity);
              qs.energy_level = Math.min(1, qs.energy_level + 0.1 * intensity);
            }
            break;
            
          case 'achievement':
            if (event.action === 'success' || event.action === 'progress') {
              qs.valence = Math.min(1, qs.valence + 0.15 * intensity);
              qs.energy_level = Math.min(1, qs.energy_level + 0.1 * intensity);
            } else if (event.action === 'failure' || event.action === 'setback') {
              qs.valence = Math.max(0, qs.valence - 0.15 * intensity);
              qs.energy_level = Math.max(0, qs.energy_level - 0.15 * intensity);
            }
            break;
        }
        
        // Clamp all values to [0, 1]
        qs.somatic_tension = Math.max(0, Math.min(1, qs.somatic_tension));
        qs.valence = Math.max(0, Math.min(1, qs.valence));
        qs.focus_aperture = Math.max(0, Math.min(1, qs.focus_aperture));
        qs.energy_level = Math.max(0, Math.min(1, qs.energy_level));
      },
      
      /**
       * Simulates emotional contagion in a group.
       * Characters in the same location gradually synchronize their qualia states.
       * This creates "atmosphere" in a room.
       * @param {Array<string>} characterNames - Names of characters in the group
       * @param {number} convergenceRate - How quickly states converge (0-1), default 0.1
       */
      runGroupResonance(characterNames, convergenceRate = 0.1) {
        if (!Array.isArray(characterNames) || characterNames.length < 2) return;
        
        const L = LC.lcInit();
        const characters = [];
        
        // Collect all characters with valid qualia states
        for (let i = 0; i < characterNames.length; i++) {
          const char = L.characters[characterNames[i]];
          if (char && char.qualia_state) {
            characters.push(char);
          }
        }
        
        if (characters.length < 2) return;
        
        // Calculate group average for each qualia dimension
        const avg = {
          somatic_tension: 0,
          valence: 0,
          focus_aperture: 0,
          energy_level: 0
        };
        
        for (let i = 0; i < characters.length; i++) {
          const qs = characters[i].qualia_state;
          avg.somatic_tension += qs.somatic_tension;
          avg.valence += qs.valence;
          avg.focus_aperture += qs.focus_aperture;
          avg.energy_level += qs.energy_level;
        }
        
        const count = characters.length;
        avg.somatic_tension /= count;
        avg.valence /= count;
        avg.focus_aperture /= count;
        avg.energy_level /= count;
        
        // Move each character's state toward the group average
        for (let i = 0; i < characters.length; i++) {
          const qs = characters[i].qualia_state;
          
          // Gradual convergence toward group average
          qs.somatic_tension += (avg.somatic_tension - qs.somatic_tension) * convergenceRate;
          qs.valence += (avg.valence - qs.valence) * convergenceRate;
          qs.focus_aperture += (avg.focus_aperture - qs.focus_aperture) * convergenceRate;
          qs.energy_level += (avg.energy_level - qs.energy_level) * convergenceRate;
          
          // Ensure bounds
          qs.somatic_tension = Math.max(0, Math.min(1, qs.somatic_tension));
          qs.valence = Math.max(0, Math.min(1, qs.valence));
          qs.focus_aperture = Math.max(0, Math.min(1, qs.focus_aperture));
          qs.energy_level = Math.max(0, Math.min(1, qs.energy_level));
        }
      }
    },

    // ========== Social Norms Engine ==========
    /**
     * The Norms Engine dynamically tracks, creates, and measures the strength of
     * unwritten rules within the group (e.g., "betrayal is unacceptable").
     * Norms emerge organically from how the group reacts to various events.
     */
    NormsEngine: {
      /**
       * Processes an event to update social norms based on group reactions.
       * This function should be called after personal evolution processing.
       * @param {object} eventData - Event data including type, actor, target, and witnesses
       * @param {string} eventData.type - Type of action (e.g., 'betrayal', 'loyalty', 'violence')
       * @param {string} eventData.actor - Character who performed the action
       * @param {string} eventData.target - Character who was affected
       * @param {Array<string>} eventData.witnesses - Characters who witnessed the event
       * @param {number} eventData.relationChange - The relationship change that occurred
       */
      processEvent(eventData) {
        if (!eventData || !eventData.type || !eventData.actor) return;
        
        const L = LC.lcInit();
        const witnesses = eventData.witnesses || [];
        
        // Need at least some witnesses to establish norms
        if (witnesses.length === 0) return;
        
        // Initialize norm if it doesn't exist
        const normType = eventData.type;
        if (!L.society.norms[normType]) {
          L.society.norms[normType] = {
            strength: 0.5,      // Initial neutral strength [0, 1]
            lastUpdate: L.turn,
            violations: 0,
            reinforcements: 0
          };
        }
        
        const norm = L.society.norms[normType];
        
        // Analyze witness reactions
        let negativeReactions = 0;
        let positiveReactions = 0;
        let totalReactions = 0;
        
        for (const witness of witnesses) {
          if (!L.evergreen?.relations?.[witness]?.[eventData.actor]) continue;
          
          const relationBefore = eventData.relationsBefore?.[witness] || 0;
          const relationAfter = L.evergreen.relations[witness][eventData.actor] || 0;
          const reactionChange = relationAfter - relationBefore;
          
          if (Math.abs(reactionChange) > 5) {
            totalReactions++;
            if (reactionChange < -5) negativeReactions++;
            if (reactionChange > 5) positiveReactions++;
          }
        }
        
        // Update norm strength based on reactions
        if (totalReactions > 0) {
          const negativeRatio = negativeReactions / totalReactions;
          const positiveRatio = positiveReactions / totalReactions;
          
          // If >70% of witnesses reacted negatively, this action violates the norm
          if (negativeRatio > 0.7) {
            norm.strength = Math.min(1, norm.strength + 0.05);
            norm.violations++;
            norm.lastUpdate = L.turn;
            
            // Update actor's social capital (handled by HierarchyEngine)
            if (LC.HierarchyEngine && typeof LC.HierarchyEngine.updateCapital === 'function') {
              LC.HierarchyEngine.updateCapital(eventData.actor, {
                type: 'NORM_VIOLATION',
                normStrength: norm.strength,
                witnessCount: totalReactions
              });
            }
          }
          // If >70% reacted positively, this action is actually approved
          else if (positiveRatio > 0.7) {
            norm.strength = Math.max(0, norm.strength - 0.05);
            norm.reinforcements++;
            norm.lastUpdate = L.turn;
          }
        }
        
        // Decay old norms slowly over time
        const turnsSinceUpdate = L.turn - norm.lastUpdate;
        if (turnsSinceUpdate > 50) {
          norm.strength = Math.max(0, norm.strength - 0.01);
        }
      },
      
      /**
       * Gets the strength of a specific norm.
       * @param {string} normType - The type of norm to query
       * @returns {number} The strength of the norm [0, 1], or 0.5 if not established
       */
      getNormStrength(normType) {
        const L = LC.lcInit();
        const baseStrength = L.society.norms[normType]?.strength || 0.5;
        
        // Boost norm strength with corresponding myths
        if (LC.MemoryEngine && typeof LC.MemoryEngine.getMythStrengthForTheme === 'function') {
          const mythBoost = LC.MemoryEngine.getMythStrengthForTheme(normType);
          // Myths can increase norm strength by up to 20%
          return Math.min(1, baseStrength + mythBoost * 0.2);
        }
        
        return baseStrength;
      }
    },

    // ========== Social Hierarchy Engine ==========
    /**
     * The Hierarchy Engine calculates social status for each NPC
     * (Opinion Leader, Regular Member, Outcast) based on their actions
     * and conformity to social norms.
     * 
     * Updated for Epic 4: Social capital now depends on SUBJECTIVE INTERPRETATIONS
     * of actions, not objective events. How witnesses PERCEIVE you matters more
     * than what you actually did.
     */
    HierarchyEngine: {
      /**
       * Updates a character's social capital based on their actions.
       * Now considers subjective perceptions of witnesses.
       * @param {string} characterName - The character whose capital to update
       * @param {object} eventData - Event data describing what happened
       * @param {string} eventData.type - Type of event (e.g., 'NORM_VIOLATION', 'NORM_CONFORMITY')
       * @param {number} eventData.normStrength - Strength of the relevant norm
       * @param {number} eventData.witnessCount - Number of witnesses to the event
       * @param {string} eventData.interpretation - How the action was interpreted by witnesses
       * @param {object} eventData.target - Target character for social actions
       */
      updateCapital(characterName, eventData) {
        if (!characterName || !eventData) return;
        
        const L = LC.lcInit();
        const character = L.characters[characterName];
        if (!character) return;
        
        // Ensure social structure exists
        if (!character.social) {
          character.social = {
            status: 'member',
            capital: 100,
            conformity: 0.5
          };
        }
        
        switch (eventData.type) {
          case 'NORM_VIOLATION':
            // Violating a strong norm costs more capital
            const normStrength = eventData.normStrength || 0.5;
            const witnessCount = eventData.witnessCount || 1;
            const capitalLoss = Math.floor(10 * normStrength * Math.min(witnessCount / 3, 2));
            character.social.capital = Math.max(0, character.social.capital - capitalLoss);
            character.social.conformity = Math.max(0, character.social.conformity - 0.1);
            break;
            
          case 'NORM_CONFORMITY':
            // Following strong norms builds capital
            const conformityGain = Math.floor(5 * (eventData.normStrength || 0.5));
            character.social.capital = Math.min(200, character.social.capital + conformityGain);
            character.social.conformity = Math.min(1, character.social.conformity + 0.05);
            break;
            
          case 'POSITIVE_ACTION':
            // Helping others, showing leadership
            // NEW: Modified by witness perceptions
            let baseGain = 8;
            
            // If we have witness perception data, adjust capital gain based on how they see the actor
            if (eventData.target) {
              const avgRespect = this._getAverageWitnessRespect(characterName, eventData.target);
              // Characters with high respect gain more capital from positive actions
              // Range: 50-150% of base gain
              const multiplier = 0.5 + (avgRespect / 100);
              baseGain = Math.floor(baseGain * multiplier);
            }
            
            character.social.capital = Math.min(200, character.social.capital + baseGain);
            break;
            
          case 'NEGATIVE_ACTION':
            // Harmful behavior
            // NEW: Modified by witness perceptions
            let baseLoss = 5;
            
            // If witnesses have low trust/respect for actor, negative actions hurt more
            if (eventData.target) {
              const avgTrust = this._getAverageWitnessTrust(characterName);
              // Characters with low trust lose more capital from negative actions
              // Range: 50-150% of base loss
              const multiplier = 1.5 - (avgTrust / 100);
              baseLoss = Math.floor(baseLoss * multiplier);
            }
            
            character.social.capital = Math.max(0, character.social.capital - baseLoss);
            break;
        }
        
        L.stateVersion++;
      },
      
      /**
       * Gets average respect that active characters have for the given character.
       * Used to determine social capital gains from positive actions.
       */
      _getAverageWitnessRespect(characterName, excludeTarget) {
        const L = LC.lcInit();
        let totalRespect = 0;
        let count = 0;
        
        for (const witName in L.characters) {
          const wit = L.characters[witName];
          if (!wit || wit.status !== 'ACTIVE') continue;
          if (witName === characterName) continue; // Don't count self
          if (witName === excludeTarget) continue; // Don't count the target of the action
          
          if (wit.perceptions && wit.perceptions[characterName]) {
            const perception = wit.perceptions[characterName];
            totalRespect += (perception.respect || 50);
            count++;
          }
        }
        
        return count > 0 ? totalRespect / count : 50; // Default to neutral if no data
      },
      
      /**
       * Gets average trust that active characters have for the given character.
       * Used to determine social capital loss from negative actions.
       */
      _getAverageWitnessTrust(characterName) {
        const L = LC.lcInit();
        let totalTrust = 0;
        let count = 0;
        
        for (const witName in L.characters) {
          const wit = L.characters[witName];
          if (!wit || wit.status !== 'ACTIVE') continue;
          if (witName === characterName) continue; // Don't count self
          
          if (wit.perceptions && wit.perceptions[characterName]) {
            const perception = wit.perceptions[characterName];
            totalTrust += (perception.trust || 50);
            count++;
          }
        }
        
        return count > 0 ? totalTrust / count : 50; // Default to neutral if no data
      },
      
      /**
       * Recalculates social status for all characters based on their capital.
       * This should be called periodically (e.g., every 20 turns).
       */
      recalculateStatus() {
        const L = LC.lcInit();
        
        // Gather all active characters with their social capital
        const characters = [];
        for (const name in L.characters) {
          const char = L.characters[name];
          if (char.status !== 'ACTIVE') continue;
          
          if (!char.social) {
            char.social = {
              status: 'member',
              capital: 100,
              conformity: 0.5
            };
          }
          
          characters.push({
            name: name,
            capital: char.social.capital,
            char: char
          });
        }
        
        // Sort by capital
        characters.sort((a, b) => b.capital - a.capital);
        
        // Assign statuses
        const LEADER_THRESHOLD = 140;
        const OUTCAST_THRESHOLD = 40;
        
        let statusChanged = false;
        
        for (let i = 0; i < characters.length; i++) {
          const item = characters[i];
          const oldStatus = item.char.social.status;
          let newStatus = 'member';
          
          // Only the top character with high capital becomes a leader
          if (i === 0 && item.capital >= LEADER_THRESHOLD) {
            newStatus = 'leader';
          }
          // Low capital makes you an outcast
          else if (item.capital < OUTCAST_THRESHOLD) {
            newStatus = 'outcast';
          }
          
          if (oldStatus !== newStatus) {
            item.char.social.status = newStatus;
            statusChanged = true;
            
            // Trigger Crucible for formative status changes
            if (newStatus === 'leader' && LC.Crucible && typeof LC.Crucible.analyzeEvent === 'function') {
              LC.Crucible.analyzeEvent({
                type: 'STATUS_CHANGE',
                character: item.name,
                newStatus: newStatus,
                oldStatus: oldStatus,
                capital: item.capital
              });
            }
            
            // Log status changes
            if (newStatus === 'leader') {
              LC.lcSys?.({
                text: `${item.name} —Å—Ç–∞–ª(–∞) –ª–∏–¥–µ—Ä–æ–º –º–Ω–µ–Ω–∏–π –≤ –≥—Ä—É–ø–ø–µ.`,
                level: 'director'
              });
            } else if (newStatus === 'outcast') {
              LC.lcSys?.({
                text: `${item.name} —Å—Ç–∞–ª(–∞) –∏–∑–≥–æ–µ–º –∏–∑-–∑–∞ –Ω–∏–∑–∫–æ–≥–æ —Å–æ—Ü–∏–∞–ª—å–Ω–æ–≥–æ —Å—Ç–∞—Ç—É—Å–∞.`,
                level: 'director'
              });
            } else if (oldStatus === 'outcast') {
              LC.lcSys?.({
                text: `${item.name} –≤–µ—Ä–Ω—É–ª(–∞) —Å–≤–æ–π —Å—Ç–∞—Ç—É—Å –≤ –≥—Ä—É–ø–ø–µ.`,
                level: 'director'
              });
            }
          }
        }
        
        if (statusChanged) {
          L.stateVersion++;
        }
      },
      
      /**
       * Gets the social status of a character.
       * @param {string} characterName - The character to query
       * @returns {string} The character's status ('leader', 'member', or 'outcast')
       */
      getStatus(characterName) {
        const L = LC.lcInit();
        const char = L.characters[characterName];
        return char?.social?.status || 'member';
      }
    },

    // ========== Collective Memory Engine (Myths & Legends) ==========
    /**
     * The Memory Engine transforms formative events into myths over time,
     * creating a collective cultural memory that influences future behavior.
     */
    MemoryEngine: {
      /**
       * Runs the mythologization process, converting old event records into abstract myths.
       * Should be called periodically (every 100 turns).
       */
      runMythologization() {
        const L = LC.lcInit();
        
        if (!L.society.myths) L.society.myths = [];
        
        const currentTurn = L.turn;
        const MYTHOLOGIZATION_AGE = 50; // Events older than 50 turns can become myths
        
        // Process event records that are old enough to mythologize
        for (let i = 0; i < L.society.myths.length; i++) {
          const record = L.society.myths[i];
          
          // Skip if already mythologized or too recent
          if (record.type === 'myth') continue;
          if (record.type !== 'event_record') continue;
          if (currentTurn - record.turn < MYTHOLOGIZATION_AGE) continue;
          
          // Transform event record into myth
          const myth = this._createMythFromEvent(record);
          if (myth) {
            // Replace event record with myth
            L.society.myths[i] = myth;
            
            LC.lcSys?.({
              text: `–°–æ–±—ã—Ç–∏–µ "${record.character}" –ø—Ä–µ–≤—Ä–∞—Ç–∏–ª–æ—Å—å –≤ –º–∏—Ñ: ${myth.moral}`,
              level: 'director'
            });
          }
        }
        
        // Keep only the most powerful myths (max 20)
        this._pruneMythsIfNeeded();
        
        L.stateVersion++;
      },
      
      /**
       * Transforms an event record into an abstract myth.
       */
      _createMythFromEvent(eventRecord) {
        if (!eventRecord.details) return null;
        
        const L = LC.lcInit();
        const details = eventRecord.details;
        const theme = details.theme || 'unknown';
        
        // Calculate myth strength based on event magnitude
        let strength = 0.5;
        if (details.change) {
          strength = Math.min(1, Math.abs(details.change) / 100);
        }
        
        // Extract moral and hero
        let moral = '';
        let hero = eventRecord.character;
        
        switch (theme) {
          case 'loyalty_rescue':
            moral = '–∑–∞—â–∏—â–∞—Ç—å –¥—Ä—É–∑–µ–π ‚Äî –ø—Ä–∞–≤–∏–ª—å–Ω–æ';
            strength = Math.max(strength, 0.8);
            break;
            
          case 'betrayal':
            moral = '–ø—Ä–µ–¥–∞—Ç–µ–ª—å—Å—Ç–≤–æ –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º–æ';
            strength = Math.max(strength, 0.9);
            break;
            
          case 'achievement':
            moral = '—É–ø–æ—Ä—Å—Ç–≤–æ –≤–µ–¥—ë—Ç –∫ —É—Å–ø–µ—Ö—É';
            strength = Math.max(strength, 0.7);
            break;
            
          case 'leadership':
            moral = '–ª–∏–¥–µ—Ä—ã –∑–∞—Å–ª—É–∂–∏–≤–∞—é—Ç —É–≤–∞–∂–µ–Ω–∏—è';
            strength = Math.max(strength, 0.85);
            break;
            
          default:
            moral = '–æ–ø—ã—Ç —É—á–∏—Ç –Ω–∞—Å';
            break;
        }
        
        return {
          type: 'myth',
          theme: theme,
          hero: hero,
          moral: moral,
          strength: strength,
          createdTurn: L.turn,
          originalTurn: eventRecord.turn
        };
      },
      
      /**
       * Prunes the myth collection to keep only the strongest/most recent myths.
       */
      _pruneMythsIfNeeded() {
        const L = LC.lcInit();
        const MAX_MYTHS = 20;
        
        if (!L.society.myths || L.society.myths.length <= MAX_MYTHS) return;
        
        // Sort myths by strength (descending)
        const myths = L.society.myths.filter(m => m.type === 'myth');
        const eventRecords = L.society.myths.filter(m => m.type === 'event_record');
        
        myths.sort((a, b) => b.strength - a.strength);
        
        // Keep top MAX_MYTHS myths
        const keptMyths = myths.slice(0, MAX_MYTHS);
        
        // Combine with recent event records
        L.society.myths = [...keptMyths, ...eventRecords];
      },
      
      /**
       * Gets the dominant myth(s) that define the current zeitgeist.
       * @returns {object|null} The strongest myth, or null if none exist
       */
      getDominantMyth() {
        const L = LC.lcInit();
        
        if (!L.society.myths || L.society.myths.length === 0) return null;
        
        // Find the strongest myth
        let dominantMyth = null;
        let maxStrength = 0;
        
        for (const item of L.society.myths) {
          if (item.type !== 'myth') continue;
          if (item.strength > maxStrength) {
            maxStrength = item.strength;
            dominantMyth = item;
          }
        }
        
        return dominantMyth;
      },
      
      /**
       * Gets the strength of myths related to a specific theme.
       * Used to boost norm strength and calibrate new character personalities.
       */
      getMythStrengthForTheme(theme) {
        const L = LC.lcInit();
        
        if (!L.society.myths) return 0;
        
        let totalStrength = 0;
        let count = 0;
        
        for (const item of L.society.myths) {
          if (item.type !== 'myth') continue;
          if (item.theme === theme) {
            totalStrength += item.strength;
            count++;
          }
        }
        
        return count > 0 ? totalStrength / count : 0;
      }
    },

    evergreenManualSet(L, category, key, value){
      const state = L || this.lcInit();
      if (!state || !state.evergreen || !category) return;
      const allowed = ["relations","status","obligations","facts"];
      const cat = String(category || "").toLowerCase();
      if (allowed.indexOf(cat) === -1) return;
      const val = String(value || "").trim();
      if (!val) return;
      const entryKey = key ? String(key) : `u_${Date.now().toString(36)}`;
      if (!entryKey) return;
      const box = (state.evergreen[cat] = state.evergreen[cat] || {});
      const prev = Object.prototype.hasOwnProperty.call(box, entryKey) ? box[entryKey] : undefined;
      box[entryKey] = val;
      state.evergreen.history = Array.isArray(state.evergreen.history) ? state.evergreen.history : [];
      const record = { turn: state.turn, category: cat, new: val, key: entryKey };
      record.old = prev !== undefined ? prev : "";
      state.evergreen.history.push(record);
      const defaultCapRaw = CONFIG?.LIMITS?.EVERGREEN_HISTORY_CAP;
      const defaultCapNum = Number(defaultCapRaw);
      const evergreenDefaultCap = Number.isFinite(defaultCapNum) ? defaultCapNum : 0;
      let manualCap = state.evergreenHistoryCap;
      if (manualCap == null) {
        manualCap = evergreenDefaultCap;
      }
      const manualCapNum = Number(manualCap);
      const cap = Number.isFinite(manualCapNum) ? manualCapNum : evergreenDefaultCap;
      state.evergreenHistoryCap = cap;
      if (cap > 0 && state.evergreen.history.length > cap) {
        const overflow = state.evergreen.history.length - cap;
        if (overflow > 0) state.evergreen.history.splice(0, overflow);
      }
      state.evergreen.lastUpdate = state.turn;
      if (LC.EvergreenEngine && typeof LC.EvergreenEngine.limitCategories === "function") {
        LC.EvergreenEngine.limitCategories(state);
      }
    },
    capEvergreenHistory(max){
      const L = this.lcInit();
      const m = Math.max(0, toNum(max, 0));
      L.evergreenHistoryCap = m;
      if (m > 0 && Array.isArray(L.evergreen.history) && L.evergreen.history.length > m) {
        L.evergreen.history = L.evergreen.history.slice(-m);
      }
    },

    // ---------- Events & Recap Scheduler ----------
    _eventPatterns: {
      conflict:   [/—É–¥–∞—Ä–∏–ª|—É–¥–∞—Ä–∏–ª–∞|—É–¥–∞—Ä–∏–ª–∏|—Å—Å–æ—Ä|–∫—Ä–∏–∫|–ø–ª—é—Ö–∞|–¥—Ä–∞–∫(?:–∞|–µ|—É)/i],
      romance:    [/–ø–æ—Ü–µ–ª–æ–≤–∞–ª|–ø–æ—Ü–µ–ª–æ–≤–∞–ª–∞|–ø—Ä–∏–∑–Ω–∞–ª—Å[—è–∞]|—Å–≤–∏–¥–∞–Ω–∏–µ/i],
      authority:  [/–¥–∏—Ä–µ–∫—Ç–æ—Ä|—É—á–∏—Ç–µ–ª—å|–≤—ã–≥–æ–≤–æ—Ä|–≤—ã–∑–≤–∞–ª–∏\s+–∫\s+–¥–∏—Ä–µ–∫—Ç–æ—Ä—É/i],
      achievement:[/–ø–æ–±–µ–¥[–∞–∏–ª]|—É—Å–ø–µ—Ö|—Ç—Ä–æ—Ñ–µ–π|–Ω–∞–≥—Ä–∞–¥–∞|–≤—ã–∏–≥—Ä–∞–ª/i],
      reveal:     [/—Å–µ–∫—Ä–µ—Ç|—Ä–∞–∑–æ–±–ª–∞—á–µ–Ω–∏–µ|—Ç–∞–π–Ω–∞\s+—Ä–∞—Å–∫—Ä—ã—Ç–∞|–≤—Å–µ\s+—É–∑–Ω–∞–ª(?:–∏)?/i],
      location:   [/–∫–∞–±–∏–Ω–µ—Ç|—Å—Ç–æ–ª–æ–≤–∞—è|–∫–æ—Ä–∏–¥–æ—Ä|—Å–ø–æ—Ä—Ç–∑–∞–ª|–±–∏–±–ª–∏–æ—Ç–µ–∫/i],
      timeskip:   [/–ø—Ä–æ—à–ª–æ\s+\d+|—á–µ—Ä–µ–∑\s+\d+|—Å–ø—É—Å—Ç—è\s+\d+/i],
      betrayal:   [/–ø—Ä–µ–¥–∞–ª|–ø—Ä–µ–¥–∞–ª–∞|–ø—Ä–µ–¥–∞–ª–∏|–∏–∑–º–µ–Ω|–æ–±–º–∞–Ω/i],
      loyalty:    [/–≤–µ—Ä–Ω–æ—Å—Ç|–ø—Ä–µ–¥–∞–Ω–Ω–æ—Å—Ç|–ª–æ—è–ª—å–Ω–æ—Å—Ç|–ø–æ–¥–¥–µ—Ä–∂/i],
      // Social upheavals
      social_upheaval: [/–ø–æ—Å—Å–æ—Ä–∏–ª(?:—Å—è|–∞—Å—å|–∏—Å—å)|—Ä–∞—Å—Å—Ç–∞–ª(?:—Å—è|–∞—Å—å|–∏—Å—å)|–ø—Ä–∏–∑–Ω–∞–ª(?:—Å—è|–∞—Å—å)\s+–≤\s+–ª—é–±–≤–∏|—Å—Ç–∞–ª–∏\s+–≤—Ä–∞–≥–∞–º–∏|–ø—Ä–µ–¥–∞–ª(?:–∞)?/i],
      // Secret revelations
      secret_reveal: [/–æ–Ω\s+–≤—Å—ë\s+—É–∑–Ω–∞–ª|–æ–Ω–∞\s+–≤—Å—ë\s+—É–∑–Ω–∞–ª–∞|—Ç–∞–π–Ω–∞\s+—Ä–∞—Å–∫—Ä—ã—Ç–∞|—Ç–µ–ø–µ—Ä—å\s+–≤—Å–µ\s+–∑–Ω–∞—é—Ç|—Å–µ–∫—Ä–µ—Ç\s+—Ä–∞—Å–∫—Ä—ã—Ç/i],
      // Goal achievement/failure
      goal_outcome: [/(?:–æ–Ω|–æ–Ω–∞|–æ–Ω–∏)\s+–Ω–∞–∫–æ–Ω–µ—Ü\s+–¥–æ–±–∏–ª—Å—è?\s+—Å–≤–æ–µ–≥–æ|—É\s+(?:–Ω–µ–≥–æ|–Ω–µ—ë|–Ω–µ–µ|–Ω–∏—Ö)\s+–ø–æ–ª—É—á–∏–ª–æ—Å—å|–≤—Å—ë\s+–ø–æ—à–ª–æ\s+–ø—Ä–∞—Ö–æ–º|–ø–æ—Ç–µ—Ä–ø–µ–ª(?:–∞|–∏)?\s+–Ω–µ—É–¥–∞—á—É|–ø—Ä–æ–≤–∞–ª/i],
      // Dramatic events
      dramatic: [/–¥—Ä–∞–∫(?:–∞|–µ|—É)|–∞–≤–∞—Ä–∏(?:—è|–∏|—é)|–∏—Å–∫–ª—é—á–∏–ª–∏\s+–∏–∑\s+—à–∫–æ–ª—ã|–ø–æ–±–µ–≥|—Å–±–µ–∂–∞–ª(?:–∞)?/i]
    },
    _pruneEventsWindow(){
      const L = this.lcInit();
      const t = L.turn || 0;
      const W = this.CONFIG.LIMITS.EVENTS_WINDOW_TURNS || 50;
      if (!Array.isArray(L.events) || L.events.length === 0) return;
      const minTurn = Math.max(0, t - W);
      const next = [];
      for (let i=0;i<L.events.length;i++){
        const e = L.events[i];
        if (e && toNum(e.turn, -1) >= minTurn) next.push(e);
      }
      if (next.length !== L.events.length) {
        L.events = next;
        this.lcDebug(`Events pruned to last ${W} turns (${next.length} kept).`);
      }
    },
    analyzeTextForEvents(text, source){
      if (!text) return;
      const L = this.lcInit();
      const low = toStr(text).toLowerCase();
      const t = L.turn || 0;

      for (const type in this._eventPatterns){
        const regs = this._eventPatterns[type];
        for (let i=0;i<regs.length;i++){
          if (regs[i].test(low)){
            const w = CONFIG.RECAP_V2.WEIGHTS[type] || 0.5;
            let exists = false;
            for (let j=0;j<(L.events||[]).length;j++){
              const e = L.events[j];
              if (e.type === type && e.turn === t){ exists = true; break; }
            }
            if (!exists) L.events.push({ type, turn:t, weight:w, src: (source||"output") }); LC.ensureEventsCap(300);
            
            break;
          }
        }
      }
      
      this._pruneEventsWindow();
    },
    computeRecapScore(){
      this._pruneEventsWindow();
      const L = this.lcInit();
      const t = L.turn || 0;
      const turnsSince = t - (L.lastRecapTurn || 0);
      let score = turnsSince / (L.cadence || CONFIG.LIMITS.CADENCE.DEFAULT);
      if (turnsSince > 0 && turnsSince % Math.max(2, Math.floor(L.cadence/2)) === 0) {
        score += CONFIG.RECAP_V2.BASE_CADENCE_BONUS;
      }
      const half = CONFIG.RECAP_V2.DECAY_HALF_LIFE;
      for (let i=0;i<(L.events||[]).length;i++){
        const e = L.events[i];
        const dt = Math.max(0, t - e.turn);
        const decay = Math.pow(0.5, dt / half);
        score += (e.weight || 0.5) * decay;
      }
      const hotWindow = (this.CONFIG?.CHAR_WINDOW_HOT ?? 3);
      const hot = this.getActiveCharacters(10).filter(c => c.turnsAgo <= hotWindow);
      if (hot.length > 0) score += CONFIG.RECAP_V2.HOT_NPC_BONUS;
      return score;
    },
    getEventsDiagnostics(n){
      this._pruneEventsWindow();
      const L = this.lcInit();
      const t = L.turn || 0, half = CONFIG.RECAP_V2.DECAY_HALF_LIFE;
      const src = Array.isArray(L.events) ? L.events.slice(-Math.max(1, toNum(n,10))) : [];
      const rows = [];
      let total = 0;
      for (let i=src.length-1;i>=0;i--){
        const e = src[i];
        const dt = Math.max(0, t - (e.turn||t));
        const decay = Math.pow(0.5, dt / half);
        const w = toNum(e.weight, 0.5);
        const contrib = +(w * decay).toFixed(3);
        total += contrib;
        rows.push({ type:e.type, turn:e.turn, ago:dt, w:+w.toFixed(2), decay:+decay.toFixed(3), contrib });
      }
      return { total:+total.toFixed(3), rows: rows.reverse() };
    },
    checkRecapOfferV2(){
      const L = this.lcInit();
      if (L.currentAction?.type === 'retry' || L.currentAction?.type === 'command') return false;
      if (L.recapDraft || L.epochDraft) return false;
      if (L.turn < (L.recapMuteUntil || 0)) return false;

      const wantRecap = L.currentAction?.wantRecap || false;
      if (wantRecap) {
        const since = L.turn - (L.tm.wantRecapTurn || L.turn);
        if (since >= 3) { 
          if (L.currentAction) L.currentAction.wantRecap = false;
          L.tm.wantRecapTurn = 0; 
        }
        else return false;
      }

      const score = this.computeRecapScore();
      L.tm.lastRecapScore = score;

      const baseCooldown = Math.max(2, Math.floor(L.cadence / 2));
      const cfgCooldown  = Math.max(1, CONFIG.RECAP_V2.COOLDOWN_TURNS || 0);
      const sinceLast    = L.turn - (L.lastRecapTurn || 0);
      const enoughCooldown = sinceLast >= Math.max(baseCooldown, cfgCooldown);

      if (score >= CONFIG.RECAP_V2.SCORE_THRESHOLD && enoughCooldown){
        if (!L.currentAction) L.currentAction = {};
        L.currentAction.wantRecap = true;
        L.tm.wantRecapTurn = L.turn;
        if (L.sysShow) this.lcSys("ü§ñ Want a recap? Reply: /–¥–∞, /–Ω–µ—Ç, /–ø–æ–∑–∂–µ.");
        return true;
      }
      return false;
    },
    checkAutoEpoch(){
      const L = this.lcInit();
      if (L && L.recapDraft) return false; // delay auto-epoch while recap draft pending
      if (L.currentAction?.type === 'retry' || L.currentAction?.type === 'command') return false;
      if (L.epochDraft) return false;

      const t = L.turn || 0;
      const win = CONFIG.RECAP_V2.AUTO_EPOCH_WINDOW;
      let recentRecaps = 0;
      if (L.tm && Array.isArray(L.tm.recapTurns)) {
        for (let i=0;i<L.tm.recapTurns.length;i++){
          if (t - L.tm.recapTurns[i] <= win) recentRecaps++;
        }
      }
      const score = this.computeRecapScore();
      const high = score >= CONFIG.RECAP_V2.AUTO_EPOCH_SCORE;

      if (recentRecaps >= CONFIG.RECAP_V2.AUTO_EPOCH_MIN_RECAPS || high) {
        if (!L.currentAction) L.currentAction = {};
        L.currentAction.task = 'epoch';
        this.pushNotice("üóø Epoch scheduled for next turn.");
        if (L.sysShow) this.lcSys("üóø Epoch scheduled automatically.");
        return true;
      }
      return false;
    },

    // ---------- Morphology (mini) ----------
    ruPlural(n, f1, f2, f5){
      n = Math.abs(n) % 100; const n1 = n % 10;
      if (n > 10 && n < 20) return f5;
      if (n1 > 1 && n1 < 5) return f2;
      if (n1 === 1) return f1;
      return f5;
    },
    ruCase(name, c){
      const s = String(name || "");
      if (!s) return s;
      const low = s.toLowerCase();
      const map = {
        "–º–∞–∫—Å–∏–º": { gen:"–ú–∞–∫—Å–∏–º–∞", dat:"–ú–∞–∫—Å–∏–º—É", acc:"–ú–∞–∫—Å–∏–º–∞", ins:"–ú–∞–∫—Å–∏–º–æ–º", pre:"–ú–∞–∫—Å–∏–º–µ" },
        "—Ö–ª–æ—è":   { gen:"–•–ª–æ–∏",   dat:"–•–ª–æ–µ",   acc:"–•–ª–æ—é",   ins:"–•–ª–æ–µ–π",   pre:"–•–ª–æ–µ"   },
        "—ç—à–ª–∏":   { gen:"–≠—à–ª–∏",   dat:"–≠—à–ª–∏",   acc:"–≠—à–ª–∏",   ins:"–≠—à–ª–∏",    pre:"–≠—à–ª–∏"   }
      };
      const base = map[low];
      if (!base) return s;
      switch (c){
        case "gen": return base.gen;
        case "dat": return base.dat;
        case "acc": return base.acc;
        case "ins": return base.ins;
        case "pre": return base.pre;
        default: return s;
      }
    },
    enPlural(word){
      const w = String(word || "");
      if (!w) return w;
      const irr = { child:"children", person:"people", man:"men", woman:"women", mouse:"mice", foot:"feet" };
      const low = w.toLowerCase();
      if (irr[low]) return irr[low];
      if (/[sxz]$|[cs]h$/i.test(w)) return w + "es";
      if (/[aeiou]y$/i.test(w)) return w + "s";
      if (/y$/i.test(w)) return w.replace(/y$/i, "ies");
      return w + "s";
    },

    // ---------- Recap ‚Üí story cards ----------
    syncRecapToStoryCards(text, windowTurns){
      const s = String(text||"").trim();
      if (s.length < 60) return 0;
      const bullets = s
        .split(/\r?\n|^[‚Ä¢\-‚Äì]\s+/m)
        .map(x=>x.trim())
        .filter(x=>x.length>25)
        .slice(0,4);
      let n=0;
      for (let i=0;i<bullets.length;i++){
        this.createStoryCard(bullets[i], windowTurns, "note");
        n++;
      }
      return n;
    }
  });

  const _mergedConfig = {
    ...CONFIG,
    ..._preparedConfig,
    LIMITS: {
      ...CONFIG.LIMITS,
      ...(_preparedConfig.LIMITS || {}),
      CADENCE: {
        ...CONFIG.LIMITS.CADENCE,
        ...(_preparedConfig.LIMITS?.CADENCE || {})
      },
      ANTI_ECHO: {
        ...CONFIG.LIMITS.ANTI_ECHO,
        ...(_preparedConfig.LIMITS?.ANTI_ECHO || {}),
        CONTINUE_THRESHOLD_MULT: {
          ...CONFIG.LIMITS.ANTI_ECHO.CONTINUE_THRESHOLD_MULT,
          ...(_preparedConfig.LIMITS?.ANTI_ECHO?.CONTINUE_THRESHOLD_MULT || {})
        }
      }
    },
    FEATURES: {
      ...CONFIG.FEATURES,
      ...(_preparedConfig.FEATURES || {})
    },
    RECAP_V2: {
      ...CONFIG.RECAP_V2,
      ...(_preparedConfig.RECAP_V2 || {}),
      WEIGHTS: {
        ...CONFIG.RECAP_V2.WEIGHTS,
        ...(_preparedConfig.RECAP_V2?.WEIGHTS || {})
      }
    }
  };

  LC.CONFIG = _mergedConfig;
  // Ensure STRICT_CMD_BYPASS survives any merge order
  try {
    if (!LC.CONFIG.FEATURES) LC.CONFIG.FEATURES = {};
    if (typeof LC.CONFIG.FEATURES.STRICT_CMD_BYPASS === "undefined") {
      LC.CONFIG.FEATURES.STRICT_CMD_BYPASS = true;
    }
  } catch(_) {}
  
  // Sync RELATIONSHIP_MODIFIERS to RelationsEngine
  if (LC.RelationsEngine && CONFIG.RELATIONSHIP_MODIFIERS) {
    LC.RelationsEngine.MODIFIERS = CONFIG.RELATIONSHIP_MODIFIERS;
  }
  
  if (typeof globalThis !== "undefined") {
    globalThis.LC = LC;
  } else if (_globalScope && typeof _globalScope === "object") {
    _globalScope.LC = LC;
  }

  if (typeof globalThis !== "undefined") globalThis.LC = LC;
  if (typeof window !== "undefined") window.LC = LC;
})();


// --- TURN UTILS ---
function turnSet(n) {
  const L = this.lcInit();
  const v = Math.max(0, Math.floor(Number(n) || 0));
  L.turn = v;
  L.lastProcessedTurn = v;
  if (L.lastRecapTurn && L.lastRecapTurn >= v) L.lastRecapTurn = 0;
  if (L.lastEpochTurn && L.lastEpochTurn >= v) L.lastEpochTurn = 0;
  if (Array.isArray(L.events)) {
    L.events = L.events.filter(ev => !(ev && Number(ev.turn) >= v));
  }
  L.recapDraft = null;
  L.epochDraft = null;
  L.prevOutput = "";
  L.lastOutput = "";

  if (L.tm && Array.isArray(L.tm.recapTurns)) {
    const recapTurns = L.tm.recapTurns
      .map(t => Number(t))
      .filter(t => Number.isFinite(t) && t < v)
      .sort((a, b) => a - b);
    L.tm.recapTurns = recapTurns;
    const last = recapTurns.length ? recapTurns[recapTurns.length - 1] : -Infinity;
    L.lastRecapTurn = Number.isFinite(last) ? last : 0;
  }
  if (L.tm && Number(L.tm.wantRecapTurn) >= v) {
    L.tm.wantRecapTurn = 0;
  }
  if (L.tm) {
    L.tm.lastRecapScore = 0;
  }

      // clear flags on rewind
    if (L.currentAction) {
      delete L.currentAction.wantRecap;
      delete L.currentAction.task;
    }
    this.lcSys(`‚Ü©Ô∏è Turn set to ${L.turn}.`);
    return L.turn;
}


function turnUndo(n=1) {
  const L = this.lcInit();
  const dec = Math.max(1, Math.floor(Number(n) || 1));
  const v = Math.max(0, (L.turn || 0) - dec);
  return this.turnSet(v);
}

// Export into LC
LC.turnSet = turnSet;
LC.turnUndo = turnUndo;




/**
 * Assembles the complete context overlay string for the AI.
 * Applies caching based on L.stateVersion to skip redundant work.
 * @param {object} [options] - The composition options
 * @param {number} [options.limit] - The maximum character limit for the overlay
 * @param {boolean} [options.allowPartial] - Whether to allow partial results if budget is exceeded
 * @returns {{text: string, parts: object, max: number, error?: string}} The composed overlay object
 */
LC.composeContextOverlay = function(options) {
  const opts = (options && typeof options === "object") ? options : {};
  try {
    const L = LC.lcInit();
    
    // Context caching: Check if we can return cached result
    // Cache is invalidated when L.stateVersion changes (on state mutations)
    const cacheKey = JSON.stringify(opts);
    const cached = LC._contextCache[cacheKey];
    
    if (cached && cached.stateVersion === L.stateVersion) {
      // State hasn't changed, return cached context
      return cached.result;
    }
    
    const priority = [];
    const normal = [];

    // Style guides
    priority.push("‚ü¶GUIDE‚üß Lincoln Heights school drama. Third person past tense.");
    priority.push("‚ü¶GUIDE‚üß 2‚Äì4 short paragraphs. Show emotions via actions and subtext.");
    priority.push("‚ü¶GUIDE‚üß Keep it plausible and consistent. PG-16.");
    normal.push("‚ü¶GUIDE‚üß Do NOT repeat last 2‚Äì3 sentences from previous output.");

    if (L.lastIntent && L.lastIntent.length > 2) priority.push(`‚ü¶INTENT‚üß ${L.lastIntent}`);

    if (L.currentAction?.type !== 'command' && L.currentAction?.task === 'recap') {
      priority.push("‚ü¶TASK‚üß NOW WRITE A RECAP: Summarize the last 10‚Äì15 turns in 5‚Äì7 clear sentences, focusing on key events/relationships and current situation.");
    }
    if (L.currentAction?.type !== 'command' && L.currentAction?.task === 'epoch') {
      priority.push("‚ü¶TASK‚üß NOW WRITE AN EPOCH: Compress multiple recaps into 5‚Äì7 sentences with major consequences and status changes.");
    }

    const canon = LC.EvergreenEngine?.getCanon?.() || "";
    if (canon) priority.push(`‚ü¶CANON‚üß ${canon}`);

    // Time and Schedule
    if (L.time) {
      const timeStr = `–°–µ–π—á–∞—Å ${L.time.dayName}, ${L.time.timeOfDay.toLowerCase()}.`;
      priority.push(`‚ü¶TIME‚üß ${timeStr}`);
      
      // Check for scheduled events
      if (Array.isArray(L.time.scheduledEvents) && L.time.scheduledEvents.length > 0) {
        const currentDay = L.time.currentDay || 1;
        const upcomingEvents = [];
        
        for (let i = 0; i < L.time.scheduledEvents.length; i++) {
          const event = L.time.scheduledEvents[i];
          if (event && event.day && event.day >= currentDay) {
            const daysUntil = event.day - currentDay;
            const eventName = event.name || '–°–æ–±—ã—Ç–∏–µ';
            if (daysUntil === 0) {
              upcomingEvents.push(`${eventName} –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç —Å–µ–≥–æ–¥–Ω—è`);
            } else if (daysUntil === 1) {
              upcomingEvents.push(`–î–æ ${eventName} –æ—Å—Ç–∞–ª—Å—è 1 –¥–µ–Ω—å`);
            } else if (daysUntil <= 7) {
              upcomingEvents.push(`–î–æ ${eventName} –æ—Å—Ç–∞–ª–æ—Å—å ${daysUntil} –¥–Ω—è`);
            }
          }
        }
        
        if (upcomingEvents.length > 0) {
          for (let i = 0; i < upcomingEvents.length; i++) {
            priority.push(`‚ü¶SCHEDULE‚üß ${upcomingEvents[i]}`);
          }
        }
      }
    }

    // Population context (low priority, added to normal)
    if (L.population && (L.population.unnamedStudents > 0 || L.population.unnamedTeachers > 0)) {
      let popText = '';
      if (L.population.unnamedStudents > 0 && L.population.unnamedTeachers > 0) {
        popText = `‚ü¶WORLD‚üß –í —à–∫–æ–ª–µ —É—á–∏—Ç—Å—è –æ–∫–æ–ª–æ ${L.population.unnamedStudents} –¥—Ä—É–≥–∏—Ö —É—á–µ–Ω–∏–∫–æ–≤ –∏ —Ä–∞–±–æ—Ç–∞–µ—Ç ${L.population.unnamedTeachers} —É—á–∏—Ç–µ–ª–µ–π.`;
      } else if (L.population.unnamedStudents > 0) {
        popText = `‚ü¶WORLD‚üß –í —à–∫–æ–ª–µ —É—á–∏—Ç—Å—è –æ–∫–æ–ª–æ ${L.population.unnamedStudents} –¥—Ä—É–≥–∏—Ö —É—á–µ–Ω–∏–∫–æ–≤.`;
      } else if (L.population.unnamedTeachers > 0) {
        popText = `‚ü¶WORLD‚üß –í —à–∫–æ–ª–µ —Ä–∞–±–æ—Ç–∞–µ—Ç –æ–∫–æ–ª–æ ${L.population.unnamedTeachers} —É—á–∏—Ç–µ–ª–µ–π.`;
      }
      if (popText) normal.push(popText);
    }

    // Demographic pressure suggestions (priority)
    if (LC.DemographicPressure) {
      const suggestions = LC.DemographicPressure.getSuggestions();
      if (suggestions && suggestions.length > 0) {
        for (let i = 0; i < suggestions.length; i++) {
          priority.push(suggestions[i]);
        }
      }
    }

    // Zeitgeist - Dominant cultural myth (priority)
    if (LC.MemoryEngine && typeof LC.MemoryEngine.getDominantMyth === 'function') {
      const dominantMyth = LC.MemoryEngine.getDominantMyth();
      if (dominantMyth && dominantMyth.moral) {
        // Create zeitgeist message based on the dominant myth's theme
        let zeitgeistText = '';
        switch (dominantMyth.theme) {
          case 'loyalty_rescue':
            zeitgeistText = '–í —ç—Ç–æ–π —à–∫–æ–ª–µ –≥–µ—Ä–æ–µ–≤ —É–≤–∞–∂–∞—é—Ç, –∞ –ø—Ä–µ–¥–∞—Ç–µ–ª–µ–π –ø—Ä–µ–∑–∏—Ä–∞—é—Ç.';
            break;
          case 'betrayal':
            zeitgeistText = '–í —ç—Ç–æ–π —à–∫–æ–ª–µ –¥–æ–≤–µ—Ä–∏–µ —Ç—Ä—É–¥–Ω–æ –∑–∞—Ä–∞–±–æ—Ç–∞—Ç—å –∏ –ª–µ–≥–∫–æ –ø–æ—Ç–µ—Ä—è—Ç—å.';
            break;
          case 'achievement':
            zeitgeistText = '–í —ç—Ç–æ–π —à–∫–æ–ª–µ —Ü–µ–Ω—è—Ç —É–ø–æ—Ä—Å—Ç–≤–æ –∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è.';
            break;
          case 'leadership':
            zeitgeistText = '–í —ç—Ç–æ–π —à–∫–æ–ª–µ –ª–∏–¥–µ—Ä—ã –∑–∞–¥–∞—é—Ç —Ç–æ–Ω –∏ –ø–æ–ª—å–∑—É—é—Ç—Å—è —É–≤–∞–∂–µ–Ω–∏–µ–º.';
            break;
          default:
            zeitgeistText = `–í —ç—Ç–æ–π —à–∫–æ–ª–µ –ø–æ–º–Ω—è—Ç: ${dominantMyth.moral}`;
            break;
        }
        
        if (zeitgeistText) {
          priority.push(`‚ü¶ZEITGEIST‚üß ${zeitgeistText}`);
        }
      }
    }

    // Active goals (created within last 20 turns)
    if (L.goals && typeof L.goals === 'object') {
      const goalEntries = Object.entries(L.goals);
      const activeGoals = [];
      for (let i = 0; i < goalEntries.length; i++) {
        const [key, goal] = goalEntries[i];
        // Defensive programming: validate goal object structure
        if (!goal || typeof goal !== 'object') continue;
        if (goal.status !== 'active') continue;
        if (!goal.text || typeof goal.text !== 'string') continue;
        
        const turnsSince = L.turn - (goal.turnCreated || 0);
        if (turnsSince >= 0 && turnsSince < 20) {
          const char = goal.character || 'Unknown';
          let goalLine = `${char}: ${goal.text}`;
          
          // Add plan progress if plan exists
          if (goal.plan && Array.isArray(goal.plan) && goal.plan.length > 0) {
            const currentStep = goal.planProgress || 0;
            if (currentStep < goal.plan.length) {
              const step = goal.plan[currentStep];
              goalLine += ` [–®–∞–≥ ${currentStep + 1}/${goal.plan.length}: ${step.text}]`;
            }
          }
          
          activeGoals.push(goalLine);
        }
      }
      if (activeGoals.length > 0) {
        for (let i = 0; i < activeGoals.length; i++) {
          priority.push(`‚ü¶GOAL‚üß –¶–µ–ª—å ${activeGoals[i]}`);
        }
      }
    }

    // Character mood/status (active statuses)
    if (L.character_status && typeof L.character_status === 'object') {
      const currentTurn = L.turn || 0;
      for (const character in L.character_status) {
        if (Object.prototype.hasOwnProperty.call(L.character_status, character)) {
          const status = L.character_status[character];
          // Defensive programming: validate status object
          if (!status || typeof status !== 'object') continue;
          if (typeof status.expires !== 'number' || currentTurn >= status.expires) continue;
          
          // Status is still active
          const mood = status.mood || 'unknown';
          const reason = status.reason || '';
          let moodText = '';
          
          // Create mood description
          if (mood === 'angry') {
            moodText = reason ? `${character} –∑–æ–ª –∏–∑-–∑–∞ ${reason}` : `${character} –∑–æ–ª`;
          } else if (mood === 'happy') {
            moodText = reason ? `${character} —Å—á–∞—Å—Ç–ª–∏–≤ –±–ª–∞–≥–æ–¥–∞—Ä—è ${reason}` : `${character} —Å—á–∞—Å—Ç–ª–∏–≤`;
          } else if (mood === 'scared') {
            moodText = reason ? `${character} –Ω–∞–ø—É–≥–∞–Ω –∏–∑-–∑–∞ ${reason}` : `${character} –Ω–∞–ø—É–≥–∞–Ω`;
          } else if (mood === 'tired') {
            moodText = reason ? `${character} —É—Å—Ç–∞–ª –æ—Ç ${reason}` : `${character} —É—Å—Ç–∞–ª`;
          } else if (mood === 'wounded') {
            moodText = reason ? `${character} —Ä–∞–Ω–µ–Ω (${reason})` : `${character} —Ä–∞–Ω–µ–Ω`;
          } else {
            moodText = reason ? `${character}: ${mood} (${reason})` : `${character}: ${mood}`;
          }
          
          priority.push(`‚ü¶MOOD‚üß ${moodText}`);
        }
      }
    }

    // Secrets (filtered by scene focus)
    if (L.secrets && Array.isArray(L.secrets) && L.secrets.length > 0) {
      // First, build preliminary context to check for scene focus
      const prelimChars = LC.getActiveCharacters(10);
      const HOT = LC.CONFIG?.CHAR_WINDOW_HOT ?? 3;  // HOT characters are those seen in the last 3 turns
      const focusChars = [];
      if (prelimChars && prelimChars.length > 0) {
        for (let i = 0; i < prelimChars.length; i++) {
          const c = prelimChars[i];
          if (c.turnsAgo <= HOT) focusChars.push(c.name);
        }
      }
      
      // Filter secrets based on who knows them
      if (focusChars.length > 0) {
        for (let i = 0; i < L.secrets.length; i++) {
          const secret = L.secrets[i];
          if (LC.KnowledgeEngine && LC.KnowledgeEngine.isSecretVisible(secret, focusChars)) {
            priority.push(`‚ü¶SECRET‚üß ${secret.text}`);
          }
        }
      }
    }

    const opening = LC.getOpeningLine?.() || "";
    if (opening) normal.push(opening);

    const HOT = LC.CONFIG?.CHAR_WINDOW_HOT ?? 3;     // HOT window: last 3 turns
    const ACTIVE = LC.CONFIG?.CHAR_WINDOW_ACTIVE ?? 10;  // ACTIVE window: last 10 turns
    const chars = LC.getActiveCharacters(10);
    if (chars.length) {
      const hot = []; const active = [];
      for (let i=0;i<chars.length;i++){
        const c = chars[i];
        if (c.turnsAgo <= HOT) hot.push(c.name);       // Characters in HOT window
        else if (c.turnsAgo <= ACTIVE) active.push(c.name);  // Characters in ACTIVE window
      }
      if (hot.length)    priority.push(`‚ü¶SCENE‚üß Focus on: ${hot.join(", ")}`);
      if (active.length) normal.push(`‚ü¶SCENE‚üß Recently active: ${active.join(", ")}`);
      
      // Add personality traits for HOT characters (those in current scene focus)
      for (let i = 0; i < hot.length; i++) {
        const charName = hot[i];
        const character = L.characters[charName];
        if (character && character.personality) {
          const p = character.personality;
          const sc = character.self_concept || {};
          const traits = [];
          const conflicts = [];
          
          // Helper function to detect significant divergence
          const hasDivergence = (objTrait, perceivedTrait) => {
            if (perceivedTrait === undefined) return false;
            return Math.abs(objTrait - perceivedTrait) > 0.2;
          };
          
          // Analyze trust (check for self-concept divergence)
          const trustDiv = hasDivergence(p.trust, sc.perceived_trust);
          const trustValue = trustDiv ? sc.perceived_trust : p.trust;
          
          if (trustValue <= 0.3) {
            traits.push('—Ü–∏–Ω–∏—á–µ–Ω –∏ –Ω–µ –¥–æ–≤–µ—Ä—è–µ—Ç –ª—é–¥—è–º');
            if (trustDiv && p.trust > 0.5) {
              conflicts.push('–Ω–µ–¥–æ–æ—Ü–µ–Ω–∏–≤–∞–µ—Ç —Å–≤–æ—é –¥–æ–≤–µ—Ä—á–∏–≤–æ—Å—Ç—å');
            }
          } else if (trustValue >= 0.8) {
            traits.push('–Ω–∞–∏–≤–µ–Ω –∏ –æ—Ç–∫—Ä—ã—Ç');
            if (trustDiv && p.trust < 0.5) {
              conflicts.push('–ø–µ—Ä–µ–æ—Ü–µ–Ω–∏–≤–∞–µ—Ç —Å–≤–æ—é –¥–æ–≤–µ—Ä—á–∏–≤–æ—Å—Ç—å');
            }
          } else if (trustDiv) {
            // Moderate trust with divergence
            if (sc.perceived_trust < p.trust - 0.2) {
              conflicts.push('—Å—á–∏—Ç–∞–µ—Ç —Å–µ–±—è –º–µ–Ω–µ–µ –¥–æ–≤–µ—Ä—á–∏–≤—ã–º —á–µ–º –µ—Å—Ç—å');
            } else if (sc.perceived_trust > p.trust + 0.2) {
              conflicts.push('—Å—á–∏—Ç–∞–µ—Ç —Å–µ–±—è –±–æ–ª–µ–µ –¥–æ–≤–µ—Ä—á–∏–≤—ã–º —á–µ–º –µ—Å—Ç—å');
            }
          }
          
          // Analyze bravery (check for self-concept divergence)
          const braveryDiv = hasDivergence(p.bravery, sc.perceived_bravery);
          const braveryValue = braveryDiv ? sc.perceived_bravery : p.bravery;
          
          if (braveryValue <= 0.3) {
            traits.push('–æ—Å—Ç–æ—Ä–æ–∂–µ–Ω –∏ –±–æ–∏—Ç—Å—è —Ä–∏—Å–∫–æ–≤–∞—Ç—å');
            if (braveryDiv && p.bravery > 0.5) {
              conflicts.push('–Ω–µ–¥–æ–æ—Ü–µ–Ω–∏–≤–∞–µ—Ç —Å–≤–æ—é —Ö—Ä–∞–±—Ä–æ—Å—Ç—å');
            }
          } else if (braveryValue >= 0.8) {
            traits.push('—Å–º–µ–ª –∏ –≥–æ—Ç–æ–≤ —Ä–∏—Å–∫–æ–≤–∞—Ç—å');
            if (braveryDiv && p.bravery < 0.5) {
              conflicts.push('–ø–µ—Ä–µ–æ—Ü–µ–Ω–∏–≤–∞–µ—Ç —Å–≤–æ—é —Ö—Ä–∞–±—Ä–æ—Å—Ç—å');
            }
          } else if (braveryDiv) {
            // Moderate bravery with divergence
            if (sc.perceived_bravery < p.bravery - 0.2) {
              conflicts.push('–Ω–µ–¥–æ–æ—Ü–µ–Ω–∏–≤–∞–µ—Ç —Å–≤–æ—é —Å–º–µ–ª–æ—Å—Ç—å');
            }
          }
          
          // Analyze idealism (check for self-concept divergence)
          const idealismDiv = hasDivergence(p.idealism, sc.perceived_idealism);
          const idealismValue = idealismDiv ? sc.perceived_idealism : p.idealism;
          
          if (idealismValue <= 0.3) {
            traits.push('–ø—Ä–∞–≥–º–∞—Ç–∏—á–µ–Ω –∏ —Ü–∏–Ω–∏—á–µ–Ω');
          } else if (idealismValue >= 0.8) {
            traits.push('–∏–¥–µ–∞–ª–∏—Å—Ç –∏ –≤–µ—Ä–∏—Ç –≤ –ª—É—á—à–µ–µ');
          }
          
          // Analyze aggression (check for self-concept divergence)
          const aggressionDiv = hasDivergence(p.aggression, sc.perceived_aggression);
          const aggressionValue = aggressionDiv ? sc.perceived_aggression : p.aggression;
          
          if (aggressionValue >= 0.7) {
            traits.push('–∞–≥—Ä–µ—Å—Å–∏–≤–µ–Ω –∏ –∫–æ–Ω—Ñ–ª–∏–∫—Ç–µ–Ω');
          } else if (aggressionValue <= 0.2) {
            traits.push('–º–∏—Ä–æ–ª—é–±–∏–≤ –∏ –∏–∑–±–µ–≥–∞–µ—Ç –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤');
          }
          
          if (traits.length > 0) {
            priority.push(`‚ü¶TRAITS: ${charName}‚üß ${traits.join(', ')}`);
          }
          
          // Add internal conflict tag if there's significant divergence
          if (conflicts.length > 0) {
            priority.push(`‚ü¶CONFLICT: ${charName}‚üß –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –∫–æ–Ω—Ñ–ª–∏–∫—Ç: ${conflicts.join(', ')}`);
          }
        }
        
        // Add social status for HOT characters
        if (character && character.social && character.social.status !== 'member') {
          const status = character.social.status;
          let statusText = '';
          if (status === 'leader') {
            statusText = '–õ–∏–¥–µ—Ä –º–Ω–µ–Ω–∏–π';
          } else if (status === 'outcast') {
            statusText = '–ò–∑–≥–æ–π';
          }
          if (statusText) {
            priority.push(`‚ü¶STATUS: ${charName}‚üß ${statusText}`);
          }
        }
        
        // Add qualia state for HOT characters (extreme states only)
        if (character && character.qualia_state) {
          const qs = character.qualia_state;
          const qualiaDesc = [];
          
          // Check for extreme somatic tension
          if (qs.somatic_tension >= 0.8) {
            qualiaDesc.push('–∫—Ä–∞–π–Ω–µ –Ω–∞–ø—Ä—è–∂–µ–Ω');
          } else if (qs.somatic_tension <= 0.2) {
            qualiaDesc.push('–ø–æ–ª–Ω–æ—Å—Ç—å—é —Ä–∞—Å—Å–ª–∞–±–ª–µ–Ω');
          }
          
          // Check for extreme valence
          if (qs.valence >= 0.8) {
            qualiaDesc.push('–ø—Ä–∏—è—Ç–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ');
          } else if (qs.valence <= 0.2) {
            qualiaDesc.push('–Ω–µ–≥–∞—Ç–∏–≤–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ');
          }
          
          // Check for extreme focus
          if (qs.focus_aperture <= 0.3) {
            qualiaDesc.push('—Ç—É–Ω–Ω–µ–ª—å–Ω–æ–µ –∑—Ä–µ–Ω–∏–µ');
          }
          
          // Check for extreme energy
          if (qs.energy_level >= 0.9) {
            qualiaDesc.push('–æ—á–µ–Ω—å –±–æ–¥—Ä');
          } else if (qs.energy_level <= 0.2) {
            qualiaDesc.push('–∏—Å—Ç–æ—â–µ–Ω');
          }
          
          if (qualiaDesc.length > 0) {
            priority.push(`‚ü¶QUALIA: ${charName}‚üß ${qualiaDesc.join(', ')}`);
          }
        }
        
        // Add asymmetric perceptions for HOT characters
        if (character && character.perceptions && hot.length > 1) {
          const perceptions = character.perceptions;
          const significantPerceptions = [];
          
          // Find other HOT characters that this character has strong opinions about
          for (let j = 0; j < hot.length; j++) {
            const otherChar = hot[j];
            if (otherChar === charName) continue; // Skip self
            
            const perception = perceptions[otherChar];
            if (!perception || typeof perception !== 'object') continue;
            
            // Check for extreme perception values
            const affection = perception.affection || 50;
            const trust = perception.trust || 50;
            const respect = perception.respect || 50;
            const rivalry = perception.rivalry || 50;
            
            const perceptionDesc = [];
            
            if (affection >= 80) {
              perceptionDesc.push('–æ—á–µ–Ω—å –ª—é–±–∏—Ç');
            } else if (affection <= 20) {
              perceptionDesc.push('–Ω–µ –ª—é–±–∏—Ç');
            }
            
            if (trust >= 80) {
              perceptionDesc.push('–ø–æ–ª–Ω–æ—Å—Ç—å—é –¥–æ–≤–µ—Ä—è–µ—Ç');
            } else if (trust <= 20) {
              perceptionDesc.push('–Ω–µ –¥–æ–≤–µ—Ä—è–µ—Ç');
            }
            
            if (respect >= 80) {
              perceptionDesc.push('–æ—á–µ–Ω—å —É–≤–∞–∂–∞–µ—Ç');
            } else if (respect <= 20) {
              perceptionDesc.push('–Ω–µ —É–≤–∞–∂–∞–µ—Ç');
            }
            
            if (rivalry >= 80) {
              perceptionDesc.push('—Å–∏–ª—å–Ω–æ —Å–æ–ø–µ—Ä–Ω–∏—á–∞–µ—Ç');
            }
            
            if (perceptionDesc.length > 0) {
              significantPerceptions.push(`${otherChar}: ${perceptionDesc.join(', ')}`);
            }
          }
          
          if (significantPerceptions.length > 0) {
            priority.push(`‚ü¶PERCEPTION: ${charName}‚üß ${significantPerceptions.join('; ')}`);
          }
        }
      }
    }

    if (L.turn > 0) {
      const sinceRecap = L.turn - (L.lastRecapTurn || 0);
      const sinceEpoch = L.turn - (L.lastEpochTurn || 0);
      const retryInfo = L.consecutiveRetries > 0 ? ` (${L.consecutiveRetries} retries)` : "";
      normal.push(`‚ü¶META‚üß Turn ${L.turn}${retryInfo}, ${sinceRecap} since recap, ${sinceEpoch} since epoch.`);
    }

    const all = priority.concat(normal);
    const seen = {}; const uniq = [];
    for (let i=0;i<all.length;i++){ const r=all[i]; const k=r.toLowerCase(); if (!seen[k]){ seen[k]=1; uniq.push(r); } }

    function weight(line){
      if (line.indexOf("‚ü¶INTENT‚üß") === 0) return 1000;
      if (line.indexOf("‚ü¶TASK‚üß") === 0)   return 900;
      if (line.indexOf("‚ü¶CANON‚üß") === 0)  return 800;
      if (line.indexOf("‚ü¶SUGGESTION‚üß") === 0) return 760;
      if (line.indexOf("‚ü¶GOAL‚üß") === 0)   return 750;
      if (line.indexOf("‚ü¶SECRET‚üß") === 0) return 740;
      if (line.indexOf("‚ü¶CONFLICT:") === 0) return 735;
      if (line.indexOf("‚ü¶TRAITS:") === 0) return 730;
      if (line.indexOf("‚ü¶STATUS:") === 0) return 728;
      if (line.indexOf("‚ü¶QUALIA:") === 0) return 727;
      if (line.indexOf("‚ü¶PERCEPTION:") === 0) return 726;
      if (line.indexOf("‚ü¶MOOD‚üß") === 0)   return 725;
      if (line.indexOf("‚ü¶OPENING‚üß") === 0)return 700;
      if (line.indexOf("‚ü¶SCENE‚üß") === 0 && line.indexOf("Focus") !== -1) return 600;
      if (line.indexOf("‚ü¶SCENE‚üß") === 0)  return 500;
      if (line.indexOf("‚ü¶GUIDE‚üß") === 0)  return 400;
      if (line.indexOf("‚ü¶WORLD‚üß") === 0)  return 200;
      if (line.indexOf("‚ü¶META‚üß") === 0)   return 100;
      return 0;
    }
    uniq.sort((a,b)=> weight(b) - weight(a));

    const MAX = Number.isFinite(Number(opts.limit)) ? Number(opts.limit) : (LC.CONFIG?.LIMITS?.CONTEXT_LENGTH ?? 800);
    let text = "";
    const parts = { GUIDE:0, INTENT:0, TASK:0, CANON:0, GOAL:0, SECRET:0, CONFLICT:0, TRAITS:0, STATUS:0, QUALIA:0, PERCEPTION:0, MOOD:0, OPENING:0, SCENE:0, META:0, WORLD:0, SUGGESTION:0 };
    for (let i=0;i<uniq.length;i++){
      const line = uniq[i];
      const nl = text ? "\n" : "";
      const projectedLength = text.length + nl.length + line.length;
      if (projectedLength > MAX) {
        if (!opts.allowPartial) continue;
        const currentLength = text.length + nl.length;
        const remaining = MAX - currentLength;
        if (remaining <= 0) break;
        if (remaining >= 40) {
          const slice = line.slice(0, remaining);
          text += nl + slice;
          const tag = (line.match(/^‚ü¶([A-Z]+)(?::|‚üß)/)||[])[1] || "GUIDE";
          parts[tag] = (parts[tag]||0) + nl.length + slice.length;
        }
        break;
      }
      text += nl + line;
      const tag = (line.match(/^‚ü¶([A-Z]+)(?::|‚üß)/)||[])[1] || "GUIDE";
      parts[tag] = (parts[tag]||0) + line.length + nl.length;
    }
    
    const result = { text, parts, max:MAX };
    
    // Cache the result for future use
    LC._contextCache[cacheKey] = {
      stateVersion: L.stateVersion,
      result: result
    };
    
    return result;
  } catch(e) {
    const err = e && e.message ? e.message : String(e);
    return { text:"", parts:{}, max:0, error:err };
  }
};

LC.ensureEventsCap = function(cap) {
  try {
    const L = this.lcInit();
    if (!Array.isArray(L.events)) return;
    const max = Number(cap || 300) || 300;
    if (L.events.length > max) {
      L.events.splice(0, L.events.length - max);
    }
  } catch(_) {}
};


LC.migrateState = function(L) {
  try {
    if (!L || typeof L !== 'object') return;
    if (!L.evergreen || typeof L.evergreen !== 'object') L.evergreen = {};
    if (!Array.isArray(L.evergreen.history)) L.evergreen.history = [];
    if (!L.tm || typeof L.tm !== 'object') L.tm = {};
    if (!Array.isArray(L.tm.recapTurns)) L.tm.recapTurns = [];
    if (!L.currentAction || typeof L.currentAction !== 'object') L.currentAction = {};
  } catch(_) {}
};


LC.selfTest = function() {
  const st = getState();
  const hadOriginal = Object.prototype.hasOwnProperty.call(st, "lincoln");
  const originalState = hadOriginal ? st.lincoln : undefined;
  const savedEchoCache = this._echoCache;
  const savedEchoOrder = this._echoOrder;
  const savedCmdSeq = this._cmdSysSeq;
  const savedCmdSeen = this._cmdSysSeen;
  const savedPatterns = this.EvergreenEngine ? this.EvergreenEngine.patterns : undefined;

  const lines = [];
  const push = (cond, msg) => lines.push(`${cond ? "‚úÖ" : "‚ö†Ô∏è"} ${msg}`);

  try {
    const baseL = this.lcInit();
    const recapDraft = baseL.recapDraft;
    const epochDraft = baseL.epochDraft;
    push(Array.isArray(baseL.events), `events array (${Array.isArray(baseL.events) ? baseL.events.length : 'n/a'})`);
    push(typeof baseL.turn === 'number' && baseL.turn >= 0, `turn=${baseL.turn}`);
    push(typeof baseL.currentAction === 'object', 'currentAction object available');
    push(!recapDraft || typeof recapDraft === 'string' || typeof recapDraft.text === 'string', 'recapDraft text field');
    push(!epochDraft || typeof epochDraft === 'string' || typeof epochDraft.text === 'string', 'epochDraft text field');
    push(baseL.evergreen && Array.isArray(baseL.evergreen.history), 'evergreen.history is array');
    const wantRecap = baseL.currentAction?.wantRecap || false;
    const doRecap = baseL.currentAction?.task === 'recap';
    const doEpoch = baseL.currentAction?.task === 'epoch';
    push(!(wantRecap && doEpoch), 'flags: not both wantRecap and doEpoch');

    const self = this;
    function freshState() {
      st.lincoln = {};
      self._echoCache = {};
      self._echoOrder = [];
      self._cmdSysSeq = 0;
      self._cmdSysSeen = undefined;
      const L = self.lcInit();
      L.currentAction = L.currentAction || {};
      L.sysMsgs = Array.isArray(L.sysMsgs) ? L.sysMsgs : [];
      return L;
    }

    function run(label, fn) {
      try {
        const res = fn();
        if (res && typeof res === 'object' && Object.prototype.hasOwnProperty.call(res, 'ok')) {
          const detail = res.detail ? ` ‚Äî ${res.detail}` : '';
          push(!!res.ok, `${label}${detail}`);
        } else {
          push(!!res, label);
        }
      } catch (err) {
        push(false, `${label} error: ${err && err.message ? err.message : err}`);
      }
    }

    run('Continue button bumps turn', () => {
      const L = freshState();
      L.turn = 7;
      L.lastInput = 'Previous line';
      const type = self.detectInputType('');
      const before = L.turn;
      const should = self.shouldIncrementTurn();
      if (type !== 'continue') {
        return { ok: false, detail: `type=${type}` };
      }
      if (!should) {
        return { ok: false, detail: 'shouldIncrementTurn=false' };
      }
      self.incrementTurn();
      return { ok: L.turn === before + 1, detail: `turn=${L.turn}` };
    });

    run('Command /continue saves draft once', () => {
      if (!self.Drafts || typeof self.Drafts.applyPending !== 'function') {
        return { ok: true, detail: 'drafts API missing' };
      }
      const L = freshState();
      L.turn = 12;
      L.recapDraft = { text: 'Recap draft body', turn: 11, window: [8, 11] };
      const beforeTurn = L.turn;
      L.currentAction = { type: 'command', name: '/continue' };
      const first = self.Drafts.applyPending(L, 'selftest');
      const firstMsgs = self.lcConsumeMsgs();
      const sawDraftSaved = Array.isArray(firstMsgs) && firstMsgs.some((m) => /‚úÖ Draft saved/i.test(m));
      const second = self.Drafts.applyPending(L, 'selftest');
      const secondMsgs = self.lcConsumeMsgs();
      const okTurn = L.turn === beforeTurn;
      const okSilent = Array.isArray(secondMsgs) && secondMsgs.length === 0;
      const ok = !!first?.applied && sawDraftSaved && okTurn && (!second?.applied) && okSilent;
      return { ok, detail: `msgs=${Array.isArray(firstMsgs) ? firstMsgs.length : 0}, repeat=${second?.reason || 'none'}` };
    });

    run('/help keeps turn + clears SYS queue', () => {
      const L = freshState();
      L.turn = 5;
      L.sysMsgs.push('‚ü¶SYS‚üß Help block');
      L.currentAction = { type: 'command', name: '/help' };
      const beforeTurn = L.turn;
      const should = self.shouldIncrementTurn();
      const first = self.lcConsumeMsgs();
      const second = self.lcConsumeMsgs();
      const ok = !should && beforeTurn === L.turn && Array.isArray(first) && first.length === 1 && Array.isArray(second) && second.length === 0;
      return { ok, detail: `consumed=${Array.isArray(first) ? first.length : 0}` };
    });

    run('Retry keeps turn & anti-echo baseline', () => {
      const L = freshState();
      L.turn = 9;
      self.detectInputType('–ü–µ—Ä–≤—ã–π —Ö–æ–¥');
      const type = self.detectInputType('–ü–µ—Ä–≤—ã–π —Ö–æ–¥');
      const isRetry = L.currentAction?.type === 'retry';
      const should = self.shouldIncrementTurn();
      const baseline = 'Baseline output sample';
      L.prevOutput = baseline;
      const filtered = self.applyAntiEcho('–ü–æ–≤—Ç–æ—Ä–Ω—ã–π –æ—Ç–≤–µ—Ç', baseline, 'retry');
      const ok = type === 'retry' && isRetry && !should && L.turn === 9 && filtered === '–ü–æ–≤—Ç–æ—Ä–Ω—ã–π –æ—Ç–≤–µ—Ç' && L.prevOutput === baseline;
      return { ok, detail: `retry=${isRetry}` };
    });

    run('Context overlay fallback keeps upstream text', () => {
      if (typeof self.composeContextOverlay !== 'function') {
        return { ok: true, detail: 'no composeContextOverlay' };
      }
      freshState();
      const savedCompose = self.composeContextOverlay;
      const upstream = 'Original upstream context';
      let finalText = '';
      let fallbackUsed = false;
      try {
        self.composeContextOverlay = () => ({ text: '' });
        const limit = self.CONFIG?.LIMITS?.CONTEXT_LENGTH ?? 800;
        try {
          const built = self.composeContextOverlay({ limit, allowPartial: true });
          const raw = (built && typeof built.text === 'string') ? built.text : String(built || '');
          const overlay = raw && raw.trim().length ? raw : '';
          if (!overlay) throw new Error('empty overlay');
          finalText = overlay.length > limit ? overlay.slice(0, limit) : overlay;
        } catch (_) {
          fallbackUsed = true;
          finalText = upstream;
        }
      } finally {
        self.composeContextOverlay = savedCompose;
      }
      return { ok: fallbackUsed && finalText === upstream, detail: fallbackUsed ? 'fallback' : 'no-fallback' };
    });

    run('Evergreen cues dedupe & cap', () => {
      const L = freshState();
      if (!self.EvergreenEngine) {
        return { ok: true, detail: 'EvergreenEngine missing' };
      }
      L.evergreenHistoryCap = 2;
      L.evergreen.enabled = true;
      self.EvergreenEngine.patterns = null;
      self.EvergreenEngine.analyze('–í–∞–∂–Ω–æ: —Ç–æ—Ç –∂–µ —Ç–µ–∫—Å—Ç.', 'story');
      self.EvergreenEngine.analyze('–í–∞–∂–Ω–æ: —Ç–æ—Ç –∂–µ —Ç–µ–∫—Å—Ç.', 'story');
      self.EvergreenEngine.analyze('–í–∞–∂–Ω–æ: —Ç–æ—Ç –∂–µ —Ç–µ–∫—Å—Ç.', 'story');
      const factsCount = Object.keys(L.evergreen.facts || {}).length;
      self.EvergreenEngine.analyze('–ú–∞–∫—Å–∏–º —Ç–µ–ø–µ—Ä—å –∑–ª–æ–π.', 'story');
      self.EvergreenEngine.analyze('–ú–∞–∫—Å–∏–º —Ç–µ–ø–µ—Ä—å —Å–ø–æ–∫–æ–µ–Ω.', 'story');
      self.EvergreenEngine.analyze('–ú–∞–∫—Å–∏–º —Ç–µ–ø–µ—Ä—å —Ä–∞–¥–æ—Å—Ç–Ω—ã–π.', 'story');
      const historyLen = Array.isArray(L.evergreen.history) ? L.evergreen.history.length : 0;
      const okFacts = factsCount === 1;
      const okCap = historyLen <= 2;
      return { ok: okFacts && okCap, detail: `facts=${factsCount}, history=${historyLen}` };
    });

    return lines.join('\n');
  } catch (e) {
    return '‚ö†Ô∏è selfTest exception: ' + (e && e.message ? e.message : String(e));
  } finally {
    if (this.EvergreenEngine) {
      this.EvergreenEngine.patterns = savedPatterns;
    }
    if (hadOriginal) st.lincoln = originalState;
    else delete st.lincoln;
    this._echoCache = savedEchoCache;
    this._echoOrder = savedEchoOrder;
    this._cmdSysSeq = savedCmdSeq;
    this._cmdSysSeen = savedCmdSeen;
  }
};


LC.migrateToVersion = function(L, fromV, toV){
  try {
    L.offer = L.offer || {};
    if (!L.offer.recap) L.offer.recap = { active:false, issuedTurn:0, ttl:3 };
  if (typeof L.lastRecapTurn === "undefined") L.lastRecapTurn = 0;
  } catch(_){}
  return true;
};


LC.ctxPreview = function() {
  try {
    const L = LC.lcInit();
    const LIMIT = (LC.CONFIG && LC.CONFIG.LIMITS && LC.CONFIG.LIMITS.CONTEXT_LENGTH) ? LC.CONFIG.LIMITS.CONTEXT_LENGTH : 800;
    const out = [];
    out.push(`‚ü¶CONTEXT PREVIEW‚üß turn=${L.turn} limit=${LIMIT}`);
    if (L.lastIntent) out.push(`INTENT: ${String(L.lastIntent).slice(0,140)}‚Ä¶`);
    try {
      const doRecap = L.currentAction?.task === 'recap';
      const doEpoch = L.currentAction?.task === 'epoch';
      if (doRecap) out.push("TASK: Recap requested");
      if (doEpoch) out.push("TASK: Epoch requested");
    } catch(_){}
    try {
      if (LC.EvergreenEngine && typeof LC.EvergreenEngine.getCanon === "function") {
        const canon = LC.EvergreenEngine.getCanon();
        if (canon) out.push(`CANON: ${String(canon).slice(0,140)}‚Ä¶`);
      }
    } catch(_){}
    return out.join("\n");
  } catch(e){
    return "‚ü¶CONTEXT PREVIEW‚üß error: " + (e && e.message ? e.message : String(e));
  }
};
