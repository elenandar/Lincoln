// === INPUT MODIFIER v16.0.8-compat6d ===
const modifier = function (text) {
  
if (typeof LC === "undefined") return { text: String(text || "") };
  const L = LC.lcInit();

  if (L.turn === 0 && !L.openingCaptured) LC.captureOpeningFromHistory();

  const raw = String(text || "");
  const userText = LC.stripYouWrappers(raw.trim());

  function reply(msg){ LC.lcSys(msg); return { text: LC.CONFIG.CMD_PLACEHOLDER }; }
  function clearCommandFlags(){
    try {
      LC.lcSetFlag("isCmd", false);
      LC.lcSetFlag("isRetry", false);
      LC.lcSetFlag("isContinue", false);
    } catch (_) {}
  }
  function replyStop(msg){
    let state;
    try { state = LC.lcInit(); } catch (_) {}
    if (state) {
      const prev = (state.visibleNotice || "").trim();
      state.visibleNotice = prev ? `${prev}\n${msg}` : msg;
      if (state !== L) L.visibleNotice = state.visibleNotice;
    }
    LC.lcSys(msg);
    clearCommandFlags();
    return { text: LC.CONFIG?.CMD_PLACEHOLDER ?? "⟦SYS⟧ OK.", stop: true, _sys: msg };
  }

  function extractCommand(s){
    let t = (s || "").trim();
    if ((t.startsWith('"') && t.endsWith('"')) || (t.startsWith("'") && t.endsWith("'"))) t = t.slice(1, -1).trim();
    return t.startsWith("/") ? t : null;
  }
  const cmdRaw = extractCommand(userText);
  const cmd = cmdRaw ? cmdRaw.toLowerCase() : null;
const tokens = cmdRaw ? cmdRaw.trim().split(/\s+/) : [];
const args   = tokens.slice(1);


  if (!cmd) LC.detectInputType(raw);

  // ==== Команды ====
  if (cmd) {
    LC.lcSetFlag("isCmd", true);
    LC.lcSetFlag("isRetry", false);
    LC.lcSetFlag("isContinue", false);
    L.lastActionType = "command";


    const wantRecap = LC.lcGetFlag("wantRecap", false);
// /undo [N]
    if (cmd === "/undo") {
      const n = Number(args[0] || 1);
      try { if (typeof LC !== 'undefined') LC.turnUndo(n); } catch(e) { try { LC.lcSys("⚠️ Undo failed."); } catch(_){} }
      clearCommandFlags();
      return { text: "", stop: true };
    }

    // /turn set N
    if (cmd === "/turn" && (args[0] || "").toLowerCase() === "set") {
      const n = Number(args[1] || 0);
      try { if (typeof LC !== 'undefined') LC.turnSet(n); } catch(e) { try { LC.lcSys("⚠️ Turn set failed."); } catch(_){} }
      clearCommandFlags();
      return { text: "", stop: true };
    }


    // быстрые ответы на оффер recap
    if (cmd === "/да")   {
      if (!(typeof LC !== 'undefined' && LC.lcGetFlag && LC.lcGetFlag('wantRecap', wantRecap))) {
        return replyStop('ℹ️ Нет активного оффера рекапа.');
      }
      LC.lcSetFlag("wantRecap", false); L.recapMuteUntil = L.turn;
      LC.lcSetFlag("doRecap", true);
      return reply("📋 Recap will be generated.");
    }
    if (cmd === "/нет")  {
      if (!(typeof LC !== 'undefined' && LC.lcGetFlag && LC.lcGetFlag('wantRecap', wantRecap))) {
        return replyStop('ℹ️ Нет активного оффера рекапа.');
      }
      LC.lcSetFlag("wantRecap", false); L.recapMuteUntil = L.turn + 5;
      return reply("🚫 Recap postponed for 5 turns.");
    }
    if (cmd === "/позже"){
      if (!(typeof LC !== 'undefined' && LC.lcGetFlag && LC.lcGetFlag('wantRecap', wantRecap))) {
        return replyStop('ℹ️ Нет активного оффера рекапа.');
      }
      LC.lcSetFlag("wantRecap", false); L.recapMuteUntil = L.turn + 3; if (L.tm) L.tm.wantRecapTurn = 0;
      return reply("🕑 Recap later (3 turns).");
    }

// helpers for /ctx
    function buildContextPreview(){
      const priority = [];
      const normal = [];

      // Style guides
      priority.push("⟦GUIDE⟧ Lincoln Heights school drama. Third person past tense.");
      priority.push("⟦GUIDE⟧ 2–4 short paragraphs. Show emotions via actions and subtext.");
      priority.push("⟦GUIDE⟧ Keep it plausible and consistent. PG-16.");
      normal.push("⟦GUIDE⟧ Do NOT repeat last 2–3 sentences from previous output.");

      if (L.lastIntent && L.lastIntent.length > 2) priority.push(`⟦INTENT⟧ ${L.lastIntent}`);

      if (!LC.lcGetFlag("isCmd", false) && LC.lcGetFlag("doRecap", false)) {
        priority.push("⟦TASK⟧ NOW WRITE A RECAP: Summarize the last 10–15 turns in 5–7 clear sentences, focusing on key events/relationships and current situation.");
      }
      if (!LC.lcGetFlag("isCmd", false) && LC.lcGetFlag("doEpoch", false)) {
        priority.push("⟦TASK⟧ NOW WRITE AN EPOCH: Compress multiple recaps into 5–7 sentences with major consequences and status changes.");
      }

      const canon = LC.autoEvergreen?.getCanon?.() || "";
      if (canon) priority.push(`⟦CANON⟧ ${canon}`);

      const opening = LC.getOpeningLine?.() || "";
      if (opening) normal.push(opening);

      const chars = LC.getActiveCharacters(10);
      if (chars.length) {
        const hot = []; const active = [];
        for (let i=0;i<chars.length;i++){
          const c = chars[i];
          if (c.turnsAgo <= 3) hot.push(c.name);
          else if (c.turnsAgo <= 10) active.push(c.name);
        }
        if (hot.length)    priority.push(`⟦SCENE⟧ Focus on: ${hot.join(", ")}`);
        if (active.length) normal.push(`⟦SCENE⟧ Recently active: ${active.join(", ")}`);
      }

      if (L.turn > 0) {
        const sinceRecap = L.turn - (L.lastRecapTurn || 0);
        const sinceEpoch = L.turn - (L.lastEpochTurn || 0);
        const retryInfo = L.consecutiveRetries > 0 ? ` (${L.consecutiveRetries} retries)` : "";
        normal.push(`⟦META⟧ Turn ${L.turn}${retryInfo}, ${sinceRecap} since recap, ${sinceEpoch} since epoch.`);
      }

      const all = priority.concat(normal);
      const seen = {}; const uniq = [];
      for (let i=0;i<all.length;i++){ const r=all[i]; const k=r.toLowerCase(); if (!seen[k]){ seen[k]=1; uniq.push(r); } }

      function weight(line){
        if (line.indexOf("⟦INTENT⟧") === 0) return 1000;
        if (line.indexOf("⟦TASK⟧") === 0)   return 900;
        if (line.indexOf("⟦CANON⟧") === 0)  return 800;
        if (line.indexOf("⟦OPENING⟧") === 0)return 700;
        if (line.indexOf("⟦SCENE⟧") === 0 && line.indexOf("Focus") !== -1) return 600;
        if (line.indexOf("⟦SCENE⟧") === 0)  return 500;
        if (line.indexOf("⟦GUIDE⟧") === 0)  return 400;
        if (line.indexOf("⟦META⟧") === 0)   return 100;
        return 0;
      }
      uniq.sort((a,b)=> weight(b) - weight(a));

      const MAX = LC.CONFIG.LIMITS.CONTEXT_LENGTH || 800;
      let overlay = "";
      const parts = { GUIDE:0, INTENT:0, TASK:0, CANON:0, OPENING:0, SCENE:0, META:0 };
      for (let i=0;i<uniq.length;i++){
        const line = uniq[i];
        const nl = overlay ? "\n" : "";
        if ((overlay.length + line.length + nl.length) > MAX) continue;
        overlay += nl + line;
        const tag = (line.match(/^⟦([A-Z]+)⟧/)||[])[1] || "GUIDE";
        parts[tag] = (parts[tag]||0) + line.length + nl.length;
      }
      return { overlay, parts, max:MAX };
    }

    switch ((cmd.split(" ")[0])) {
      case "/help":
      case "/h":
        return reply([
          `=== COMMANDS ${LC.CONFIG.VERSION} ===`,
          "/recap — create recap draft next output",
          "/epoch — create epoch draft",
          "/continue — accept and save draft",
          "/evergreen on|off|clear|summary|set <cat>: <value>",
          "/antiecho on|off|sensitivity N (1-100)|mode soft|hard|stats|flush",
          "/events [N] — list recent events with score contribution",
          "/alias add <Name>=a,b,c | /alias del <Name> | /alias list",
          "/evhist cap <N> | /evhist last <N> | /evhist clear",
          "/characters — list active NPCs",
          "/opening — show captured opening",
          "/ui on|off — toggle UI messages",
          "/debug on|off — toggle debug mode",
          "/stats — show statistics",
          "/retry — show retry info",
          "/cadence N — set recap cadence (6-24)",
          "/story add <text> | /story del <id>",
          "/cards — list managed cards",
          "/pin <id> /unpin <id> — pseudo-pin for cleanup",
          "/del <id> — remove card by id (if possible)",
          "/ctx — inspect context overlay composition"
        ].join("\n"));

      case "/ui":
        if (/\/ui\s+on/i.test(cmdRaw))  { L.sysShow = true;  return reply("✅ UI enabled."); }
        if (/\/ui\s+off/i.test(cmdRaw)) { L.sysShow = false; return reply("⚫ UI disabled."); }
        return reply(`UI is ${L.sysShow ? "on" : "off"}.`);

      case "/debug":
        if (/\/debug\s+on/i.test(cmdRaw))  { L.debugMode = true;  return reply("🔍 Debug ON."); }
        if (/\/debug\s+off/i.test(cmdRaw)) { L.debugMode = false; return reply("🔍 Debug OFF."); }
        return reply(`Debug is ${L.debugMode ? "on" : "off"}.`);

      case "/recap":
        LC.lcSetFlag("doRecap", true);
        return reply("📋 Recap requested. Next output → draft.");

      case "/epoch":
        LC.lcSetFlag("doEpoch", true);
        return reply("🗿 Epoch requested. Next output → draft.");

      case "/continue":
        if (L.recapDraft || L.epochDraft) { LC.lcSetFlag("acceptDraft", true); return reply("✅ Draft will be saved now."); }
        return reply("❌ No draft to save.");

      case "/evergreen": {
        if (/\/evergreen\s+clear/i.test(cmdRaw)) { LC.autoEvergreen.clear(); return reply("🧹 Evergreen storage cleared."); }
        if (/\/evergreen\s+on/i.test(cmdRaw))    { LC.autoEvergreen.toggle(true);  return reply("🌿 Evergreen enabled."); }
        if (/\/evergreen\s+off/i.test(cmdRaw))   { LC.autoEvergreen.toggle(false); return reply("🌿 Evergreen disabled."); }
        if (/\/evergreen\s+summary/i.test(cmdRaw)) { return reply(LC.autoEvergreen.getSummary()); }
        const m = cmdRaw.match(/\/evergreen\s+set\s+([\w-]+):\s*(.+)$/i);
        if (m) {
          const cat = m[1].toLowerCase();
          let val = m[2].trim().replace(/\s+/g, " ").slice(0, 240);
          const allowed = ["facts","status","relations","obligations"];
          const target = allowed.indexOf(cat) === -1 ? "facts" : cat;
          const key = `u_${Date.now().toString(36)}`;
          LC.evergreenManualSet(L, target, key, val);
          return reply(`Evergreen[${target}] += ${val.slice(0,80)}`);
        }
        return reply(LC.autoEvergreen.getSummary());
      }

      case "/antiecho":
        if (/\/antiecho\s+stats/i.test(cmdRaw)) {
          const s = LC.antiEchoStats();
          return reply([
            "=== ANTI-ECHO STATS ===",
            `LRU size: ${s.lruSize}`,
            `Cache entries: ${s.cacheEntries}`,
            `Cache hits: ${s.hits}`
          ].join("\n"));
        }
        if (/\/antiecho\s+flush/i.test(cmdRaw)) {
          LC.antiEchoFlush(); return reply("Anti-echo cache flushed.");
        }
        if (/\/antiecho\s+on/i.test(cmdRaw))  { L.antiEchoEnabled = true;  return reply("✅ Anti-echo enabled."); }
        if (/\/antiecho\s+off/i.test(cmdRaw)) { L.antiEchoEnabled = false; return reply("⚫ Anti-echo disabled."); }
        if (/\/antiecho\s+sensitivity\s+(\d{1,3})/i.test(cmdRaw)) {
          const v = Math.max(1, Math.min(100, parseInt(cmdRaw.match(/sensitivity\s+(\d{1,3})/i)[1], 10)));
          L.antiEchoSensitivity = v; return reply(`🔧 Anti-echo sensitivity = ${v}%`);
        }
        if (/\/antiecho\s+mode\s+(soft|hard)/i.test(cmdRaw)) {
          L.antiEchoMode = (cmdRaw.match(/mode\s+(soft|hard)/i)[1].toLowerCase() === "hard") ? "hard" : "soft";
          return reply(`🛡️ Anti-echo mode = ${L.antiEchoMode.toUpperCase()}`);
        }
        (function(){
          const base = (L.antiEchoSensitivity || 85) / 100;
          const multSoft = LC.CONFIG.LIMITS.ANTI_ECHO.CONTINUE_THRESHOLD_MULT.SOFT;
          const multHard = LC.CONFIG.LIMITS.ANTI_ECHO.CONTINUE_THRESHOLD_MULT.HARD;
          LC.lcSys([
            "=== ANTI-ECHO SETTINGS ===",
            `Status: ${L.antiEchoEnabled ? "Enabled" : "Disabled"}`,
            `Sensitivity: ${L.antiEchoSensitivity || 85}%`,
            `Mode: ${L.antiEchoMode || "soft"}`,
            `Continue thr (soft/hard): ${(Math.min(0.99, base*multSoft)).toFixed(2)} / ${(Math.min(0.99, base*multHard)).toFixed(2)}`,
            `Echo hits: ${L.tm.echoHits || 0}`
          ].join("\n"));
        })();
        return { text: LC.CONFIG.CMD_PLACEHOLDER };

      case "/events": {
        const m = cmdRaw.match(/\/events(?:\s+(\d+))?/i);
        const n = m && m[1] ? parseInt(m[1],10) : 10;
        const diag = LC.getEventsDiagnostics(n);
        const lines = diag.rows.map(r => `${r.type.padEnd(10)} | turn ${String(r.turn).padStart(3)} | ${String(r.ago).padStart(2)} ago | w=${r.w} decay=${r.decay} → +${r.contrib}`);
        return reply([
          `=== EVENTS (last ${diag.rows.length}) — contribution total: +${diag.total} ===`,
          ...lines
        ].join("\n"));
      }

      case "/alias": {
        if (/\/alias\s+list/i.test(cmdRaw)) {
          const map = L.aliases || {};
          const keys = Object.keys(map);
          if (!keys.length) return reply("No custom aliases.");
          const out = keys.map(k => `${k}: ${map[k].join(", ")}`);
          return reply("=== ALIASES ===\n" + out.join("\n"));
        }
        if (/\/alias\s+add\s+/i.test(cmdRaw)) {
          const m = cmdRaw.match(/\/alias\s+add\s+([^=]+)=(.+)$/i);
          if (!m) return reply("Usage: /alias add <Name>=a,b,c");
          const name = m[1].trim();
          const list = m[2].split(",").map(s=>s.trim()).filter(Boolean);
          L.aliases[name] = list;
          return reply(`Alias set: ${name} = ${list.join(", ")}`);
        }
        if (/\/alias\s+del\s+/i.test(cmdRaw)) {
          const m = cmdRaw.match(/\/alias\s+del\s+(.+)$/i);
          if (!m) return reply("Usage: /alias del <Name>");
          const name = m[1].trim();
          if (name in L.aliases) { delete L.aliases[name]; return reply(`Alias deleted: ${name}`); }
          return reply(`No alias for: ${name}`);
        }
        return reply("Usage: /alias add <Name>=a,b,c | /alias del <Name> | /alias list");
      }

      case "/evhist": {
        if (/\/evhist\s+cap\s+(\d+)/i.test(cmdRaw)) {
          const cap = Math.max(0, parseInt(cmdRaw.match(/cap\s+(\d+)/i)[1],10));
          LC.capEvergreenHistory(cap);
          return reply(`Evergreen history cap = ${cap || "no cap"}.`);
        }
        if (/\/evhist\s+last\s+(\d+)/i.test(cmdRaw)) {
          const n = Math.max(1, parseInt(cmdRaw.match(/last\s+(\d+)/i)[1],10));
          const arr = (L.evergreen && Array.isArray(L.evergreen.history)) ? L.evergreen.history.slice(-n) : [];
          if (!arr.length) return reply("Evergreen history is empty.");
          const show = arr.map(h => {
            const oldS = String(h.old||"").slice(0,40);
            const newS = String(h.new||"").slice(0,40);
            return `t${h.turn} [${h.category}] ${oldS} ⇒ ${newS}`;
          });
          return reply("=== EV HISTORY ===\n" + show.join("\n"));
        }
        if (/\/evhist\s+clear/i.test(cmdRaw)) {
          if (L.evergreen) L.evergreen.history = [];
          return reply("Evergreen history cleared.");
        }
        return reply("Usage: /evhist cap <N> | /evhist last <N> | /evhist clear");
      }

      case "/characters": {
        const chars = LC.getActiveCharacters(10);
        if (chars.length) return reply("=== ACTIVE CHARACTERS ===\n" +
          chars.map(c => `${c.name}: ${c.mentions} mentions, ${c.turnsAgo} turns ago`).join("\n"));
        return reply("No active characters tracked yet.");
      }

      case "/opening":
        return reply(LC.getOpeningLine() || "No opening captured yet.");

      case "/retry":
        
{
  if (/\/retry\s+keep/i.test(cmdRaw)) {
    LC.lcSetFlag("RETRY_KEEP_CONTEXT", true);
    return reply("🔁 Retry: keep context = ON.");
  }
  if (/\/retry\s+clear/i.test(cmdRaw)) {
    LC.lcSetFlag("RETRY_KEEP_CONTEXT", false);
    return reply("🔁 Retry: keep context = OFF.");
  }
  const keep = LC.lcGetFlag("RETRY_KEEP_CONTEXT", false);
  return reply([
    "=== RETRY ===",
    `Consecutive: ${L.consecutiveRetries || 0}`,
    `Total: ${L.tm?.retries || 0}`,
    `Turn: ${L.turn}, LastProcessed: ${L.lastProcessedTurn}`,
    `isRetry=${LC.lcGetFlag("isRetry", false)}, isContinue=${LC.lcGetFlag("isContinue", false)}`,
    `Keep context: ${keep ? "ON" : "OFF"}`
  ].join("\n"));
}


      case "/stats": {
        const s = (L.tm.lastRecapScore == null) ? "n/a" : Number(L.tm.lastRecapScore).toFixed(2);
        return reply([
          `=== STATISTICS ${LC.CONFIG.VERSION} ===`,
          `Turn: ${L.turn}`,
          `Since recap: ${L.turn - (L.lastRecapTurn || 0)}`,
          `Since epoch: ${L.turn - (L.lastEpochTurn || 0)}`,
          `Cadence: ${L.cadence}`,
          `Cards: ${L.worldInfoIds.length} (pinned ${L.pinnedWorldInfoIds.length})`,
          `Characters: ${Object.keys(L.characters).length}`,
          `Echo hits: ${L.tm.echoHits || 0}`,
          `Retry hits: ${L.tm.retries || 0}`,
          `Errors: ${L.tm.errors || 0}`,
          `Last recap score: ${s}`
        ].join("\n"));
      }

      case "/cadence": {
        const m = cmdRaw.match(/\/cadence\s+(\d{1,3})/i);
        if (m) {
          const req = parseInt(m[1], 10);
          const v = Math.max(LC.CONFIG.LIMITS.CADENCE.MIN, Math.min(LC.CONFIG.LIMITS.CADENCE.MAX, req));
          L.cadence = v;
          if (req !== v) return reply(`⏱️ Recap cadence: requested ${req} → applied ${v} (range ${LC.CONFIG.LIMITS.CADENCE.MIN}-${LC.CONFIG.LIMITS.CADENCE.MAX}).`);
          return reply(`⏱️ Recap cadence → ${v} turns.`);
        }
        return reply(`Current cadence: ${L.cadence} turns.`);
      }

      case "/story": {
        if (/^\/story\s+add\s+/i.test(cmdRaw)) {
          const m = cmdRaw.match(/^\/story\s+add\s+([\s\S]+)$/i);
          const entry = m ? m[1].trim() : "";
          if (!entry || entry.length < 10) return reply("Usage: /story add <текст карточки (≥10 символов)>");
          const id = LC.createStoryCard(entry, [Math.max(0, L.turn - L.cadence), L.turn], "note");
          return reply(`📝 Card saved — ID: ${id}`);
        }
        if (/^\/story\s+del\s+/i.test(cmdRaw)) {
          const m = cmdRaw.match(/^\/story\s+del\s+(\S+)/i);
          if (!m) return reply("Usage: /story del <id>");
          const id = m[1].trim();
          const ok = LC.removeStoryCardById(id);
          return reply(ok ? `🗑️ Card ${id} removed.` : `🔎 Card ${id} not found (removed from registry if present).`);
        }
        return reply("Usage: /story add <text> | /story del <id>");
      }

      case "/cards": {
        const st  = (typeof state !== "undefined") ? state : {};
        const ext = Array.isArray(st.$$WORLD_INFO_EXTENDED) ? st.$$WORLD_INFO_EXTENDED : [];
        const extSet = {};
        for (let i=0;i<ext.length;i++){
          const id = ext[i] && ext[i].worldInfoId;
          if (id) extSet[id] = 1;
        }
        const ids = L.worldInfoIds.slice(-15);
        if (!ids.length) return reply("No managed cards.");
        return reply("=== CARDS (managed) ===\n" + 
          ids.map((id,i)=>{
            const pin = (L.pinnedWorldInfoIds.indexOf(id)!==-1) ? " [PIN]" : "";
            const mk  = extSet[id] ? " [EXT]" : "";
            return `${i+1}. ${id}${pin}${mk}`;
          }).join("\n"));
      }

      case "/pin": {
        const m = cmdRaw.match(/\/pin\s+(\S+)/i);
        if (!m) return reply("Usage: /pin <id>");
        const id = m[1];
        if (L.pinnedWorldInfoIds.indexOf(id) === -1) L.pinnedWorldInfoIds.push(id);
        return reply(`📌 Pseudo-pin set for ${id}.`);
      }

      case "/unpin": {
        const m = cmdRaw.match(/\/unpin\s+(\S+)/i);
        if (!m) return reply("Usage: /unpin <id>");
        const id = m[1];
        const p = L.pinnedWorldInfoIds.indexOf(id);
        if (p !== -1) L.pinnedWorldInfoIds.splice(p,1);
        return reply(`📌 Pseudo-pin removed for ${id}.`);
      }

      case "/del": {
        const m = cmdRaw.match(/\/del\s+(\S+)/i);
        if (!m) return reply("Usage: /del <id>");
        const id = m[1];
        const p = L.pinnedWorldInfoIds.indexOf(id);
        if (p !== -1) L.pinnedWorldInfoIds.splice(p,1);
        const ok = LC.removeStoryCardById(id);
        return reply(ok ? `🗑️ Card ${id} removed.` : `🔎 Card ${id} not found (removed from registry if present).`);
      }

      case "/ctx": {
  try { if (typeof LC !== "undefined" && LC.ctxPreview) { return reply(LC.ctxPreview()); } } catch(_){/* fallback */}
  
  // Fallback to local preview builder
  const r = (typeof buildContextPreview === "function") ? buildContextPreview() : { overlay:"", max:800, parts:{} };
  const lines = [
    `LEN: ${r.overlay.length}/${r.max}`,
    `GUIDE: ${r.parts.GUIDE||0}`,
    `INTENT: ${r.parts.INTENT||0}`,
    `TASK: ${r.parts.TASK||0}`,
    `CANON: ${r.parts.CANON||0}`,
    `OPENING: ${r.parts.OPENING||0}`,
    `SCENE: ${r.parts.SCENE||0}`,
    `META: ${r.parts.META||0}`
  ];
  const sample = String(r.overlay).split(/\r?\n/).slice(0,8).join("\n");
return reply("=== CONTEXT INSPECTOR ===\n" + lines.join(" | ") + "\n---\n" + sample);
      }

      case "/selftest": {
{
  const cfg = LC.CONFIG || {};
  const anti = [
    L.antiEchoEnabled ? "ON" : "OFF",
    (L.antiEchoMode || "soft"),
    `@${L.antiEchoSensitivity ?? 85}%`
  ].join(" ");
  return reply([
    "=== SELFTEST ===",
    `Version: ${cfg.VERSION || "n/a"}`,
    `Data: ${cfg.DATA_VERSION || "n/a"}`,
    `Cadence: ${L.cadence} (muteUntil=${L.recapMuteUntil ?? "-"}, sinceRecap=${(L.turn - (L.lastRecapTurn || 0)) || 0})`,
    `Anti-echo: ${anti}`,
    `Flags: isCmd=${LC.lcGetFlag("isCmd",false)}, isRetry=${LC.lcGetFlag("isRetry",false)}, isContinue=${LC.lcGetFlag("isContinue",false)}, RETRY_KEEP_CONTEXT=${LC.lcGetFlag("RETRY_KEEP_CONTEXT",false)}`
  ].join("\n"));
}


      default:
        return reply("Unknown command. Use /help.");
    }
  }

  // Не команда — Intent
  const _isCont = LC.lcGetFlag("isContinue", false);
const _isRet  = LC.lcGetFlag("isRetry", false);
if (!_isCont && !_isRet && userText && userText.length > 0) L.lastIntent = userText.slice(0, 300);
  return { text: String(userText || "") };
};
return modifier(text);