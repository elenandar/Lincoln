/*
Module: Input — Lincoln v16.0.8-compat6d
Contract:
- Reads flags: ...
- Writes flags: ...
- Entry points: ...
- Invariants: recap/epoch reset only on non-command path; retry baseline preserved; command bypass on marked handlers.
- Config: LIMITS.*, CHAR_WINDOW_*, FEATURES.*, OUTPUT_BUDGET_MS (optional)
*/
// === INPUT MODIFIER v16.0.8-compat6d ===
const __SCRIPT_SLOT__ = "Input";
if (typeof LC !== "undefined") LC.DATA_VERSION = "16.0.8-compat6d";

const modifier = function (text) {
  
if (typeof LC === "undefined") return { text: String(text || "") };
  LC.DATA_VERSION = "16.0.8-compat6d";
  const L = LC.lcInit(__SCRIPT_SLOT__);

  if (L.turn === 0 && !L.openingCaptured) LC.captureOpeningFromHistory();

  const raw = String(text || "");
  const userText = LC.stripYouWrappers(raw.trim());

  const CMD_SYS_PREFIX = "\u2063\u2063"; // invisible marker to tag command SYS messages
  const CMD_SYS_META_SEP = "\u2062";
  const CMD_CYCLE_FLAG = "__cmdCyclePending";

  function stampCommandSysMessage(message) {
    const turn = L?.turn ?? 0;
    const seq = (L._cmdSysSeq = (L._cmdSysSeq || 0) + 1);
    const text = String(message ?? "");
    return {
      raw: `${CMD_SYS_PREFIX}${turn}:${seq}${CMD_SYS_META_SEP}${text}`,
      turn,
      seq,
      text
    };
  }

  function clearCommandFlags(options = {}) {
    const preserveCycle = options && options.preserveCycle === true;
    try {
      LC.Flags?.clearCmd?.();
    } catch (_) {}
    if (!preserveCycle) {
      try {
        LC.lcSetFlag?.(CMD_CYCLE_FLAG, false);
      } catch (_) {}
    }
  }

  function reply(msg){
    try { LC.lcInit?.(__SCRIPT_SLOT__); } catch(_) {}
    // команды, идущие через reply (не stop), всё равно должны снять isCmd,
    // иначе следующий этап воспримет ход как «командный»
    clearCommandFlags();
    LC.lcSys(msg);
    return { text: LC.CONFIG?.CMD_PLACEHOLDER ?? "⟦SYS⟧ OK.", stop: false };
  }
  function setCommandMode(){
    try {
      LC.Flags?.setCmd?.();
      LC.lcSetFlag?.(CMD_CYCLE_FLAG, true);
    } catch (_) {}
  }
function replyStop(msg){
  // Командные ответы: только SYS (без notice) + немедленный вывод текста
  try { LC.lcInit?.(__SCRIPT_SLOT__); } catch(_) {}
  const stamped = stampCommandSysMessage(msg);
  LC.lcSys(stamped.raw);              // лог/SYS-лента (с невидимой меткой)
  L._cmdSysSeen = { turn: stamped.turn, seq: stamped.seq };
  LC.lcConsumeMsgs?.();       // немедленно очищаем очередь SYS-сообщений
  try { LC.lcSetFlag?.(CMD_CYCLE_FLAG, true); } catch (_) {}
  clearCommandFlags({ preserveCycle: true });        // сбросить isCmd/isRetry/isContinue, но сохранить признак цикла
  return { text: `⟦SYS⟧ ${String(stamped.text || "")}`, stop: true };
}
function replyStopSilent(){
  // Без текста и без SYS-префикса — просто остановить генерацию и сбросить флаги
  try { LC.lcInit?.(__SCRIPT_SLOT__); } catch(_) {}
  try { LC.lcSetFlag?.(CMD_CYCLE_FLAG, true); } catch (_) {}
  clearCommandFlags({ preserveCycle: true });
  return { text: "", stop: true };
}

  function handleAcceptDraftCycle(currentL = L) {
    let processed = false;
    try {
      const wantAccept = LC.lcGetFlag?.("acceptDraft", false);
      if (!wantAccept) return false;
      LC.lcSetFlag?.("acceptDraft", false);
      const activeL = currentL || LC?.lcInit?.(__SCRIPT_SLOT__) || L || {};

      if (activeL.recapDraft && activeL.recapDraft.text) {
        try {
          let savedCount = 0;
          if (typeof LC.syncRecapToStoryCards === "function") {
            savedCount = LC.syncRecapToStoryCards(activeL.recapDraft.text, activeL.recapDraft.window) | 0;
          }
          activeL.lastRecapTurn = activeL.recapDraft.turn || activeL.turn;
          activeL.recapDraft = null;
          LC.lcSys?.(`✅ Recap saved${savedCount ? ` (${savedCount} card${savedCount===1?'':'s'})` : ""}.`);
        } catch (e) {
          LC.lcWarn?.("Recap save failed: " + (e && e.message));
        }
        processed = true;
      }

      if (activeL.epochDraft && activeL.epochDraft.text) {
        try {
          activeL.lastEpochTurn = activeL.epochDraft.turn || activeL.turn;
          activeL.epochDraft = null;
          LC.lcSys?.("✅ Epoch accepted.");
        } catch (e) {
          LC.lcWarn?.("Epoch accept failed: " + (e && e.message));
        }
        processed = true;
      }
    } catch (e) {
      LC.lcWarn?.("AcceptDraft handling failed: " + (e && e.message));
    }
    return processed;
  }
  // Экспорт для registry (Library)
  LC.replyStop = replyStop;
  LC.reply = reply;

  function buildHelpMessage(currentL = L) {
    const version = LC?.CONFIG?.VERSION ?? "";
    return [
      `=== COMMANDS ${version} ===`,
      "/recap — create recap draft next output",
      "/epoch — create epoch draft",
      "/continue — accept and save draft",
      "/evergreen on|off|clear|summary|set <cat>: <value>",
      "/antiecho on|off|sensitivity N (1-100)|mode soft|hard|stats|flush",
      "/events [N] — list recent events with score contribution",
      "/alias add <Name>=a,b,c | /alias del <Name> | /alias list",
      "/evhist cap <N> | /evhist last <N> | /evhist clear",
      "/characters — list active NPCs",
      "/opening — show captured opening",
      "/ui on|off — toggle UI messages",
      "/debug on|off — toggle debug mode",
      "/stats — show statistics",
      "/retry — show retry info",
      "/cadence N — set recap cadence (6-24)",
      "/story add <text> | /story del <id>",
      "/cards — list managed cards",
      "/pin <id> /unpin <id> — pseudo-pin for cleanup",
      "/del <id> — remove card by id (if possible)",
      "/ctx — inspect context overlay composition"
    ].join("\n");
  }

  function buildStatsMessage(currentL = L) {
    const activeL = currentL || LC?.lcInit?.(__SCRIPT_SLOT__) || {};
    const tm = activeL.tm || {};
    const lastRecapScore = tm.lastRecapScore;
    const score = (lastRecapScore == null) ? "n/a" : Number(lastRecapScore).toFixed(2);
    const turn = activeL.turn ?? 0;
    const lastRecap = activeL.lastRecapTurn ?? 0;
    const lastEpoch = activeL.lastEpochTurn ?? 0;
    const cadence = activeL.cadence ?? "n/a";
    const worldInfoIds = Array.isArray(activeL.worldInfoIds) ? activeL.worldInfoIds : [];
    const pinnedWorldInfoIds = Array.isArray(activeL.pinnedWorldInfoIds) ? activeL.pinnedWorldInfoIds : [];
    const characters = activeL.characters ? Object.keys(activeL.characters).length : 0;
    const echoHits = tm.echoHits || 0;
    const retryHits = tm.retries || 0;
    const errors = tm.errors || 0;
    const version = LC?.CONFIG?.VERSION ?? "";
    return [
      `=== STATISTICS ${version} ===`,
      `Turn: ${turn}`,
      `Since recap: ${turn - lastRecap}`,
      `Since epoch: ${turn - lastEpoch}`,
      `Cadence: ${cadence}`,
      `Cards: ${worldInfoIds.length} (pinned ${pinnedWorldInfoIds.length})`,
      `Characters: ${characters}`,
      `Echo hits: ${echoHits}`,
      `Retry hits: ${retryHits}`,
      `Errors: ${errors}`,
      `Last recap score: ${score}`
    ].join("\n");
  }

  function ensureSharedCommand(cmdName, builder) {
    if (!LC?.Commands) return;
    const existing = LC.Commands?.get?.(cmdName);
    if (existing && !existing.bypass && typeof existing.handler === "function") {
      return;
    }
    const prev = existing;
    const bypass = (prev && prev.bypass === true) || false;
    LC.Commands.set(cmdName, {
      handler() {
        const ctx = LC?.lcInit?.(__SCRIPT_SLOT__) || LC?.lcInit?.() || L;
        const message = builder(ctx);
        if (typeof LC.replyStop === "function") return LC.replyStop(message);
        return { text: `⟦SYS⟧ ${String(message ?? "")}`, stop: true };
      },
      bypass
    });
  }

  function extractCommand(s){
    let t = (s || "").trim();
    if ((t.startsWith('"') && t.endsWith('"')) || (t.startsWith("'") && t.endsWith("'"))) t = t.slice(1, -1).trim();
    return t.startsWith("/") ? t : null;
  }
  const cmdRaw = extractCommand(userText);
  const cmd = cmdRaw ? cmdRaw.toLowerCase() : null;
const tokens = cmdRaw ? cmdRaw.trim().split(/\s+/) : [];
const args   = tokens.slice(1);


  if (!cmd) LC.detectInputType(raw);

  // ==== Команды ====
  if (cmd) {

    const wantRecap = LC.lcGetFlag("wantRecap", false);

    ensureSharedCommand("/help", buildHelpMessage);
    ensureSharedCommand("/h", buildHelpMessage);
    ensureSharedCommand("/stats", buildStatsMessage);

    // Try registry first
    const def = LC.Commands?.get(cmd);
    if (def && typeof def.handler === "function") {
      if (def.bypass === true) {
        LC.lcSetFlag?.("isCmd", true);
        L.lastActionType = "command";
      } else {
        setCommandMode();
        L.lastActionType = "command";
      }
      try {
        const res = def.handler(args, text);
        return res;
      } catch (e) {
        return replyStop(`Command failed: ${e?.message || e}`);
      }
    }

    setCommandMode();
    L.lastActionType = "command";

// /undo [N]
    if (cmd === "/undo") {
      const n = Number(args[0] || 1);
      try { if (typeof LC !== 'undefined') LC.turnUndo(n); } catch(e) { try { LC.lcSys("⚠️ Undo failed."); } catch(_){} }
      clearCommandFlags({ preserveCycle: true });
      return replyStop(`↩️ Undid ${n|0} turn${(n|0)===1?"":"s"}.`);
    }

    // /turn set N
    if (cmd === "/turn" && (args[0] || "").toLowerCase() === "set") {
      const n = Number(args[1] || 0);
      try { if (typeof LC !== 'undefined') LC.turnSet(n); } catch(e) { try { LC.lcSys("⚠️ Turn set failed."); } catch(_){} }
      clearCommandFlags({ preserveCycle: true });
      return replyStop(`↩️ Turn set to ${n|0}.`);
    }


    // быстрые ответы на оффер recap
    if (cmd === "/да")   {
      if (!(typeof LC !== 'undefined' && LC.lcGetFlag && LC.lcGetFlag('wantRecap', wantRecap))) {
        return replyStop('ℹ️ Нет активного оффера рекапа.');
      }
      LC.lcSetFlag("wantRecap", false); L.recapMuteUntil = L.turn;
      LC.lcSetFlag("doRecap", true);
      clearCommandFlags({ preserveCycle: true }); // важно: снять isCmd до Context, но сохранить признак командного цикла
      return replyStop("📋 Recap will be generated.");
    }
    if (cmd === "/нет")  {
      if (!(typeof LC !== 'undefined' && LC.lcGetFlag && LC.lcGetFlag('wantRecap', wantRecap))) {
        return replyStop('ℹ️ Нет активного оффера рекапа.');
      }
      LC.lcSetFlag("wantRecap", false); L.recapMuteUntil = L.turn + 5;
      return replyStop("🚫 Recap postponed for 5 turns.");
    }
    if (cmd === "/позже"){
      if (!(typeof LC !== 'undefined' && LC.lcGetFlag && LC.lcGetFlag('wantRecap', wantRecap))) {
        return replyStop('ℹ️ Нет активного оффера рекапа.');
      }
      LC.lcSetFlag("wantRecap", false); L.recapMuteUntil = L.turn + 3; if (L.tm) L.tm.wantRecapTurn = 0;
      return replyStop("🕑 Recap later (3 turns).");
    }

    switch ((cmd.split(" ")[0])) {
      case "/ui":
        if (/\/ui\s+on/i.test(cmdRaw)) {
          L.sysShow = true;
          return replyStop("✅ UI enabled.");
        }
        if (/\/ui\s+off/i.test(cmdRaw)) {
          L.sysShow = false;
          return replyStop("⚫ UI disabled.");
        }
        return replyStop(`UI is ${L.sysShow ? "on" : "off"}.`);

      case "/debug":
        if (/\/debug\s+on/i.test(cmdRaw)) {
          L.debugMode = true;
          return replyStop("🔍 Debug ON.");
        }
        if (/\/debug\s+off/i.test(cmdRaw)) {
          L.debugMode = false;
          return replyStop("🔍 Debug OFF.");
        }
        return replyStop(`Debug is ${L.debugMode ? "on" : "off"}.`);

      case "/recap":
        LC.lcSetFlag("wantRecap", false);
        L.tm = L.tm || {};
        L.tm.wantRecapTurn = 0;
        LC.lcSetFlag("doRecap", true);
        return replyStop("📋 Recap requested. Next output → draft.");

      case "/epoch":
        LC.lcSetFlag("wantRecap", false);
        L.tm = L.tm || {};
        L.tm.wantRecapTurn = 0;
        LC.lcSetFlag("doEpoch", true);
        return replyStop("🗿 Epoch requested. Next output → draft.");

      case "/continue":
        if (L.recapDraft || L.epochDraft) {
          LC.lcSetFlag("acceptDraft", true);
          handleAcceptDraftCycle();
          return replyStopSilent();
        }
        return replyStop("❌ No draft to save.");

      case "/evergreen": {
        if (/\/evergreen\s+clear/i.test(cmdRaw)) {
          LC.autoEvergreen.clear();
          return replyStop("🧹 Evergreen storage cleared.");
        }
        if (/\/evergreen\s+on/i.test(cmdRaw)) {
          LC.autoEvergreen.toggle(true);
          return replyStop("🌿 Evergreen enabled.");
        }
        if (/\/evergreen\s+off/i.test(cmdRaw)) {
          LC.autoEvergreen.toggle(false);
          return replyStop("🌿 Evergreen disabled.");
        }
        if (/\/evergreen\s+summary/i.test(cmdRaw)) { return replyStop(LC.autoEvergreen.getSummary()); }
        const m = cmdRaw.match(/\/evergreen\s+set\s+([\w-]+):\s*(.+)$/i);
        if (m) {
          const cat = m[1].toLowerCase();
          let val = m[2].trim().replace(/\s+/g, " ").slice(0, 240);
          const allowed = ["facts","status","relations","obligations"];
          const target = allowed.indexOf(cat) === -1 ? "facts" : cat;
          const key = `u_${Date.now().toString(36)}`;
          LC.evergreenManualSet(L, target, key, val);
          return replyStop(`Evergreen[${target}] += ${val.slice(0,80)}`);
        }
        return replyStop(LC.autoEvergreen.getSummary());
      }

      case "/antiecho":
        if (/\/antiecho\s+stats/i.test(cmdRaw)) {
          const s = LC.antiEchoStats();
          return replyStop([
            "=== ANTI-ECHO STATS ===",
            `LRU size: ${s.lruSize}`,
            `Cache entries: ${s.cacheEntries}`,
            `Cache hits: ${s.hits}`
          ].join("\n"));
        }
        if (/\/antiecho\s+flush/i.test(cmdRaw)) {
          LC.antiEchoFlush();
          return replyStop("Anti-echo cache flushed.");
        }
        if (/\/antiecho\s+on/i.test(cmdRaw))  { L.antiEchoEnabled = true;  return replyStop("✅ Anti-echo enabled."); }
        if (/\/antiecho\s+off/i.test(cmdRaw)) { L.antiEchoEnabled = false; return replyStop("⚫ Anti-echo disabled."); }
        if (/\/antiecho\s+sensitivity\s+(\d{1,3})/i.test(cmdRaw)) {
          const v = Math.max(1, Math.min(100, parseInt(cmdRaw.match(/sensitivity\s+(\d{1,3})/i)[1], 10)));
          L.antiEchoSensitivity = v; return replyStop(`🔧 Anti-echo sensitivity = ${v}%`);
        }
        if (/\/antiecho\s+mode\s+(soft|hard)/i.test(cmdRaw)) {
          L.antiEchoMode = (cmdRaw.match(/mode\s+(soft|hard)/i)[1].toLowerCase() === "hard") ? "hard" : "soft";
          return replyStop(`🛡️ Anti-echo mode = ${L.antiEchoMode.toUpperCase()}`);
        }
        {
          const base = (L.antiEchoSensitivity || 85) / 100;
          const multSoft = LC.CONFIG.LIMITS.ANTI_ECHO.CONTINUE_THRESHOLD_MULT.SOFT;
          const multHard = LC.CONFIG.LIMITS.ANTI_ECHO.CONTINUE_THRESHOLD_MULT.HARD;
          return replyStop([
            "=== ANTI-ECHO SETTINGS ===",
            `Status: ${L.antiEchoEnabled ? "Enabled" : "Disabled"}`,
            `Sensitivity: ${L.antiEchoSensitivity || 85}%`,
            `Mode: ${L.antiEchoMode || "soft"}`,
            `Continue thr (soft/hard): ${(Math.min(0.99, base*multSoft)).toFixed(2)} / ${(Math.min(0.99, base*multHard)).toFixed(2)}`,
            `Echo hits: ${L.tm.echoHits || 0}`
          ].join("\n"));
        }

      case "/events": {
        const m = cmdRaw.match(/\/events(?:\s+(\d+))?/i);
        const n = m && m[1] ? parseInt(m[1],10) : 10;
        const diag = LC.getEventsDiagnostics(n);
        const lines = diag.rows.map(r => `${r.type.padEnd(10)} | turn ${String(r.turn).padStart(3)} | ${String(r.ago).padStart(2)} ago | w=${r.w} decay=${r.decay} → +${r.contrib}`);
        return replyStop([
          `=== EVENTS (last ${diag.rows.length}) — contribution total: +${diag.total} ===`,
          ...lines
        ].join("\n"));
      }

      case "/alias": {
        if (/\/alias\s+list/i.test(cmdRaw)) {
          const map = L.aliases || {};
          const keys = Object.keys(map);
          if (!keys.length) return replyStop("No custom aliases.");
          const out = keys.map(k => `${k}: ${map[k].join(", ")}`);
          return replyStop("=== ALIASES ===\n" + out.join("\n"));
        }
        if (/\/alias\s+add\s+/i.test(cmdRaw)) {
          const m = cmdRaw.match(/\/alias\s+add\s+([^=]+)=(.+)$/i);
          if (!m) return replyStop("Usage: /alias add <Name>=a,b,c");
          const name = m[1].trim();
          const list = m[2].split(",").map(s=>s.trim()).filter(Boolean);
          L.aliases[name] = list;
          return replyStop(`Alias set: ${name} = ${list.join(", ")}`);
        }
        if (/\/alias\s+del\s+/i.test(cmdRaw)) {
          const m = cmdRaw.match(/\/alias\s+del\s+(.+)$/i);
          if (!m) return replyStop("Usage: /alias del <Name>");
          const name = m[1].trim();
          if (name in L.aliases) { delete L.aliases[name]; return replyStop(`Alias deleted: ${name}`); }
          return replyStop(`No alias for: ${name}`);
        }
        return replyStop("Usage: /alias add <Name>=a,b,c | /alias del <Name> | /alias list");
      }

      case "/evhist": {
        if (/\/evhist\s+cap\s+(\d+)/i.test(cmdRaw)) {
          const cap = Math.max(0, parseInt(cmdRaw.match(/cap\s+(\d+)/i)[1],10));
          LC.capEvergreenHistory(cap);
          return replyStop(`Evergreen history cap = ${cap || "no cap"}.`);
        }
        if (/\/evhist\s+last\s+(\d+)/i.test(cmdRaw)) {
          const n = Math.max(1, parseInt(cmdRaw.match(/last\s+(\d+)/i)[1],10));
          const arr = (L.evergreen && Array.isArray(L.evergreen.history)) ? L.evergreen.history.slice(-n) : [];
          if (!arr.length) return replyStop("Evergreen history is empty.");
          const show = arr.map(h => {
            const oldS = String(h.old||"").slice(0,40);
            const newS = String(h.new||"").slice(0,40);
            return `t${h.turn} [${h.category}] ${oldS} ⇒ ${newS}`;
          });
          return replyStop("=== EV HISTORY ===\n" + show.join("\n"));
        }
        if (/\/evhist\s+clear/i.test(cmdRaw)) {
          if (L.evergreen) L.evergreen.history = [];
          return replyStop("Evergreen history cleared.");
        }
        return replyStop("Usage: /evhist cap <N> | /evhist last <N> | /evhist clear");
      }

      case "/characters": {
        const chars = LC.getActiveCharacters(10);
        if (chars.length) return replyStop("=== ACTIVE CHARACTERS ===\n" +
          chars.map(c => `${c.name}: ${c.mentions} mentions, ${c.turnsAgo} turns ago`).join("\n"));
        return replyStop("No active characters tracked yet.");
      }

      case "/opening":
        return replyStop(LC.getOpeningLine() || "No opening captured yet.");

      case "/retry": {
        if (/\/retry\s+keep/i.test(cmdRaw)) {
          LC.lcSetFlag("RETRY_KEEP_CONTEXT", true);
          return replyStop("🔁 Retry: keep context = ON.");
        }
        if (/\/retry\s+clear/i.test(cmdRaw)) {
          LC.lcSetFlag("RETRY_KEEP_CONTEXT", false);
          return replyStop("🔁 Retry: keep context = OFF.");
        }
        const keep = LC.lcGetFlag("RETRY_KEEP_CONTEXT", false);
        return replyStop([
          "=== RETRY ===",
          `Consecutive: ${L.consecutiveRetries || 0}`,
          `Total: ${L.tm?.retries || 0}`,
          `Turn: ${L.turn}, LastProcessed: ${L.lastProcessedTurn}`,
          `isRetry=${LC.lcGetFlag("isRetry", false)}, isContinue=${LC.lcGetFlag("isContinue", false)}`,
          `Keep context: ${keep ? "ON" : "OFF"}`
        ].join("\n"));
      }

      case "/cadence": {
        const m = cmdRaw.match(/\/cadence\s+(\d{1,3})/i);
        if (m) {
          const req = parseInt(m[1], 10);
          const v = Math.max(LC.CONFIG.LIMITS.CADENCE.MIN, Math.min(LC.CONFIG.LIMITS.CADENCE.MAX, req));
          L.cadence = v;
          if (req !== v) return replyStop(`⏱️ Recap cadence: requested ${req} → applied ${v} (range ${LC.CONFIG.LIMITS.CADENCE.MIN}-${LC.CONFIG.LIMITS.CADENCE.MAX}).`);
          return replyStop(`⏱️ Recap cadence → ${v} turns.`);
        }
        return replyStop(`Current cadence: ${L.cadence} turns.`);
      }

      case "/story": {
        if (/^\/story\s+add\s+/i.test(cmdRaw)) {
          const m = cmdRaw.match(/^\/story\s+add\s+([\s\S]+)$/i);
          const entry = m ? m[1].trim() : "";
          if (!entry || entry.length < 10) return replyStop("Usage: /story add <текст карточки (≥10 символов)>");
          const id = LC.createStoryCard(entry, [Math.max(0, L.turn - L.cadence), L.turn], "note");
          return replyStop(`📝 Card saved — ID: ${id}`);
        }
        if (/^\/story\s+del\s+/i.test(cmdRaw)) {
          const m = cmdRaw.match(/^\/story\s+del\s+(\S+)/i);
          if (!m) return replyStop("Usage: /story del <id>");
          const id = m[1].trim();
          const ok = LC.removeStoryCardById(id);
          return replyStop(ok ? `🗑️ Card ${id} removed.` : `🔎 Card ${id} not found (removed from registry if present).`);
        }
        return replyStop("Usage: /story add <text> | /story del <id>");
      }

      case "/cards": {
        const st  = (typeof state !== "undefined") ? state : {};
        const ext = Array.isArray(st.$$WORLD_INFO_EXTENDED) ? st.$$WORLD_INFO_EXTENDED : [];
        const extSet = {};
        for (let i=0;i<ext.length;i++){
          const id = ext[i] && ext[i].worldInfoId;
          if (id) extSet[id] = 1;
        }
        const ids = L.worldInfoIds.slice(-15);
        if (!ids.length) return replyStop("No managed cards.");
        return replyStop("=== CARDS (managed) ===\n" +
          ids.map((id,i)=>{
            const pin = (L.pinnedWorldInfoIds.indexOf(id)!==-1) ? " [PIN]" : "";
            const mk  = extSet[id] ? " [EXT]" : "";
            return `${i+1}. ${id}${pin}${mk}`;
          }).join("\n"));
      }

      case "/pin": {
        const m = cmdRaw.match(/\/pin\s+(\S+)/i);
        if (!m) return replyStop("Usage: /pin <id>");
        const id = m[1];
        if (L.pinnedWorldInfoIds.indexOf(id) === -1) L.pinnedWorldInfoIds.push(id);
        return replyStop(`📌 Pseudo-pin set for ${id}.`);
      }

      case "/unpin": {
        const m = cmdRaw.match(/\/unpin\s+(\S+)/i);
        if (!m) return replyStop("Usage: /unpin <id>");
        const id = m[1];
        const p = L.pinnedWorldInfoIds.indexOf(id);
        if (p !== -1) L.pinnedWorldInfoIds.splice(p,1);
        return replyStop(`📌 Pseudo-pin removed for ${id}.`);
      }

      case "/del": {
        const m = cmdRaw.match(/\/del\s+(\S+)/i);
        if (!m) return replyStop("Usage: /del <id>");
        const id = m[1];
        const p = L.pinnedWorldInfoIds.indexOf(id);
        if (p !== -1) L.pinnedWorldInfoIds.splice(p,1);
        const ok = LC.removeStoryCardById(id);
        return replyStop(ok ? `🗑️ Card ${id} removed.` : `🔎 Card ${id} not found (removed from registry if present).`);
      }

      case "/ctx": {
        const limit = LC.CONFIG?.LIMITS?.CONTEXT_LENGTH ?? 800;
        let preview = {};
        try {
          const result = LC.buildCtxPreview?.({ limit, allowPartial: true });
          if (result && typeof result === "object") preview = result;
        } catch (_) {/* ignore */}
        const overlayRaw = typeof preview.overlay === "string"
          ? preview.overlay
          : String(preview.text ?? preview.overlay ?? "");
        const overlay = overlayRaw.length > limit ? overlayRaw.slice(0, limit) : overlayRaw;
        const max = (typeof preview?.max === "number" && isFinite(preview.max)) ? preview.max : limit;
        const parts = (preview.parts && typeof preview.parts === "object") ? preview.parts : {};
        const lines = [
          `LEN: ${overlay.length}/${max}`,
          `GUIDE: ${parts.GUIDE||0}`,
          `INTENT: ${parts.INTENT||0}`,
          `TASK: ${parts.TASK||0}`,
          `CANON: ${parts.CANON||0}`,
          `OPENING: ${parts.OPENING||0}`,
          `SCENE: ${parts.SCENE||0}`,
          `META: ${parts.META||0}`
        ];
        if (preview.error) lines.push(`ERROR: ${preview.error}`);
        let sampleSource = typeof preview.preview === "string"
          ? preview.preview
          : (typeof preview.overlay === "string" ? preview.overlay : overlay);
        if (typeof sampleSource !== "string") sampleSource = "";
        const sample = sampleSource.split(/\r?\n/).slice(0,8).join("\n");
        return replyStop("=== CONTEXT INSPECTOR ===\n" + lines.join(" | ") + "\n---\n" + sample);
      }

      case "/selftest": {
        const cfg = LC.CONFIG || {};
        const anti = [
          L.antiEchoEnabled ? "ON" : "OFF",
          (L.antiEchoMode || "soft"),
          `@${L.antiEchoSensitivity ?? 85}%`
        ].join(" ");
        const out = [
          "=== SELFTEST ===",
          `Version: ${cfg.VERSION || "n/a"}`,
          `Data: ${cfg.DATA_VERSION || "n/a"}`,
          `Cadence: ${L.cadence} (muteUntil=${L.recapMuteUntil ?? "-"}, sinceRecap=${(L.turn - (L.lastRecapTurn || 0)) || 0})`,
          `Anti-echo: ${anti}`,
          `Flags: isCmd=${LC.lcGetFlag("isCmd",false)}, isRetry=${LC.lcGetFlag("isRetry",false)}, isContinue=${LC.lcGetFlag("isContinue",false)}, RETRY_KEEP_CONTEXT=${LC.lcGetFlag("RETRY_KEEP_CONTEXT",false)}`
        ];
        const mods = (L && L._modsSeen) || {};
        const modList = Object.entries(mods).map(([k,v]) => `${k}:${v}`).join(", ");
        const modSummary = modList || "n/a";
        out.push(`versions=[${modSummary}]`);
        const flagsReset = (() => {
          try {
            clearCommandFlags();
          } catch (_) {}
          return !LC.lcGetFlag("isCmd", false) && !LC.lcGetFlag("isRetry", false) && !LC.lcGetFlag("isContinue", false);
        })();
        const flagsResetStatus = flagsReset ? "ok" : "warn";
        out.push(`flagsReset=${flagsResetStatus}`);
        out.push(`echoCache=${LC._echoOrder?.length ?? 0}`);
        const ever = (L && L.evergreen) || {};
        out.push(`evHist=${ever.history?.length ?? 0}`);
        return replyStop(out.join("\n"));
      }


      default:
        return replyStop("Unknown command. Use /help.");
    }
  }

  // Не команда — Intent
  const _isCont = LC.lcGetFlag("isContinue", false);
const _isRet  = LC.lcGetFlag("isRetry", false);
if (!_isCont && !_isRet && userText && userText.length > 0) L.lastIntent = userText.slice(0, 300);
  return { text: String(userText || "") };
};
return modifier(text);