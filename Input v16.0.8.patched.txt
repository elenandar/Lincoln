/* 
Module: Input (Lincoln v16.0.8-compat6d)
Contract:
- Reads flags: ...; Writes flags: ...
- Entry points: ...
- Invariants: recap/epoch flags reset only on non-command path; retry baseline preserved; ...
- Config keys used: CONTEXT_LENGTH, CHAR_WINDOW_*, LIMITS.ANTI_ECHO, FEATURES.*
*/
// === INPUT MODIFIER v16.0.8-compat6d ===
const __SCRIPT_SLOT__ = "Input";
if (typeof LC !== "undefined") LC.DATA_VERSION = "16.0.8-compat6d";

const modifier = function (text) {
  
if (typeof LC === "undefined") return { text: String(text || "") };
  LC.DATA_VERSION = "16.0.8-compat6d";
  const L = LC.lcInit(__SCRIPT_SLOT__);

  if (L.turn === 0 && !L.openingCaptured) LC.captureOpeningFromHistory();

  const raw = String(text || "");
  const userText = LC.stripYouWrappers(raw.trim());

  function reply(msg){
    LC.lcSys(msg);
    return { text: LC.CONFIG?.CMD_PLACEHOLDER ?? "⟦SYS⟧ OK." };
  }
  function clearCommandFlags(){
    try {
      LC.Flags?.clearCmd?.();
    } catch (_) {}
  }
  function setCommandMode(){
    try {
      LC.Flags?.setCmd?.();
    } catch (_) {}
  }
  function replyStop(msg){
    const state = (L && typeof L === "object") ? L : (() => {
      try { return LC.lcInit(__SCRIPT_SLOT__); } catch (_) { return null; }
    })();
    if (state) {
      LC.pushNotice?.(msg);
    }
    LC.lcSys(msg);
    clearCommandFlags();
    return { text: LC.CONFIG?.CMD_PLACEHOLDER ?? "⟦SYS⟧ OK.", stop: true, _sys: msg };
  }

  function extractCommand(s){
    let t = (s || "").trim();
    if ((t.startsWith('"') && t.endsWith('"')) || (t.startsWith("'") && t.endsWith("'"))) t = t.slice(1, -1).trim();
    return t.startsWith("/") ? t : null;
  }
  const cmdRaw = extractCommand(userText);
  const cmd = cmdRaw ? cmdRaw.toLowerCase() : null;
const tokens = cmdRaw ? cmdRaw.trim().split(/\s+/) : [];
const args   = tokens.slice(1);


  if (!cmd) LC.detectInputType(raw);

  // ==== Команды ====
  if (cmd) {
    setCommandMode();
    L.lastActionType = "command";


    const wantRecap = LC.lcGetFlag("wantRecap", false);
// /undo [N]
    if (cmd === "/undo") {
      const n = Number(args[0] || 1);
      try { if (typeof LC !== 'undefined') LC.turnUndo(n); } catch(e) { try { LC.lcSys("⚠️ Undo failed."); } catch(_){} }
      clearCommandFlags();
      return { text: "", stop: true };
    }

    // /turn set N
    if (cmd === "/turn" && (args[0] || "").toLowerCase() === "set") {
      const n = Number(args[1] || 0);
      try { if (typeof LC !== 'undefined') LC.turnSet(n); } catch(e) { try { LC.lcSys("⚠️ Turn set failed."); } catch(_){} }
      clearCommandFlags();
      return { text: "", stop: true };
    }


    // быстрые ответы на оффер recap
    if (cmd === "/да")   {
      if (!(typeof LC !== 'undefined' && LC.lcGetFlag && LC.lcGetFlag('wantRecap', wantRecap))) {
        return replyStop('ℹ️ Нет активного оффера рекапа.');
      }
      LC.lcSetFlag("wantRecap", false); L.recapMuteUntil = L.turn;
      LC.lcSetFlag("doRecap", true);
      return reply("📋 Recap will be generated.");
    }
    if (cmd === "/нет")  {
      if (!(typeof LC !== 'undefined' && LC.lcGetFlag && LC.lcGetFlag('wantRecap', wantRecap))) {
        return replyStop('ℹ️ Нет активного оффера рекапа.');
      }
      LC.lcSetFlag("wantRecap", false); L.recapMuteUntil = L.turn + 5;
      return reply("🚫 Recap postponed for 5 turns.");
    }
    if (cmd === "/позже"){
      if (!(typeof LC !== 'undefined' && LC.lcGetFlag && LC.lcGetFlag('wantRecap', wantRecap))) {
        return replyStop('ℹ️ Нет активного оффера рекапа.');
      }
      LC.lcSetFlag("wantRecap", false); L.recapMuteUntil = L.turn + 3; if (L.tm) L.tm.wantRecapTurn = 0;
      return reply("🕑 Recap later (3 turns).");
    }

    // Registry first
    try {
      const reg = LC.Commands?.get(cmd);
      if (reg && typeof reg.handler === "function") {
        return reg.handler(args, text);
      }
    } catch(e) {
      return replyStop(`Command failed: ${e?.message||e}`);
    }

    switch ((cmd.split(" ")[0])) {
      case "/help":
      case "/h":
        return replyStop([
          `=== COMMANDS ${LC.CONFIG.VERSION} ===`,
          "/recap — create recap draft next output",
          "/epoch — create epoch draft",
          "/continue — accept and save draft",
          "/evergreen on|off|clear|summary|set <cat>: <value>",
          "/antiecho on|off|sensitivity N (1-100)|mode soft|hard|stats|flush",
          "/events [N] — list recent events with score contribution",
          "/alias add <Name>=a,b,c | /alias del <Name> | /alias list",
          "/evhist cap <N> | /evhist last <N> | /evhist clear",
          "/characters — list active NPCs",
          "/opening — show captured opening",
          "/ui on|off — toggle UI messages",
          "/debug on|off — toggle debug mode",
          "/stats — show statistics",
          "/retry — show retry info",
          "/cadence N — set recap cadence (6-24)",
          "/story add <text> | /story del <id>",
          "/cards — list managed cards",
          "/pin <id> /unpin <id> — pseudo-pin for cleanup",
          "/del <id> — remove card by id (if possible)",
          "/ctx — inspect context overlay composition"
        ].join("\n"));

      case "/ui":
        if (/\/ui\s+on/i.test(cmdRaw))  { L.sysShow = true;  return replyStop("✅ UI enabled."); }
        if (/\/ui\s+off/i.test(cmdRaw)) { L.sysShow = false; return replyStop("⚫ UI disabled."); }
        return replyStop(`UI is ${L.sysShow ? "on" : "off"}.`);

      case "/debug":
        if (/\/debug\s+on/i.test(cmdRaw))  { L.debugMode = true;  return replyStop("🔍 Debug ON."); }
        if (/\/debug\s+off/i.test(cmdRaw)) { L.debugMode = false; return replyStop("🔍 Debug OFF."); }
        return replyStop(`Debug is ${L.debugMode ? "on" : "off"}.`);

      case "/recap":
        LC.lcSetFlag("doRecap", true);
        return reply("📋 Recap requested. Next output → draft.");

      case "/epoch":
        LC.lcSetFlag("doEpoch", true);
        return reply("🗿 Epoch requested. Next output → draft.");

      case "/continue":
        if (L.recapDraft || L.epochDraft) { LC.lcSetFlag("acceptDraft", true); return reply("✅ Draft will be saved now."); }
        return replyStop("❌ No draft to save.");

      case "/evergreen": {
        if (/\/evergreen\s+clear/i.test(cmdRaw)) { LC.autoEvergreen.clear(); return reply("🧹 Evergreen storage cleared."); }
        if (/\/evergreen\s+on/i.test(cmdRaw))    { LC.autoEvergreen.toggle(true);  return reply("🌿 Evergreen enabled."); }
        if (/\/evergreen\s+off/i.test(cmdRaw))   { LC.autoEvergreen.toggle(false); return reply("🌿 Evergreen disabled."); }
        if (/\/evergreen\s+summary/i.test(cmdRaw)) { return replyStop(LC.autoEvergreen.getSummary()); }
        const m = cmdRaw.match(/\/evergreen\s+set\s+([\w-]+):\s*(.+)$/i);
        if (m) {
          const cat = m[1].toLowerCase();
          let val = m[2].trim().replace(/\s+/g, " ").slice(0, 240);
          const allowed = ["facts","status","relations","obligations"];
          const target = allowed.indexOf(cat) === -1 ? "facts" : cat;
          const key = `u_${Date.now().toString(36)}`;
          LC.evergreenManualSet(L, target, key, val);
          return reply(`Evergreen[${target}] += ${val.slice(0,80)}`);
        }
        return replyStop(LC.autoEvergreen.getSummary());
      }

      case "/antiecho":
        if (/\/antiecho\s+stats/i.test(cmdRaw)) {
          const s = LC.antiEchoStats();
          return replyStop([
            "=== ANTI-ECHO STATS ===",
            `LRU size: ${s.lruSize}`,
            `Cache entries: ${s.cacheEntries}`,
            `Cache hits: ${s.hits}`
          ].join("\n"));
        }
        if (/\/antiecho\s+flush/i.test(cmdRaw)) {
          LC.antiEchoFlush(); return reply("Anti-echo cache flushed.");
        }
        if (/\/antiecho\s+on/i.test(cmdRaw))  { L.antiEchoEnabled = true;  return reply("✅ Anti-echo enabled."); }
        if (/\/antiecho\s+off/i.test(cmdRaw)) { L.antiEchoEnabled = false; return reply("⚫ Anti-echo disabled."); }
        if (/\/antiecho\s+sensitivity\s+(\d{1,3})/i.test(cmdRaw)) {
          const v = Math.max(1, Math.min(100, parseInt(cmdRaw.match(/sensitivity\s+(\d{1,3})/i)[1], 10)));
          L.antiEchoSensitivity = v; return reply(`🔧 Anti-echo sensitivity = ${v}%`);
        }
        if (/\/antiecho\s+mode\s+(soft|hard)/i.test(cmdRaw)) {
          L.antiEchoMode = (cmdRaw.match(/mode\s+(soft|hard)/i)[1].toLowerCase() === "hard") ? "hard" : "soft";
          return reply(`🛡️ Anti-echo mode = ${L.antiEchoMode.toUpperCase()}`);
        }
        {
          const base = (L.antiEchoSensitivity || 85) / 100;
          const multSoft = LC.CONFIG.LIMITS.ANTI_ECHO.CONTINUE_THRESHOLD_MULT.SOFT;
          const multHard = LC.CONFIG.LIMITS.ANTI_ECHO.CONTINUE_THRESHOLD_MULT.HARD;
          return replyStop([
            "=== ANTI-ECHO SETTINGS ===",
            `Status: ${L.antiEchoEnabled ? "Enabled" : "Disabled"}`,
            `Sensitivity: ${L.antiEchoSensitivity || 85}%`,
            `Mode: ${L.antiEchoMode || "soft"}`,
            `Continue thr (soft/hard): ${(Math.min(0.99, base*multSoft)).toFixed(2)} / ${(Math.min(0.99, base*multHard)).toFixed(2)}`,
            `Echo hits: ${L.tm.echoHits || 0}`
          ].join("\n"));
        }

      case "/events": {
        const m = cmdRaw.match(/\/events(?:\s+(\d+))?/i);
        const n = m && m[1] ? parseInt(m[1],10) : 10;
        const diag = LC.getEventsDiagnostics(n);
        const lines = diag.rows.map(r => `${r.type.padEnd(10)} | turn ${String(r.turn).padStart(3)} | ${String(r.ago).padStart(2)} ago | w=${r.w} decay=${r.decay} → +${r.contrib}`);
        return replyStop([
          `=== EVENTS (last ${diag.rows.length}) — contribution total: +${diag.total} ===`,
          ...lines
        ].join("\n"));
      }

      case "/alias": {
        if (/\/alias\s+list/i.test(cmdRaw)) {
          const map = L.aliases || {};
          const keys = Object.keys(map);
          if (!keys.length) return replyStop("No custom aliases.");
          const out = keys.map(k => `${k}: ${map[k].join(", ")}`);
          return replyStop("=== ALIASES ===\n" + out.join("\n"));
        }
        if (/\/alias\s+add\s+/i.test(cmdRaw)) {
          const m = cmdRaw.match(/\/alias\s+add\s+([^=]+)=(.+)$/i);
          if (!m) return replyStop("Usage: /alias add <Name>=a,b,c");
          const name = m[1].trim();
          const list = m[2].split(",").map(s=>s.trim()).filter(Boolean);
          L.aliases[name] = list;
          return reply(`Alias set: ${name} = ${list.join(", ")}`);
        }
        if (/\/alias\s+del\s+/i.test(cmdRaw)) {
          const m = cmdRaw.match(/\/alias\s+del\s+(.+)$/i);
          if (!m) return replyStop("Usage: /alias del <Name>");
          const name = m[1].trim();
          if (name in L.aliases) { delete L.aliases[name]; return reply(`Alias deleted: ${name}`); }
          return replyStop(`No alias for: ${name}`);
        }
        return replyStop("Usage: /alias add <Name>=a,b,c | /alias del <Name> | /alias list");
      }

      case "/evhist": {
        if (/\/evhist\s+cap\s+(\d+)/i.test(cmdRaw)) {
          const cap = Math.max(0, parseInt(cmdRaw.match(/cap\s+(\d+)/i)[1],10));
          LC.capEvergreenHistory(cap);
          return reply(`Evergreen history cap = ${cap || "no cap"}.`);
        }
        if (/\/evhist\s+last\s+(\d+)/i.test(cmdRaw)) {
          const n = Math.max(1, parseInt(cmdRaw.match(/last\s+(\d+)/i)[1],10));
          const arr = (L.evergreen && Array.isArray(L.evergreen.history)) ? L.evergreen.history.slice(-n) : [];
          if (!arr.length) return replyStop("Evergreen history is empty.");
          const show = arr.map(h => {
            const oldS = String(h.old||"").slice(0,40);
            const newS = String(h.new||"").slice(0,40);
            return `t${h.turn} [${h.category}] ${oldS} ⇒ ${newS}`;
          });
          return replyStop("=== EV HISTORY ===\n" + show.join("\n"));
        }
        if (/\/evhist\s+clear/i.test(cmdRaw)) {
          if (L.evergreen) L.evergreen.history = [];
          return reply("Evergreen history cleared.");
        }
        return replyStop("Usage: /evhist cap <N> | /evhist last <N> | /evhist clear");
      }

      case "/characters": {
        const chars = LC.getActiveCharacters(10);
        if (chars.length) return replyStop("=== ACTIVE CHARACTERS ===\n" +
          chars.map(c => `${c.name}: ${c.mentions} mentions, ${c.turnsAgo} turns ago`).join("\n"));
        return replyStop("No active characters tracked yet.");
      }

      case "/opening":
        return replyStop(LC.getOpeningLine() || "No opening captured yet.");

      case "/retry":
        
{
  if (/\/retry\s+keep/i.test(cmdRaw)) {
    LC.lcSetFlag("RETRY_KEEP_CONTEXT", true);
    return reply("🔁 Retry: keep context = ON.");
  }
  if (/\/retry\s+clear/i.test(cmdRaw)) {
    LC.lcSetFlag("RETRY_KEEP_CONTEXT", false);
    return reply("🔁 Retry: keep context = OFF.");
  }
  const keep = LC.lcGetFlag("RETRY_KEEP_CONTEXT", false);
  return replyStop([
    "=== RETRY ===",
    `Consecutive: ${L.consecutiveRetries || 0}`,
    `Total: ${L.tm?.retries || 0}`,
    `Turn: ${L.turn}, LastProcessed: ${L.lastProcessedTurn}`,
    `isRetry=${LC.lcGetFlag("isRetry", false)}, isContinue=${LC.lcGetFlag("isContinue", false)}`,
    `Keep context: ${keep ? "ON" : "OFF"}`
  ].join("\n"));
}


      case "/stats": {
        const s = (L.tm.lastRecapScore == null) ? "n/a" : Number(L.tm.lastRecapScore).toFixed(2);
        return replyStop([
          `=== STATISTICS ${LC.CONFIG.VERSION} ===`,
          `Turn: ${L.turn}`,
          `Since recap: ${L.turn - (L.lastRecapTurn || 0)}`,
          `Since epoch: ${L.turn - (L.lastEpochTurn || 0)}`,
          `Cadence: ${L.cadence}`,
          `Cards: ${L.worldInfoIds.length} (pinned ${L.pinnedWorldInfoIds.length})`,
          `Characters: ${Object.keys(L.characters).length}`,
          `Echo hits: ${L.tm.echoHits || 0}`,
          `Retry hits: ${L.tm.retries || 0}`,
          `Errors: ${L.tm.errors || 0}`,
          `Last recap score: ${s}`
        ].join("\n"));
      }

      case "/cadence": {
        const m = cmdRaw.match(/\/cadence\s+(\d{1,3})/i);
        if (m) {
          const req = parseInt(m[1], 10);
          const v = Math.max(LC.CONFIG.LIMITS.CADENCE.MIN, Math.min(LC.CONFIG.LIMITS.CADENCE.MAX, req));
          L.cadence = v;
          if (req !== v) return reply(`⏱️ Recap cadence: requested ${req} → applied ${v} (range ${LC.CONFIG.LIMITS.CADENCE.MIN}-${LC.CONFIG.LIMITS.CADENCE.MAX}).`);
          return reply(`⏱️ Recap cadence → ${v} turns.`);
        }
        return replyStop(`Current cadence: ${L.cadence} turns.`);
      }

      case "/story": {
        if (/^\/story\s+add\s+/i.test(cmdRaw)) {
          const m = cmdRaw.match(/^\/story\s+add\s+([\s\S]+)$/i);
          const entry = m ? m[1].trim() : "";
          if (!entry || entry.length < 10) return replyStop("Usage: /story add <текст карточки (≥10 символов)>");
          const id = LC.createStoryCard(entry, [Math.max(0, L.turn - L.cadence), L.turn], "note");
          return reply(`📝 Card saved — ID: ${id}`);
        }
        if (/^\/story\s+del\s+/i.test(cmdRaw)) {
          const m = cmdRaw.match(/^\/story\s+del\s+(\S+)/i);
          if (!m) return replyStop("Usage: /story del <id>");
          const id = m[1].trim();
          const ok = LC.removeStoryCardById(id);
          return reply(ok ? `🗑️ Card ${id} removed.` : `🔎 Card ${id} not found (removed from registry if present).`);
        }
        return replyStop("Usage: /story add <text> | /story del <id>");
      }

      case "/cards": {
        const st  = (typeof state !== "undefined") ? state : {};
        const ext = Array.isArray(st.$$WORLD_INFO_EXTENDED) ? st.$$WORLD_INFO_EXTENDED : [];
        const extSet = {};
        for (let i=0;i<ext.length;i++){
          const id = ext[i] && ext[i].worldInfoId;
          if (id) extSet[id] = 1;
        }
        const ids = L.worldInfoIds.slice(-15);
        if (!ids.length) return replyStop("No managed cards.");
        return replyStop("=== CARDS (managed) ===\n" +
          ids.map((id,i)=>{
            const pin = (L.pinnedWorldInfoIds.indexOf(id)!==-1) ? " [PIN]" : "";
            const mk  = extSet[id] ? " [EXT]" : "";
            return `${i+1}. ${id}${pin}${mk}`;
          }).join("\n"));
      }

      case "/pin": {
        const m = cmdRaw.match(/\/pin\s+(\S+)/i);
        if (!m) return replyStop("Usage: /pin <id>");
        const id = m[1];
        if (L.pinnedWorldInfoIds.indexOf(id) === -1) L.pinnedWorldInfoIds.push(id);
        return reply(`📌 Pseudo-pin set for ${id}.`);
      }

      case "/unpin": {
        const m = cmdRaw.match(/\/unpin\s+(\S+)/i);
        if (!m) return replyStop("Usage: /unpin <id>");
        const id = m[1];
        const p = L.pinnedWorldInfoIds.indexOf(id);
        if (p !== -1) L.pinnedWorldInfoIds.splice(p,1);
        return reply(`📌 Pseudo-pin removed for ${id}.`);
      }

      case "/del": {
        const m = cmdRaw.match(/\/del\s+(\S+)/i);
        if (!m) return replyStop("Usage: /del <id>");
        const id = m[1];
        const p = L.pinnedWorldInfoIds.indexOf(id);
        if (p !== -1) L.pinnedWorldInfoIds.splice(p,1);
        const ok = LC.removeStoryCardById(id);
        return reply(ok ? `🗑️ Card ${id} removed.` : `🔎 Card ${id} not found (removed from registry if present).`);
      }

      case "/ctx": {
        const limit = LC.CONFIG?.LIMITS?.CONTEXT_LENGTH ?? 800;
        let r;
        try {
          r = LC.composeContextOverlay?.({ limit, allowPartial: true });
        } catch (_) {/* ignore */}
        if (!r || typeof r !== "object") {
          r = LC.buildCtxPreview?.({ limit, allowPartial: true });
        }
        const overlayRaw = (r && typeof r.text === "string") ? r.text
          : (typeof r?.overlay === "string") ? r.overlay
          : String(r?.text ?? r?.overlay ?? "");
        const max = (typeof r?.max === "number" && isFinite(r.max)) ? r.max : limit;
        const parts = (r.parts && typeof r.parts === "object") ? r.parts : {};
        const overlay = overlayRaw.length > limit ? overlayRaw.slice(0, limit) : overlayRaw;
        const buildContextPreview = () => overlay.split(/\r?\n/).slice(0,8).join("\n");
        const lines = [
          `LEN: ${overlay.length}/${max}`,
          `GUIDE: ${parts.GUIDE||0}`,
          `INTENT: ${parts.INTENT||0}`,
          `TASK: ${parts.TASK||0}`,
          `CANON: ${parts.CANON||0}`,
          `OPENING: ${parts.OPENING||0}`,
          `SCENE: ${parts.SCENE||0}`,
          `META: ${parts.META||0}`
        ];
        let sample = "";
        try {
          const preview = LC.buildCtxPreview?.(LC.lcInit?.());
          if (typeof preview === "string") {
            sample = preview;
          } else if (preview && typeof preview === "object") {
            if (typeof preview.preview === "string") {
              sample = preview.preview;
            } else if (typeof preview.overlay === "string") {
              sample = preview.overlay;
            }
          }
        } catch (_) {}
        if (!sample) sample = buildContextPreview(); // временный фоллбэк
        else sample = String(sample).split(/\r?\n/).slice(0,8).join("\n");
        return replyStop("=== CONTEXT INSPECTOR ===\n" + lines.join(" | ") + "\n---\n" + sample);
      }

      case "/selftest": {
        const cfg = LC.CONFIG || {};
        const anti = [
          L.antiEchoEnabled ? "ON" : "OFF",
          (L.antiEchoMode || "soft"),
          `@${L.antiEchoSensitivity ?? 85}%`
        ].join(" ");
        const out = [
          "=== SELFTEST ===",
          `Version: ${cfg.VERSION || "n/a"}`,
          `Data: ${cfg.DATA_VERSION || "n/a"}`,
          `Cadence: ${L.cadence} (muteUntil=${L.recapMuteUntil ?? "-"}, sinceRecap=${(L.turn - (L.lastRecapTurn || 0)) || 0})`,
          `Anti-echo: ${anti}`,
          `Flags: isCmd=${LC.lcGetFlag("isCmd",false)}, isRetry=${LC.lcGetFlag("isRetry",false)}, isContinue=${LC.lcGetFlag("isContinue",false)}, RETRY_KEEP_CONTEXT=${LC.lcGetFlag("RETRY_KEEP_CONTEXT",false)}`
        ];
        const mods = (L && L._modsSeen) || {};
        const modList = Object.entries(mods).map(([k,v]) => `${k}:${v}`).join(", ");
        const modSummary = modList || "n/a";
        out.push(`versions=[${modSummary}]`);
        const flagsReset = (() => {
          try {
            clearCommandFlags();
          } catch (_) {}
          return !LC.lcGetFlag("isCmd", false) && !LC.lcGetFlag("isRetry", false) && !LC.lcGetFlag("isContinue", false);
        })();
        const flagsResetStatus = flagsReset ? "ok" : "warn";
        out.push(`flagsReset=${flagsResetStatus}`);
        out.push(`echoCache=${LC._echoOrder?.length ?? 0}`);
        const ever = (L && L.evergreen) || {};
        out.push(`evHist=${ever.history?.length ?? 0}`);
        return replyStop(out.join("\n"));
      }


      default:
        return replyStop("Unknown command. Use /help.");
    }
  }

  // Не команда — Intent
  const _isCont = LC.lcGetFlag("isContinue", false);
const _isRet  = LC.lcGetFlag("isRetry", false);
if (!_isCont && !_isRet && userText && userText.length > 0) L.lastIntent = userText.slice(0, 300);
  return { text: String(userText || "") };
};
return modifier(text);