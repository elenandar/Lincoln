/*
Module: Input â€” Lincoln v16.0.8-compat6d
Contract:
- Reads flags: ...
- Writes flags: ...
- Entry points: ...
- Invariants:
  - Turn +1 on story input and the UI Continue button.
  - Turn +0 on slash commands (including `/continue`) and retries.
  - `/continue` slash command accepts recap/epoch drafts (not the UI button).
  - Context overlay falls back to upstream text when empty or on error.
- Config: LIMITS.*, CHAR_WINDOW_*, FEATURES.*, OUTPUT_BUDGET_MS (optional)
*/
// === INPUT MODIFIER v16.0.8-compat6d ===
const __SCRIPT_SLOT__ = "Input";
if (typeof LC !== "undefined") LC.DATA_VERSION = "16.0.8-compat6d";

const modifier = function (text) {
  
if (typeof LC === "undefined") return { text: String(text || "") };
  LC.DATA_VERSION = "16.0.8-compat6d";
  const L = LC.lcInit(__SCRIPT_SLOT__);

  if (L.turn === 0 && !L.openingCaptured) LC.captureOpeningFromHistory();

  const raw = String(text || "");
  const userText = LC.stripYouWrappers(raw.trim());

  const CMD_SYS_PREFIX = "\u2063\u2063"; // invisible marker to tag command SYS messages
  const CMD_SYS_META_SEP = "\u2062";
  const CMD_CYCLE_FLAG = "__cmdCyclePending";

  function ensureCommandRegistryBypassGuard() {
    const registry = LC?.Commands;
    if (!registry || typeof registry.set !== "function" || registry.__lcBypassGuard) return;
    const originalSet = registry.set;
    registry.set = function guardedSet(cmdName, definition) {
      let nextDef = definition;
      try {
        const prev = this.get?.(cmdName);
        if (prev && prev.bypass === true) {
          if (nextDef && typeof nextDef === "object") {
            if (nextDef.bypass !== true) {
              let applied = false;
              try {
                nextDef.bypass = true;
                applied = nextDef.bypass === true;
              } catch (_) {}
              if (!applied) {
                nextDef = { ...nextDef, bypass: true };
              }
            }
          } else if (typeof nextDef === "function") {
            nextDef = { handler: nextDef, bypass: true };
          }
        }
      } catch (_) {}
      return originalSet.call(this, cmdName, nextDef);
    };
    registry.__lcBypassGuard = true;
  }

  function stampCommandSysMessage(message) {
    const turn = L?.turn ?? 0;
    const seq = (L._cmdSysSeq = (L._cmdSysSeq || 0) + 1);
    const text = String(message ?? "");
    return {
      raw: `${CMD_SYS_PREFIX}${turn}:${seq}${CMD_SYS_META_SEP}${text}`,
      turn,
      seq,
      text
    };
  }

  function clearCommandFlags(options = {}) {
    const preserveCycle = options && options.preserveCycle === true;
    try {
      LC.Flags?.clearCmd?.(preserveCycle);
    } catch (_) {}
    if (!preserveCycle) {
      try {
        const L = LC.lcInit ? LC.lcInit(__SCRIPT_SLOT__) : {};
        if (L.currentAction) delete L.currentAction.__cmdCyclePending;
      } catch (_) {}
    }
  }

  function setCommandMode(){
    try {
      LC.Flags?.setCmd?.();
      const L = LC.lcInit ? LC.lcInit(__SCRIPT_SLOT__) : {};
      if (L.currentAction) L.currentAction.__cmdCyclePending = true;
    } catch (_) {}
  }
function replyStop(msg){
  try { LC.lcInit?.(__SCRIPT_SLOT__); } catch(_) {}
  const L = LC.lcInit ? LC.lcInit(__SCRIPT_SLOT__) : {};
  if (L.currentAction) L.currentAction.type = 'command';
  const line = LC.sysLine?.(msg) || "";
  try { LC.lcConsumeMsgs?.(); } catch(_) {} // Ð¾Ñ‡Ð¸ÑÑ‚ÐºÐ° Ñ…Ð²Ð¾ÑÑ‚Ð° Ð¾Ñ‡ÐµÑ€ÐµÐ´Ð¸
  return { text: line ? line + "\n" : "", stop: true };
}

function replyStopSilent(){
  try { LC.lcInit?.(__SCRIPT_SLOT__); } catch(_) {}
  const L = LC.lcInit ? LC.lcInit(__SCRIPT_SLOT__) : {};
  if (L.currentAction) L.currentAction.type = 'command';
  try { LC.lcConsumeMsgs?.(); } catch(_) {}
  return { text: "", stop: true };
}

  // Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚ Ð´Ð»Ñ registry (Library)
  LC.replyStop = replyStop;

  function buildHelpMessage(currentL = L) {
    const version = LC?.CONFIG?.VERSION ?? "";
    const lines = [`=== COMMANDS ${version} ===`];
    
    // Auto-generate from LC.CommandsRegistry
    if (LC?.CommandsRegistry && typeof LC.CommandsRegistry.entries === 'function') {
      const entries = Array.from(LC.CommandsRegistry.entries());
      for (const [cmdName, cmdDef] of entries) {
        if (cmdDef && cmdDef.description) {
          lines.push(cmdDef.description);
        }
      }
    }
    
    return lines.join("\n");
  }

  function buildStatsMessage(currentL = L) {
    const activeL = currentL || LC?.lcInit?.(__SCRIPT_SLOT__) || {};
    const tm = activeL.tm || {};
    const lastRecapScore = tm.lastRecapScore;
    const score = (lastRecapScore == null) ? "n/a" : Number(lastRecapScore).toFixed(2);
    const turn = activeL.turn ?? 0;
    const lastRecap = activeL.lastRecapTurn ?? 0;
    const lastEpoch = activeL.lastEpochTurn ?? 0;
    const cadence = activeL.cadence ?? "n/a";
    const worldInfoIds = Array.isArray(activeL.worldInfoIds) ? activeL.worldInfoIds : [];
    const pinnedWorldInfoIds = Array.isArray(activeL.pinnedWorldInfoIds) ? activeL.pinnedWorldInfoIds : [];
    const characters = activeL.characters ? Object.keys(activeL.characters).length : 0;
    const echoHits = tm.echoHits || 0;
    const retryHits = tm.retries || 0;
    const errors = tm.errors || 0;
    const version = LC?.CONFIG?.VERSION ?? "";
    return [
      `=== STATISTICS ${version} ===`,
      `Turn: ${turn}`,
      `Since recap: ${turn - lastRecap}`,
      `Since epoch: ${turn - lastEpoch}`,
      `Cadence: ${cadence}`,
      `Cards: ${worldInfoIds.length} (pinned ${pinnedWorldInfoIds.length})`,
      `Characters: ${characters}`,
      `Echo hits: ${echoHits}`,
      `Retry hits: ${retryHits}`,
      `Errors: ${errors}`,
      `Last recap score: ${score}`
    ].join("\n");
  }

  function ensureSharedCommand(cmdName, builder) {
    if (!LC?.Commands) return;
    ensureCommandRegistryBypassGuard();
    const existing = LC.Commands?.get?.(cmdName);
    if (existing && !existing.bypass && typeof existing.handler === "function") {
      return;
    }
    const prev = LC.Commands?.get?.(cmdName);
    const bypass = (prev && prev.bypass === true) || false;
    LC.Commands.set(cmdName, {
      handler() {
        const ctx = LC?.lcInit?.(__SCRIPT_SLOT__) || LC?.lcInit?.() || L;
        const message = builder(ctx);
        if (typeof LC.replyStop === "function") return LC.replyStop(message);
        return { text: `âŸ¦SYSâŸ§ ${String(message ?? "")}`, stop: true };
      },
      bypass
    });
  }

  function extractCommand(s){
    let t = (s || "").trim();
    if ((t.startsWith('"') && t.endsWith('"')) || (t.startsWith("'") && t.endsWith("'"))) t = t.slice(1, -1).trim();
    return t.startsWith("/") ? t : null;
  }
  const cmdRaw = extractCommand(userText);
  const cmd = cmdRaw ? cmdRaw.toLowerCase() : null;
const tokens = cmdRaw ? cmdRaw.trim().split(/\s+/) : [];
const args   = tokens.slice(1);


  if (!cmd) LC.detectInputType(raw);

  // ==== ÐšÐ¾Ð¼Ð°Ð½Ð´Ñ‹ ====
  if (cmd) {
    ensureCommandRegistryBypassGuard();

    const wantRecap = L.currentAction?.wantRecap || false;

    ensureSharedCommand("/help", buildHelpMessage);
    ensureSharedCommand("/h", buildHelpMessage);
    ensureSharedCommand("/stats", buildStatsMessage);

    // Try registry first
    const def = LC.Commands?.get(cmd);
    if (def && typeof def.handler === "function") {
      if (def.bypass === true) {
        L.currentAction = { type: 'command', name: cmd };
        L.lastActionType = "command";
      } else {
        setCommandMode();
        L.lastActionType = "command";
      }
      try {
        const res = def.handler(args, text);
        if (def?.bypass) {
          L.currentAction = { type: 'command', name: cmd };
          L.lastActionType = "command";
        }
        return res;
      } catch (e) {
        return replyStop(`Command failed: ${e?.message || e}`);
      }
    }

    setCommandMode();
    L.lastActionType = "command";

    if (def?.bypass) {
      L.currentAction = { type: 'command', name: cmd };
      L.lastActionType = "command";
    }

// /undo [N]
    if (cmd === "/undo") {
      const n = Number(args[0] || 1);
      try { if (typeof LC !== 'undefined') LC.turnUndo(n); } catch(e) { try { LC.lcSys("âš ï¸ Undo failed."); } catch(_){} }
      clearCommandFlags({ preserveCycle: true });
      return replyStop(`â†©ï¸ Undid ${n|0} turn${(n|0)===1?"":"s"}.`);
    }

    // /turn set N
    if (cmd === "/turn" && (args[0] || "").toLowerCase() === "set") {
      const n = Number(args[1] || 0);
      try { if (typeof LC !== 'undefined') LC.turnSet(n); } catch(e) { try { LC.lcSys("âš ï¸ Turn set failed."); } catch(_){} }
      clearCommandFlags({ preserveCycle: true });
      return replyStop(`â†©ï¸ Turn set to ${n|0}.`);
    }


    // Ð±Ñ‹ÑÑ‚Ñ€Ñ‹Ðµ Ð¾Ñ‚Ð²ÐµÑ‚Ñ‹ Ð½Ð° Ð¾Ñ„Ñ„ÐµÑ€ recap
    if (cmd === "/Ð´Ð°")   {
      if (!(typeof LC !== 'undefined' && L.currentAction && L.currentAction.wantRecap)) {
        return replyStop('â„¹ï¸ ÐÐµÑ‚ Ð°ÐºÑ‚Ð¸Ð²Ð½Ð¾Ð³Ð¾ Ð¾Ñ„Ñ„ÐµÑ€Ð° Ñ€ÐµÐºÐ°Ð¿Ð°.');
      }
      delete L.currentAction.wantRecap;
      L.recapMuteUntil = L.turn;
      L.currentAction = { type: 'story', task: 'recap' };
      clearCommandFlags({ preserveCycle: true }); // Ð²Ð°Ð¶Ð½Ð¾: ÑÐ½ÑÑ‚ÑŒ isCmd Ð´Ð¾ Context, Ð½Ð¾ ÑÐ¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ Ð¿Ñ€Ð¸Ð·Ð½Ð°Ðº ÐºÐ¾Ð¼Ð°Ð½Ð´Ð½Ð¾Ð³Ð¾ Ñ†Ð¸ÐºÐ»Ð°
      return replyStop("ðŸ“‹ Recap will be generated.");
    }
    if (cmd === "/Ð½ÐµÑ‚")  {
      if (!(typeof LC !== 'undefined' && L.currentAction && L.currentAction.wantRecap)) {
        return replyStop('â„¹ï¸ ÐÐµÑ‚ Ð°ÐºÑ‚Ð¸Ð²Ð½Ð¾Ð³Ð¾ Ð¾Ñ„Ñ„ÐµÑ€Ð° Ñ€ÐµÐºÐ°Ð¿Ð°.');
      }
      delete L.currentAction.wantRecap;
      L.recapMuteUntil = L.turn + 5;
      return replyStop("ðŸš« Recap postponed for 5 turns.");
    }
    if (cmd === "/Ð¿Ð¾Ð·Ð¶Ðµ"){
      if (!(typeof LC !== 'undefined' && L.currentAction && L.currentAction.wantRecap)) {
        return replyStop('â„¹ï¸ ÐÐµÑ‚ Ð°ÐºÑ‚Ð¸Ð²Ð½Ð¾Ð³Ð¾ Ð¾Ñ„Ñ„ÐµÑ€Ð° Ñ€ÐµÐºÐ°Ð¿Ð°.');
      }
      delete L.currentAction.wantRecap;
      L.recapMuteUntil = L.turn + 3; 
      if (L.tm) L.tm.wantRecapTurn = 0;
      return replyStop("ðŸ•‘ Recap later (3 turns).");
    }

    // Try CommandsRegistry
    const registryDef = LC.CommandsRegistry?.get?.(cmd);
    if (registryDef && typeof registryDef.handler === "function") {
      try {
        const res = registryDef.handler(args, cmdRaw);
        return res;
      } catch (e) {
        return replyStop(`Command failed: ${e?.message || e}`);
      }
    }

    return replyStop("Unknown command. Use /help.");
  }

  // ÐÐµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð° â€” Intent
  const _isCont = L.currentAction?.type === 'continue';
const _isRet  = L.currentAction?.type === 'retry';
if (!_isCont && !_isRet && userText && userText.length > 0) L.lastIntent = userText.slice(0, 300);
  return { text: String(userText || "") };
};
return modifier(text);