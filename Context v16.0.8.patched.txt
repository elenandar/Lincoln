/*
Module: Context — Lincoln v16.0.9-hardened
Contract:
- Reads flags: ...
- Writes flags: ...
- Entry points: ...
- Invariants:
  - Turn +1 on story input and the UI Continue button.
  - Turn +0 on slash commands (including `/continue`) and retries.
  - Context overlay falls back to upstream text when empty or on error.
  - **NEW:** Actively sanitizes context on retries and continues to prevent data leaks.
*/
// === CONTEXT MODIFIER v16.0.9-hardened ===
const __SCRIPT_SLOT__ = "Context";
if (typeof LC !== "undefined") LC.DATA_VERSION = "16.0.9-hardened";

const modifier = function (text) {
  if (typeof LC === "undefined") return { text: String(text || "") };

  const L = LC.lcInit(__SCRIPT_SLOT__);
  LC.DATA_VERSION = "16.0.9-hardened";

  const isRetry = L.currentAction?.type === 'retry';
  const isContinue = L.currentAction?.type === 'continue';

  // --- HARDENING PROTOCOL ---
  // Если это Retry или Continue, мы не можем доверять входящему 'text'.
  // Он может содержать "грязные" данные или быть результатом нажатия UI кнопки,
  // которая обходит наш Output.js. Мы должны принудительно пересобрать контекст с нуля.
  if ((isRetry || isContinue) && L.turn > 0) {
    try {
      const limit = (LC.CONFIG && LC.CONFIG.LIMITS && LC.CONFIG.LIMITS.CONTEXT_LENGTH) || 800;
      const built = LC.composeContextOverlay?.({ limit, allowPartial: false }); // allowPartial: false для полной сборки
      const overlay = (built && typeof built.text === "string") ? built.text.trim() : "";
      
      if (overlay) {
        // Успешная пересборка. Возвращаем чистый, полный контекст.
        return { text: overlay };
      } else {
        // Пересборка не удалась, возвращаем пустую строку, чтобы предотвратить утечку "грязного" text.
        LC.lcWarn?.("CTX-HARDEN: Forced rebuild resulted in an empty overlay. Blanking context.");
        return { text: "" };
      }
    } catch (e) {
      LC.lcWarn?.("CTX-HARDEN: Forced context rebuild failed: " + (e && e.message));
      // В случае критической ошибки, лучше обнулить контекст, чем допустить утечку.
      return { text: "" };
    }
  }
  // --- END HARDENING PROTOCOL ---

  const isCmd = L.currentAction?.type === 'command';
  const wantsRecap = L.currentAction?.task === 'recap';
  const wantsEpoch = L.currentAction?.task === 'epoch';

  if (isCmd && !wantsRecap && !wantsEpoch) {
    return { text: String(text || "") };
  }

  const limit = (LC.CONFIG && LC.CONFIG.LIMITS && LC.CONFIG.LIMITS.CONTEXT_LENGTH) || 800;
  
  function safeSlice(str, maxLength) {
    if (str.length <= maxLength) return str;
    const charCode = str.charCodeAt(maxLength - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      return str.slice(0, maxLength - 1);
    }
    return str.slice(0, maxLength);
  }
  
  let overlay = "";
  try {
    const built = LC.composeContextOverlay?.({ limit, allowPartial: true });
    const raw = (built && typeof built.text === "string") ? built.text : String(built || "");
    overlay = raw && raw.trim().length ? raw : "";
    if (!overlay) throw new Error("empty overlay");
  } catch (e) {
    LC.lcWarn?.("CTX: overlay build failed or empty: " + (e && e.message));
    // SAFE FALLBACK: preserve upstream context instead of blanking it
    return { text: String(text || "") };
  }
  const overlayLimited = safeSlice(overlay, limit);

  return { text: overlayLimited };
};
return modifier(text);
