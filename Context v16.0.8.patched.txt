/*
Module: Context — Lincoln v16.0.8-compat6d
Contract:
- Reads flags: ...
- Writes flags: ...
- Entry points: ...
- Invariants:
  - Turn +1 on story input and the UI Continue button.
  - Turn +0 on slash commands (including `/continue`) and retries.
  - `/continue` slash command accepts recap/epoch drafts (not the UI button).
  - Context overlay falls back to upstream text when empty or on error.
- Config: LIMITS.*, CHAR_WINDOW_*, FEATURES.*, OUTPUT_BUDGET_MS (optional)
*/
// === CONTEXT MODIFIER v16.0.8-compat6d ===
const __SCRIPT_SLOT__ = "Context";
if (typeof LC !== "undefined") LC.DATA_VERSION = "16.0.8-compat6d";

const modifier = function (text) {
  
  if (typeof LC === "undefined") return { text: String(text || "") };

  const L = LC.lcInit(__SCRIPT_SLOT__);
  const RETRY_KEEP_CONTEXT = (L.currentAction?.RETRY_KEEP_CONTEXT === true);
  LC.DATA_VERSION = "16.0.8-compat6d";

  const isRetry = L.currentAction?.type === 'retry';
  if (isRetry && !RETRY_KEEP_CONTEXT) return { text: String(text || "") };

  const isCmd = L.currentAction?.type === 'command';
  const wantsRecap = L.currentAction?.task === 'recap';
  const wantsEpoch = L.currentAction?.task === 'epoch';

  // Если это чистая команда (нет задач на драфты) — не трать бюджет на сборку оверлея
  if (isCmd && !wantsRecap && !wantsEpoch) {
    return { text: String(text || "") };
  }

  const limit = (LC.CONFIG && LC.CONFIG.LIMITS && LC.CONFIG.LIMITS.CONTEXT_LENGTH) || 800;
  
  // Helper function to safely slice strings without breaking surrogate pairs
  function safeSlice(str, maxLength) {
    if (str.length <= maxLength) return str;
    // Check if we're cutting in the middle of a surrogate pair
    const charCode = str.charCodeAt(maxLength - 1);
    // High surrogate range: 0xD800-0xDBFF
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      // We're at a high surrogate, cut one character earlier to avoid breaking the pair
      return str.slice(0, maxLength - 1);
    }
    return str.slice(0, maxLength);
  }
  
  // CTX: build overlay with safe fallback to upstream text
  let overlay = "";
  try {
    const built = LC.composeContextOverlay?.({ limit, allowPartial: true });
    const raw = (built && typeof built.text === "string") ? built.text : String(built || "");
    overlay = raw && raw.trim().length ? raw : "";
    if (!overlay) throw new Error("empty overlay");
  } catch (e) {
    LC.lcWarn?.("CTX: overlay build failed or empty: " + (e && e.message));
    // SAFE FALLBACK: preserve upstream context instead of blanking it
    return { text: String(text || "") };
  }
  const overlayLimited = safeSlice(overlay, limit);

  return { text: overlayLimited };
};
return modifier(text);
