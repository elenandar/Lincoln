/*
Module: Library â€” Lincoln v17.0.0-phase1
Contract:
- Phase 1: Infrastructure Layer Implementation
- Full state.lincoln structure with versioning
- Utilities: LC.Tools, LC.Utils
- Infrastructure: LC.Flags, LC.Drafts, LC.Turns
- Enhanced CommandsRegistry with metadata
- Commands: /help, /debug, /turn, /action, /test-phase1
*/

// === LIBRARY v17.0.0-phase1 ===

// Initialize global LC object if it doesn't exist
if (typeof LC === "undefined") {
  var LC = {};
}

// Version tracking
LC.DATA_VERSION = "17.0.0-phase1";

// ===== LC.TOOLS (#19): SAFETY UTILITIES =====
LC.Tools = {
  /**
   * Safe regex matching with error handling
   * @param {string} text - Text to match against
   * @param {RegExp} pattern - Regex pattern
   * @returns {Array|null} - Match result or null
   */
  safeRegexMatch: function(text, pattern) {
    try {
      if (!text || typeof text !== 'string') return null;
      return text.match(pattern);
    } catch (e) {
      console.log("Regex error:", e);
      return null;
    }
  },
  
  /**
   * Escape special regex characters
   * @param {string} str - String to escape
   * @returns {string} - Escaped string
   */
  escapeRegex: function(str) {
    if (!str || typeof str !== 'string') return '';
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  },
  
  /**
   * Truncate string to max length
   * @param {string} str - String to truncate
   * @param {number} maxLen - Maximum length
   * @param {string} suffix - Optional suffix (default: "...")
   * @returns {string} - Truncated string
   */
  truncate: function(str, maxLen, suffix) {
    if (!str || typeof str !== 'string') return '';
    suffix = suffix || '...';
    maxLen = maxLen || 100;
    if (str.length <= maxLen) return str;
    return str.substring(0, maxLen - suffix.length) + suffix;
  },
  
  /**
   * Safe string extraction with fallback
   * @param {*} value - Value to extract string from
   * @param {string} fallback - Fallback value
   * @returns {string} - Extracted string or fallback
   */
  safeString: function(value, fallback) {
    fallback = fallback || '';
    if (value === null || value === undefined) return fallback;
    return String(value);
  }
};

// ===== LC.UTILS (#20): TYPE CONVERSION UTILITIES =====
LC.Utils = {
  /**
   * Convert to number with fallback
   * @param {*} value - Value to convert
   * @param {number} fallback - Fallback value (default: 0)
   * @returns {number} - Converted number
   */
  toNum: function(value, fallback) {
    fallback = (typeof fallback === 'number') ? fallback : 0;
    var num = parseFloat(value);
    return isNaN(num) ? fallback : num;
  },
  
  /**
   * Convert to string
   * @param {*} value - Value to convert
   * @param {string} fallback - Fallback value (default: "")
   * @returns {string} - Converted string
   */
  toStr: function(value, fallback) {
    fallback = fallback || '';
    if (value === null || value === undefined) return fallback;
    return String(value);
  },
  
  /**
   * Convert to boolean
   * @param {*} value - Value to convert
   * @returns {boolean} - Converted boolean
   */
  toBool: function(value) {
    if (typeof value === 'boolean') return value;
    if (typeof value === 'string') {
      var lower = value.toLowerCase();
      return lower === 'true' || lower === '1' || lower === 'yes';
    }
    return Boolean(value);
  },
  
  /**
   * Clamp number to range
   * @param {number} value - Value to clamp
   * @param {number} min - Minimum value
   * @param {number} max - Maximum value
   * @returns {number} - Clamped value
   */
  clamp: function(value, min, max) {
    return Math.max(min, Math.min(max, value));
  },
  
  /**
   * Deep clone object (ES5-compatible)
   * @param {*} obj - Object to clone
   * @returns {*} - Cloned object
   */
  clone: function(obj) {
    if (obj === null || typeof obj !== 'object') return obj;
    if (obj instanceof Array) {
      var arrCopy = [];
      for (var i = 0; i < obj.length; i++) {
        arrCopy[i] = this.clone(obj[i]);
      }
      return arrCopy;
    }
    if (obj instanceof Object) {
      var objCopy = {};
      for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
          objCopy[key] = this.clone(obj[key]);
        }
      }
      return objCopy;
    }
    return obj;
  }
};

// ===== LC.TURNS (#23): TURN COUNTER =====
LC.Turns = {
  /**
   * Get current turn number
   * @returns {number} - Current turn
   */
  get: function() {
    if (!state.lincoln) return 0;
    return state.lincoln.turn || 0;
  },
  
  /**
   * Increment turn counter
   * @returns {number} - New turn number
   */
  increment: function() {
    if (!state.lincoln) return 0;
    state.lincoln.turn = (state.lincoln.turn || 0) + 1;
    state.lincoln.stateVersion++;
    return state.lincoln.turn;
  },
  
  /**
   * Set turn number (for testing/debugging)
   * @param {number} value - Turn number to set
   * @returns {number} - New turn number
   */
  set: function(value) {
    if (!state.lincoln) return 0;
    state.lincoln.turn = LC.Utils.toNum(value, 0);
    state.lincoln.stateVersion++;
    return state.lincoln.turn;
  }
};

// ===== LC.DRAFTS (#22): MESSAGE QUEUE SYSTEM =====
LC.Drafts = {
  /**
   * Add message to output queue
   * @param {string} message - Message to queue
   */
  add: function(message) {
    if (!state.lincoln || !message) return;
    if (!state.lincoln.drafts) state.lincoln.drafts = [];
    state.lincoln.drafts.push(LC.Utils.toStr(message));
    state.lincoln.stateVersion++;
  },
  
  /**
   * Get all queued messages
   * @returns {Array} - Array of messages
   */
  getAll: function() {
    if (!state.lincoln || !state.lincoln.drafts) return [];
    return state.lincoln.drafts;
  },
  
  /**
   * Clear all messages
   */
  clear: function() {
    if (!state.lincoln) return;
    state.lincoln.drafts = [];
    state.lincoln.stateVersion++;
  },
  
  /**
   * Flush messages to single string
   * @param {string} separator - Separator between messages (default: "\n")
   * @returns {string} - Concatenated messages
   */
  flush: function(separator) {
    if (!state.lincoln) return '';
    var messages = this.getAll();
    this.clear();
    return messages.join(separator || '\n');
  }
};

// ===== CURRENT ACTION TRACKER (#34) =====
var currentAction = (function() {
  var _actionType = null;  // Private variable
  
  return {
    /**
     * Set current action type
     * @param {string} type - Action type: "do", "say", or "story"
     */
    set: function(type) {
      if (type === 'do' || type === 'say' || type === 'story') {
        _actionType = type;
        if (state.lincoln) {
          state.lincoln.currentAction = type;
          state.lincoln.stateVersion++;
        }
      }
    },
    
    /**
     * Get current action type
     * @returns {string|null} - Current action type or null
     */
    get: function() {
      // Try state first, then fallback to private variable
      if (state.lincoln && state.lincoln.currentAction) {
        return state.lincoln.currentAction;
      }
      return _actionType;
    },
    
    /**
     * Detect action type from input text
     * @param {string} text - Input text to analyze
     * @returns {string} - Detected action type
     */
    detect: function(text) {
      if (!text || typeof text !== 'string') return 'story';
      var trimmed = text.trim().toLowerCase();
      
      // Check for "you say" pattern first (before general "you" check)
      if (trimmed.indexOf('you say') === 0 || trimmed.indexOf('"') === 0) {
        this.set('say');
        return 'say';
      }
      
      // Check for "you do" pattern
      if (trimmed.indexOf('you ') === 0) {
        this.set('do');
        return 'do';
      }
      
      // Default to story
      this.set('story');
      return 'story';
    },
    
    /**
     * Clear action type
     */
    clear: function() {
      _actionType = null;
      if (state.lincoln) {
        state.lincoln.currentAction = null;
        state.lincoln.stateVersion++;
      }
    }
  };
})();

// Expose currentAction globally
LC.currentAction = currentAction;

// ===== LC.FLAGS (#21): COMPATIBILITY FACADE =====
LC.Flags = {
  /**
   * Check if current action is "do"
   * @returns {boolean}
   */
  isDo: function() {
    return currentAction.get() === 'do';
  },
  
  /**
   * Check if current action is "say"
   * @returns {boolean}
   */
  isSay: function() {
    return currentAction.get() === 'say';
  },
  
  /**
   * Check if current action is "story"
   * @returns {boolean}
   */
  isStory: function() {
    return currentAction.get() === 'story';
  },
  
  /**
   * Get action type as string
   * @returns {string}
   */
  getActionType: function() {
    return currentAction.get() || 'story';
  }
};

// ===== LC.INIT (#33): FULL STATE INITIALIZATION =====
LC.lcInit = function(scriptSlot) {
  var slot = String(scriptSlot || "unknown");
  
  // Initialize state.lincoln if it doesn't exist or version is outdated
  if (!state.lincoln || state.lincoln.version !== "17.0.0") {
    state.lincoln = {
      // Core metadata
      version: "17.0.0",
      stateVersion: 0,
      turn: 0,
      currentAction: null,
      initialized: true,
      
      // Message queue
      drafts: [],
      
      // Characters data (for future phases)
      characters: {},
      
      // Social structures (for future phases)
      relations: {},
      hierarchy: {},
      rumors: [],
      
      // Cultural memory (for future phases)
      lore: [],
      myths: [],
      
      // World state (for future phases)
      time: {},
      environment: {},
      
      // Knowledge systems (for future phases)
      evergreen: [],
      secrets: []
    };
  }
  
  // Return script-specific context
  return {
    turn: state.lincoln.turn,
    slot: slot,
    version: state.lincoln.version,
    stateVersion: state.lincoln.stateVersion
  };
};

// ===== COMMANDS REGISTRY (#24): ENHANCED COMMAND SYSTEM =====
if (typeof LC.Commands === "undefined") {
  LC.Commands = {
    _registry: {},
    
    set: function(cmdName, definition) {
      this._registry[cmdName] = definition;
    },
    
    get: function(cmdName) {
      return this._registry[cmdName];
    },
    
    has: function(cmdName) {
      return this._registry.hasOwnProperty(cmdName);
    },
    
    execute: function(cmdName, args) {
      var cmd = this.get(cmdName);
      if (!cmd || typeof cmd.handler !== "function") {
        return "âŸ¦SYSâŸ§ Unknown command: " + cmdName;
      }
      try {
        return cmd.handler(args);
      } catch (e) {
        return "âŸ¦SYSâŸ§ Command error: " + String(e && e.message || e || "Unknown error");
      }
    },
    
    list: function() {
      var commands = [];
      for (var cmdName in this._registry) {
        if (this._registry.hasOwnProperty(cmdName)) {
          commands.push(cmdName);
        }
      }
      return commands.sort();
    },
    
    getMetadata: function(cmdName) {
      var cmd = this.get(cmdName);
      if (!cmd) return null;
      return {
        name: cmd.name || cmdName,
        description: cmd.description || "No description",
        usage: cmd.usage || null
      };
    }
  };
}

// ===== COMMAND DEFINITIONS =====

// /ping - Health check
LC.Commands.set("ping", {
  name: "ping",
  description: "Health check - verifies Lincoln v17 is running",
  usage: "/ping",
  handler: function(args) {
    return "âŸ¦SYSâŸ§ Pong! Lincoln v17.0.0-phase1 is active.";
  }
});

// /help - List all commands
LC.Commands.set("help", {
  name: "help",
  description: "List all available commands with descriptions",
  usage: "/help [command]",
  handler: function(args) {
    if (args && args.length > 0) {
      // Show help for specific command
      var cmdName = args[0].toLowerCase();
      var meta = LC.Commands.getMetadata(cmdName);
      if (!meta) {
        return "âŸ¦SYSâŸ§ Unknown command: " + cmdName;
      }
      var help = "âŸ¦SYSâŸ§ " + meta.name.toUpperCase() + "\n";
      help += "  " + meta.description;
      if (meta.usage) {
        help += "\n  Usage: " + meta.usage;
      }
      return help;
    }
    
    // List all commands
    var commands = LC.Commands.list();
    var help = "âŸ¦SYSâŸ§ AVAILABLE COMMANDS (" + commands.length + "):\n";
    for (var i = 0; i < commands.length; i++) {
      var meta = LC.Commands.getMetadata(commands[i]);
      help += "\n/" + commands[i];
      if (meta && meta.description) {
        help += " - " + meta.description;
      }
    }
    help += "\n\nType /help [command] for detailed usage.";
    return help;
  }
});

// /debug - System and state info
LC.Commands.set("debug", {
  name: "debug",
  description: "Display system and state information",
  usage: "/debug",
  handler: function(args) {
    if (!state.lincoln) {
      return "âŸ¦SYSâŸ§ ERROR: state.lincoln not initialized!";
    }
    
    var info = "âŸ¦SYSâŸ§ LINCOLN DEBUG INFO\n";
    info += "  Version: " + (state.lincoln.version || "unknown") + "\n";
    info += "  Data Version: " + LC.DATA_VERSION + "\n";
    info += "  Turn: " + state.lincoln.turn + "\n";
    info += "  State Version: " + state.lincoln.stateVersion + "\n";
    info += "  Current Action: " + (state.lincoln.currentAction || "none") + "\n";
    info += "  Drafts Queue: " + (state.lincoln.drafts ? state.lincoln.drafts.length : 0) + " messages\n";
    info += "  Characters: " + Object.keys(state.lincoln.characters || {}).length + "\n";
    info += "  Initialized: " + (state.lincoln.initialized ? "Yes" : "No");
    
    return info;
  }
});

// /turn - Display current turn
LC.Commands.set("turn", {
  name: "turn",
  description: "Display or set current turn number",
  usage: "/turn [set <number>]",
  handler: function(args) {
    if (args && args.length > 0 && args[0].toLowerCase() === 'set') {
      var newTurn = LC.Utils.toNum(args[1], 0);
      LC.Turns.set(newTurn);
      return "âŸ¦SYSâŸ§ Turn set to: " + newTurn;
    }
    
    var turn = LC.Turns.get();
    return "âŸ¦SYSâŸ§ Current turn: " + turn;
  }
});

// /action - Display current action type
LC.Commands.set("action", {
  name: "action",
  description: "Display current action type (do/say/story)",
  usage: "/action",
  handler: function(args) {
    var actionType = currentAction.get() || "none";
    var flags = "isDo: " + LC.Flags.isDo() + ", isSay: " + LC.Flags.isSay() + ", isStory: " + LC.Flags.isStory();
    return "âŸ¦SYSâŸ§ Current action: " + actionType + "\n  Flags: " + flags;
  }
});

// /test-phase1 - Run Phase 1 infrastructure tests
LC.Commands.set("test-phase1", {
  name: "test-phase1",
  description: "Run basic infrastructure tests for Phase 1",
  usage: "/test-phase1",
  handler: function(args) {
    var results = "âŸ¦SYSâŸ§ PHASE 1 INFRASTRUCTURE TESTS\n";
    var passed = 0;
    var failed = 0;
    
    // Test 1: State initialization
    if (state.lincoln && state.lincoln.version === "17.0.0") {
      results += "  âœ“ State initialization\n";
      passed++;
    } else {
      results += "  âœ— State initialization FAILED\n";
      failed++;
    }
    
    // Test 2: LC.Tools
    if (typeof LC.Tools === 'object' && typeof LC.Tools.safeRegexMatch === 'function') {
      results += "  âœ“ LC.Tools available\n";
      passed++;
    } else {
      results += "  âœ— LC.Tools FAILED\n";
      failed++;
    }
    
    // Test 3: LC.Utils
    if (typeof LC.Utils === 'object' && typeof LC.Utils.toNum === 'function') {
      results += "  âœ“ LC.Utils available\n";
      passed++;
    } else {
      results += "  âœ— LC.Utils FAILED\n";
      failed++;
    }
    
    // Test 4: LC.Turns
    if (typeof LC.Turns === 'object' && typeof LC.Turns.get === 'function') {
      results += "  âœ“ LC.Turns available\n";
      passed++;
    } else {
      results += "  âœ— LC.Turns FAILED\n";
      failed++;
    }
    
    // Test 5: LC.Drafts
    if (typeof LC.Drafts === 'object' && typeof LC.Drafts.add === 'function') {
      results += "  âœ“ LC.Drafts available\n";
      passed++;
    } else {
      results += "  âœ— LC.Drafts FAILED\n";
      failed++;
    }
    
    // Test 6: currentAction
    if (typeof LC.currentAction === 'object' && typeof LC.currentAction.get === 'function') {
      results += "  âœ“ currentAction tracker available\n";
      passed++;
    } else {
      results += "  âœ— currentAction tracker FAILED\n";
      failed++;
    }
    
    // Test 7: LC.Flags
    if (typeof LC.Flags === 'object' && typeof LC.Flags.isDo === 'function') {
      results += "  âœ“ LC.Flags available\n";
      passed++;
    } else {
      results += "  âœ— LC.Flags FAILED\n";
      failed++;
    }
    
    // Test 8: Commands registry
    var cmdCount = LC.Commands.list().length;
    if (cmdCount >= 6) {
      results += "  âœ“ Commands registry (" + cmdCount + " commands)\n";
      passed++;
    } else {
      results += "  âœ— Commands registry FAILED (expected â‰¥6, got " + cmdCount + ")\n";
      failed++;
    }
    
    // Summary
    results += "\n  Total: " + (passed + failed) + " | Passed: " + passed + " | Failed: " + failed;
    if (failed === 0) {
      results += "\n  âœ“ ALL TESTS PASSED!";
    } else {
      results += "\n  âœ— SOME TESTS FAILED";
    }
    
    return results;
  }
});

// No modifier needed for Library.txt - it executes directly
// Library runs 3x per turn: before Input, Context, and Output hooks
