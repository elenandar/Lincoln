/*
Module: Output ‚Äî Lincoln v16.0.8-compat6d
Contract:
- Reads flags: ...
- Writes flags: ...
- Entry points: ...
- Invariants: recap/epoch reset only on non-command path; retry baseline preserved; command bypass on marked handlers.
- Config: LIMITS.*, CHAR_WINDOW_*, FEATURES.*, OUTPUT_BUDGET_MS (optional)
*/
// === OUTPUT MODIFIER v16.0.8-compat6d ===
const __SCRIPT_SLOT__ = "Output";
if (typeof LC !== "undefined") LC.DATA_VERSION = "16.0.8-compat6d";

function omBudget(start, maxMs = 3500) {
  const dt = Date.now() - start;
  return { over: dt > maxMs, dt };
}
const modifier = function (text) {
  const t0 = Date.now();
  if (typeof LC === "undefined") return { text: String(text || "") };
  LC.DATA_VERSION = "16.0.8-compat6d";
  const L = LC.lcInit(__SCRIPT_SLOT__);
  let out = String(text || "").trim();
  const clean = LC.lcStripSys(out);


  const isCmd = LC.lcGetFlag("isCmd", false);
  const isRetry = LC.lcGetFlag("isRetry", false);
  const wantsRecap = LC.lcGetFlag("doRecap", false);
  const wantsEpoch = LC.lcGetFlag("doEpoch", false);

  // Opening ‚Äî –ø–µ—Ä–≤–∏—á–Ω—ã–π –∑–∞—Ö–≤–∞—Ç
  if (L.turn === 0 && !L.openingCaptured && !isRetry && clean.length > 20) {
    LC.captureOpeningFromOutput(clean);
  }

  // –ö–æ–º–∞–Ω–¥–Ω—ã–π –æ—Ç–≤–µ—Ç: –æ–±—Ä–∞–±–æ—Ç–∫–∞ /continue ‚Üí SYS
  if (isCmd) {
    const msgs = LC.lcConsumeMsgs?.() || [];
    return { text: (msgs.length ? msgs.join("\n") + "\n" + "=".repeat(40) + "\n" : (LC.CONFIG.CMD_PLACEHOLDER || "‚ü¶SYS‚üß OK.") + "\n") };
  }

  if (wantsRecap) LC.lcSetFlag("doRecap", false);
  if (wantsEpoch) LC.lcSetFlag("doEpoch", false);

  // –ò–Ω–∫—Ä–µ–º–µ–Ω—Ç —Ö–æ–¥–∞ –Ω–∞ —Ä–µ–∞–ª—å–Ω–æ–º –¥–µ–π—Å—Ç–≤–∏–∏
  if (!isRetry && LC.shouldIncrementTurn()) {
    LC.incrementTurn();
  }
  L.lastOutput = clean;

  // Anti-echo
  const actionType = L.lastActionType || "";
  let filtered = clean;
  if (!isRetry) {
    filtered = LC.applyAntiEcho(clean, L.prevOutput, actionType);
    // Only update the anti-echo baseline when not retrying.
    L.prevOutput = filtered;
  }
  out = filtered;

  // –ß–µ—Ä–Ω–æ–≤–∏–∫–∏ (Recap/Epoch)
  const draftSource = out;
  if (wantsRecap) {
    if (draftSource.length > 50) {
      L.recapDraft = { text: draftSource, turn: L.turn, window: [Math.max(0, L.turn - L.cadence), L.turn] };
      L.tm.recaps = (L.tm.recaps || 0) + 1;
      L.tm.recapTurns = Array.isArray(L.tm.recapTurns) ? L.tm.recapTurns : [];
      L.tm.recapTurns.push(L.turn);
      const win = LC.CONFIG.RECAP_V2.AUTO_EPOCH_WINDOW;
      L.tm.recapTurns = L.tm.recapTurns.filter(t0 => (L.turn - t0) <= (win*2));
      LC.lcSys("üìã Recap draft created. Use /continue to save.");
    } else LC.lcSys("‚ùå Recap too short.");
  }
  if (wantsEpoch) {
    if (draftSource.length > 60) {
      L.epochDraft = { text: draftSource, turn: L.turn, window: [L.lastEpochTurn || 0, L.turn] };
      L.tm.epochs = (L.tm.epochs || 0) + 1;
      LC.lcSys("üóø Epoch draft created. Use /continue to save.");
    } else LC.lcSys("‚ùå Epoch too short.");
  }

  // –ü–æ—Å—Ç-–∞–Ω–∞–ª–∏–∑ (–Ω–∞ —Ä–µ–∞–ª—å–Ω–æ–º —Ö–æ–¥–µ)
  if (!isRetry) {
    try {
      LC.updateCharacterActivity(out, false);
    } catch (e) {
      LC.lcWarn("Post-analyze updateCharacterActivity error: " + (e && e.message));
    }
    try {
      LC.analyzeTextForEvents(out, "output");
    } catch (e) {
      LC.lcWarn("Post-analyze analyzeTextForEvents error: " + (e && e.message));
    }
    const autoEvergreen = LC.autoEvergreen;
    if (autoEvergreen?.analyze) {
      try {
        autoEvergreen.analyze(out, actionType);
      } catch (e) {
        LC.lcWarn("Post-analyze autoEvergreen error: " + (e && e.message));
      }
    }
  }

  // –ê–≤—Ç–æ-–æ—Ñ—Ñ–µ—Ä recap –∏ –∞–≤—Ç–æ-epoch
  if (!isRetry) {
    try { LC.checkRecapOfferV2(); } catch(e){ LC.lcWarn("RecapOfferV2 error: " + (e && e.message)); }
    try { LC.checkAutoEpoch(); }   catch(e){ LC.lcWarn("AutoEpoch error: " + (e && e.message)); }
  }

  // SYS: –í–°–ï–ì–î–ê consume; –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ sysShow=true –∏ —ç—Ç–æ –Ω–µ retry
  const budget = omBudget(t0, LC.CONFIG?.LIMITS?.OUTPUT_BUDGET_MS ?? 3500);
  if (budget.over) LC.lcWarn?.(`Output budget exceeded: ${budget.dt}ms`);
  const notices = LC.consumeNotices?.() || "";
  const msgs = LC.lcConsumeMsgs?.() || [];
  let final = out;
  if (msgs.length) final = msgs.join("\n") + "\n" + "=".repeat(40) + "\n" + final;
  if (notices) final = notices + "\n\n" + final;
  return { text: final };
};
return modifier(text);
