/*
Module: Output ‚Äî Lincoln v16.0.8-compat6d
Contract:
- Reads flags: ...
- Writes flags: ...
- Entry points: ...
- Invariants:
  - Turn +1 on story input and the UI Continue button.
  - Turn +0 on slash commands (including `/continue`) and retries.
  - `/continue` slash command accepts recap/epoch drafts (not the UI button).
  - Context overlay falls back to upstream text when empty or on error.
- Config: LIMITS.*, CHAR_WINDOW_*, FEATURES.*, OUTPUT_BUDGET_MS (optional)
*/
// === OUTPUT MODIFIER v16.0.8-compat6d ===
const __SCRIPT_SLOT__ = "Output";
if (typeof LC !== "undefined") LC.DATA_VERSION = "16.0.8-compat6d";

/**
 * Checks if the output processing time has exceeded the budget.
 * @param {number} start - Start timestamp
 * @param {number} [maxMs=3500] - Maximum allowed milliseconds
 * @returns {{over: boolean, dt: number}} Object with over flag and elapsed time
 */
function omBudget(start, maxMs = 3500) {
  const dt = Date.now() - start;
  return { over: dt > maxMs, dt };
}
const modifier = function (text) {
  const t0 = Date.now();
  if (typeof LC === "undefined") return { text: String(text || "") };
  LC.DATA_VERSION = "16.0.8-compat6d";
  const L = LC.lcInit(__SCRIPT_SLOT__);
  let out = String(text || "").trim();
  const clean = LC.lcStripSys(out);

  const CMD_SYS_PREFIX = "\u2063\u2063";
  const CMD_SYS_META_SEP = "\u2062";
  const CMD_CYCLE_FLAG = "__cmdCyclePending";

/**
 * Decodes command system messages that were stamped in Input.
 * @param {string} raw - The raw message text
 * @returns {object|null} Decoded message object or null if not a command SYS message
 */
  function decodeCommandSys(raw) {
    if (typeof raw !== "string") return null;
    const SYS_PREFIX = "‚ü¶SYS‚üß";
    let source = raw;
    if (source.startsWith(SYS_PREFIX)) {
      const trimmed = source.slice(SYS_PREFIX.length).trimStart();
      source = trimmed.length ? trimmed : source;
    }
    if (!source.startsWith(CMD_SYS_PREFIX)) return null;
    const metaEnd = source.indexOf(CMD_SYS_META_SEP, CMD_SYS_PREFIX.length);
    if (metaEnd <= CMD_SYS_PREFIX.length) return null;
    const meta = source.slice(CMD_SYS_PREFIX.length, metaEnd);
    const text = source.slice(metaEnd + CMD_SYS_META_SEP.length);
    const [turnStr, seqStr] = meta.split(":");
    const turn = Number.parseInt(turnStr, 10);
    const seq = Number.parseInt(seqStr, 10);
    if (!Number.isFinite(turn) || !Number.isFinite(seq)) {
      return { text };
    }
    return { text, turn, seq };
  }


  const isCmd = L.currentAction?.type === 'command';
  const cmdCyclePending = L.currentAction?.__cmdCyclePending || false;
  const isRetry = L.currentAction?.type === 'retry';
  const wantsRecap = L.currentAction?.task === 'recap';
  const wantsEpoch = L.currentAction?.task === 'epoch';
  // Derive lastActionType for analysis
  const lastActionType =
    (L && L.lastActionType) ||
    (isRetry ? "retry"
             : (L.currentAction?.type === 'continue' ? "continue"
                : (L.currentAction?.type === 'command' ? "command" : "story")));
  const isCommandAction = lastActionType === "command" || cmdCyclePending || isCmd;

  if (L.currentAction?.type === 'command' && (L.currentAction?.task === 'recap' || L.currentAction?.task === 'epoch')) {
    LC.lcWarn?.("Command+TASK collision: check /–¥–∞ handler clears isCmd before Context.");
  }

  // Opening ‚Äî –ø–µ—Ä–≤–∏—á–Ω—ã–π –∑–∞—Ö–≤–∞—Ç
  if (L.turn === 0 && !L.openingCaptured && !isRetry && clean.length > 20) {
    LC.captureOpeningFromOutput(clean);
  }

  // –ö–æ–º–∞–Ω–¥–Ω—ã–π –æ—Ç–≤–µ—Ç: –æ–±—Ä–∞–±–æ—Ç–∫–∞ /continue ‚Üí SYS
  if (isCmd || cmdCyclePending) {
    const msgs = LC.lcConsumeMsgs?.() || [];
    try { 
      if (L.currentAction) delete L.currentAction.__cmdCyclePending;
    } catch (_) {}
    LC.Flags?.clearCmd?.(); // —Å—Ç—Ä–∞—Ö–æ–≤–æ—á–Ω—ã–π —Å–±—Ä–æ—Å, —á—Ç–æ–±—ã –Ω–µ ¬´–∑–∞–ª–∏–ø–Ω—É—Ç—å¬ª –≤ –∫–æ–º–∞–Ω–¥–Ω–æ–º —Ä–µ–∂–∏–º–µ
    if (!msgs.length) return { text: "" }; // –ö–æ–º–∞–Ω–¥–Ω—ã–π –æ—Ç–≤–µ—Ç —É–∂–µ –±—ã–ª –ø–æ–∫–∞–∑–∞–Ω –Ω–∞ Input-—Å—Ç–∞–¥–∏–∏ ‚Üí –º–æ–ª—á–∏–º

    const body = LC.sysBlock?.(msgs) || (msgs.join("\n") + "\n");
    // –û—á–µ—Ä–µ–¥—å –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø—É—Å—Ç–æ–π –ø–æ—Å–ª–µ –≤—ã–≤–æ–¥–∞
    try {
      const left = LC.lcConsumeMsgs?.() || [];
      if (left.length) LC.lcWarn?.("SYS queue not empty after command cycle, purged " + left.length);
    } catch(_) {}
    return { text: body };
  }

  if (wantsRecap && L.currentAction) delete L.currentAction.task;
  if (wantsEpoch && L.currentAction) delete L.currentAction.task;

  LC.assertTurnInvariants?.(L, "output:pre-inc");
  // –ò–Ω–∫—Ä–µ–º–µ–Ω—Ç —Ö–æ–¥–∞ –Ω–∞ —Ä–µ–∞–ª—å–Ω–æ–º –¥–µ–π—Å—Ç–≤–∏–∏
  if (!isRetry && L.currentAction?.type !== 'command' && LC.shouldIncrementTurn()) {
    LC.incrementTurn();
  }
  L.lastOutput = clean;

  // Anti-echo
  let filtered = clean;
  if (!isRetry) {
    filtered = LC.applyAntiEcho(clean, L.prevOutput, lastActionType);
    // Only update the anti-echo baseline when not retrying.
    L.prevOutput = filtered;
  }
  out = filtered;

  // –ß–µ—Ä–Ω–æ–≤–∏–∫–∏ (Recap/Epoch)
  const draftSource = out;
  if (wantsRecap) {
    if (draftSource.length > 50) {
      L.recapDraft = { text: draftSource, turn: L.turn, window: [Math.max(0, L.turn - L.cadence), L.turn] };
      L.tm.recaps = (L.tm.recaps || 0) + 1;
      L.tm.recapTurns = Array.isArray(L.tm.recapTurns) ? L.tm.recapTurns : [];
      L.tm.recapTurns.push(L.turn);
      const win = LC.CONFIG.RECAP_V2.AUTO_EPOCH_WINDOW;
      L.tm.recapTurns = L.tm.recapTurns.filter(t0 => (L.turn - t0) <= (win*2));
      LC.lcSys("üìã Recap draft created. Use /continue to save.");
    } else LC.lcSys("‚ùå Recap too short.");
  }
  if (wantsEpoch) {
    if (draftSource.length > 60) {
      L.epochDraft = { text: draftSource, turn: L.turn, window: [L.lastEpochTurn || 0, L.turn] };
      L.tm.epochs = (L.tm.epochs || 0) + 1;
      LC.lcSys("üóø Epoch draft created. Use /continue to save.");
    } else LC.lcSys("‚ùå Epoch too short.");
  }

  // –ü–æ—Å—Ç-–∞–Ω–∞–ª–∏–∑ (–Ω–∞ —Ä–µ–∞–ª—å–Ω–æ–º —Ö–æ–¥–µ)
  if (!isRetry) {
    try {
      LC.updateCharacterActivity(out, false);
    } catch (e) {
      LC.lcWarn("Post-analyze updateCharacterActivity error: " + (e && e.message));
    }
    try {
      LC.analyzeTextForEvents(out, "output");
    } catch (e) {
      LC.lcWarn("Post-analyze analyzeTextForEvents error: " + (e && e.message));
    }
    try {
      // Use UnifiedAnalyzer for optimized text analysis
      LC.UnifiedAnalyzer.analyze(out, lastActionType);
    } catch (e) {
      LC.lcWarn("Post-analyze UnifiedAnalyzer error: " + (e && e.message));
    }
    try {
      LC.TimeEngine.advance();
    } catch (e) {
      LC.lcWarn("Post-analyze TimeEngine error: " + (e && e.message));
    }
  }

  // –ê–≤—Ç–æ-–æ—Ñ—Ñ–µ—Ä recap –∏ –∞–≤—Ç–æ-epoch
  if (!isRetry) {
    try { LC.checkRecapOfferV2(); } catch(e){ LC.lcWarn("RecapOfferV2 error: " + (e && e.message)); }
    try { LC.checkAutoEpoch(); }   catch(e){ LC.lcWarn("AutoEpoch error: " + (e && e.message)); }
  }

  // SYS: –í–°–ï–ì–î–ê consume; –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ sysShow=true –∏ —ç—Ç–æ –Ω–µ retry
  const budget = omBudget(t0, LC.CONFIG?.LIMITS?.OUTPUT_BUDGET_MS ?? 3500);
  if (budget.over) LC.lcWarn?.(`Output budget exceeded: ${budget.dt}ms`);
  const notices = LC.consumeNotices?.() || "";
  let msgs = LC.lcConsumeMsgs?.() || [];
  if (msgs.length) {
    const filtered = [];
    let seenTurn = L._cmdSysSeen?.turn;
    let seenSeq = L._cmdSysSeen?.seq;
    let sawStamped = false;
    for (const msg of msgs) {
      // Extract text and level from message object (backward compatible with strings)
      const msgText = (msg && typeof msg === 'object') ? msg.text : msg;
      const msgLevel = (msg && typeof msg === 'object') ? msg.level : 'character';
      
      // Filter based on playerInfoLevel
      if (L.playerInfoLevel === 'character' && msgLevel === 'director') {
        continue; // Hide director-level messages in character mode
      }
      
      const decoded = decodeCommandSys(msgText);
      if (!decoded || decoded.turn == null || decoded.seq == null) {
        filtered.push(decoded ? decoded.text : msgText);
        continue;
      }
      sawStamped = true;
      const currentTurn = typeof decoded.turn === "number" ? decoded.turn : null;
      const currentSeq = typeof decoded.seq === "number" ? decoded.seq : null;
      const lastTurn = typeof seenTurn === "number" ? seenTurn : -Infinity;
      const lastSeq = typeof seenSeq === "number" ? seenSeq : -Infinity;
      const isStaleTurn = currentTurn < lastTurn;
      const isSameTurn = currentTurn === lastTurn;
      if (isStaleTurn || (isSameTurn && currentSeq <= lastSeq)) {
        continue;
      }
      if (!isSameTurn && currentTurn < (L.turn ?? -Infinity)) {
        continue;
      }
      if (!Number.isFinite(currentTurn) || !Number.isFinite(currentSeq)) {
        continue;
      }
      if (currentTurn > lastTurn || (isSameTurn && currentSeq > lastSeq)) {
        seenTurn = currentTurn;
        seenSeq = currentSeq;
      }
      // –∫–æ–º–∞–Ω–¥–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è —É–∂–µ –±—ã–ª–∏ –ø–æ–∫–∞–∑–∞–Ω—ã –Ω–∞–ø—Ä—è–º—É—é -> –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
    }
    if (sawStamped) {
      L._cmdSysSeen = { turn: seenTurn, seq: seenSeq };
    }
    msgs = filtered;
  }
  let final = out;
  if (L.sysShow && !isRetry) {
    if (msgs.length) final = msgs.join("\n") + "\n" + "=".repeat(40) + "\n" + final;
    if (notices) final = notices + "\n\n" + final;
  }
  return { text: final };
};
return modifier(text);
