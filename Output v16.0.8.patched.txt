// === OUTPUT MODIFIER v16.0.8-compat6d ===
function omBudget(start = Date.now(), ms = 280) { return () => { if (Date.now()-start > ms) throw new Error('OM_TIME_BUDGET'); }; } 
const modifier = function (text) {
  if (typeof LC === "undefined") return { text: String(text || "") };
  const L = LC.lcInit();
  const notices = [];
  const _notice = (L.visibleNotice || "").trim();
  if (_notice) {
    notices.push(_notice);
    L.visibleNotice = "";
  }


  let out = String(text || "").trim();
  const clean = LC.lcStripSys(out);


  // Print critical visible notices (even if sysShow=false)
  try {
    const pendingNotice = (L.visibleNotice || "").trim();
    if (pendingNotice) {
      notices.push(pendingNotice);
      L.visibleNotice = "";
    }
  } catch(_) {}
  const isCmd = LC.lcGetFlag("isCmd", false);
  const isRetry = LC.lcGetFlag("isRetry", false);
  const wantsRecap = LC.lcGetFlag("doRecap", false);
  const wantsEpoch = LC.lcGetFlag("doEpoch", false);

  // Opening — первичный захват
  if (L.turn === 0 && !L.openingCaptured && !isRetry && clean.length > 20) {
    LC.captureOpeningFromOutput(clean);
  }

  // Командный ответ: обработка /continue → SYS
  if (isCmd) {
    if (LC.lcGetFlag("acceptDraft", false)) {
      LC.lcSetFlag("acceptDraft", false);
      let saved = false;

      if (L.recapDraft) {
        const id = LC.createStoryCard(L.recapDraft.text, L.recapDraft.window, "recap");
        LC.lcSys(`✅ Recap saved (ID: ${id}).`);
        LC.syncRecapToStoryCards(L.recapDraft.text, L.recapDraft.window);
        L.recapDraft = null; L.lastRecapTurn = L.turn; saved = true;
      }
      if (L.epochDraft) {
        const id = LC.createStoryCard(L.epochDraft.text, L.epochDraft.window, "epoch");
        LC.lcSys(`✅ Epoch saved (ID: ${id}).`);
        L.epochDraft = null; L.lastEpochTurn = L.turn; saved = true;
      }
      if (!saved) LC.lcSys("ℹ️ No draft to save.");
    }

    LC.lcSetFlag("isCmd", false);
    const msgs = LC.lcConsumeMsgs();
    if (!msgs.length) return { text: LC.CONFIG.CMD_PLACEHOLDER + "\n" };
    return { text: msgs.join("\n") + "\n" + "=".repeat(40) + "\n" };
  }

  if (wantsRecap) LC.lcSetFlag("doRecap", false);
  if (wantsEpoch) LC.lcSetFlag("doEpoch", false);

  // Инкремент хода на реальном действии
  if (!isRetry && LC.shouldIncrementTurn()) {
    LC.incrementTurn();
  }
  L.lastOutput = clean;

  // Anti-echo
  const actionType = L.lastActionType || "";
  let filtered = clean;
  if (!isRetry) {
    filtered = LC.applyAntiEcho(clean, L.prevOutput, actionType);
    // Only update the anti-echo baseline when not retrying.
    L.prevOutput = filtered;
  }
  out = filtered;

  // Черновики (Recap/Epoch)
  const draftSource = out;
  if (wantsRecap) {
    if (draftSource.length > 50) {
      L.recapDraft = { text: draftSource, turn: L.turn, window: [Math.max(0, L.turn - L.cadence), L.turn] };
      L.tm.recaps = (L.tm.recaps || 0) + 1;
      L.tm.recapTurns = Array.isArray(L.tm.recapTurns) ? L.tm.recapTurns : [];
      L.tm.recapTurns.push(L.turn);
      const win = LC.CONFIG.RECAP_V2.AUTO_EPOCH_WINDOW;
      L.tm.recapTurns = L.tm.recapTurns.filter(t0 => (L.turn - t0) <= (win*2));
      LC.lcSys("📋 Recap draft created. Use /continue to save.");
    } else LC.lcSys("❌ Recap too short.");
  }
  if (wantsEpoch) {
    if (draftSource.length > 60) {
      L.epochDraft = { text: draftSource, turn: L.turn, window: [L.lastEpochTurn || 0, L.turn] };
      L.tm.epochs = (L.tm.epochs || 0) + 1;
      LC.lcSys("🗿 Epoch draft created. Use /continue to save.");
    } else LC.lcSys("❌ Epoch too short.");
  }

  // Пост-анализ (на реальном ходе)
  if (!isRetry) {
    try {
      LC.updateCharacterActivity(out, false);
      LC.analyzeTextForEvents(out, "output");
      LC.autoEvergreen.analyze(out, actionType);
    } catch (e) { LC.lcWarn("Post-analyze error: " + (e && e.message)); }
  }

  // Авто-оффер recap и авто-epoch
  if (!isRetry) {
    try { LC.checkRecapOfferV2(); } catch(e){ LC.lcWarn("RecapOfferV2 error: " + (e && e.message)); }
    try { LC.checkAutoEpoch(); }   catch(e){ LC.lcWarn("AutoEpoch error: " + (e && e.message)); }
  }

  // SYS: ВСЕГДА consume; показываем только если sysShow=true и это не retry
  {
    const msgs = LC.lcConsumeMsgs();
    if (!isRetry && L.sysShow && msgs.length) {
      out = out + "\n\n" + msgs.join("\n");
    }
  }

  // Capture notices that may have been set during processing (e.g., auto-epoch)
  {
    const postNotice = (L.visibleNotice || "").trim();
    if (postNotice) {
      notices.push(postNotice);
      L.visibleNotice = "";
    }
  }

  // Append any pending visible notices (including pre-cleared ones)
  if (notices.length) {
    try {
      for (const note of notices) {
        const trimmed = String(note || "").trim();
        if (!trimmed) continue;
        if (out.indexOf(trimmed) !== -1) continue;
        out = out ? out + "\n\n" + trimmed : trimmed;
      }
    } catch (_) {
      const fallback = notices.filter(n => n && String(n).trim());
      if (fallback.length) {
        const suffix = fallback.map(n => String(n).trim()).join("\n\n");
        out = out ? out + "\n\n" + suffix : suffix;
      }
    }
  }

  return { text: out };
};
return modifier(text);
